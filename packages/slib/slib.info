This is slib-3b5.info, produced by makeinfo version 4.13 from slib.texi.      |

This manual is for SLIB (version 3b5, January 2015), the portable             |
Scheme library.                                                               |

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* SLIB: (slib).         Scheme Library
END-INFO-DIR-ENTRY


File: slib-3b5.info,  Node: Top,  Next: The Library System,  Prev: (dir),  Up: (dir)
                                                                              |
SLIB
****

This manual is for SLIB (version 3b5, January 2015), the portable             |
Scheme library.                                                               |

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

* Menu:

* The Library System::          How to use and customize.
* Universal SLIB Procedures::   Provided for all implementations.
* Scheme Syntax Extension Packages::
* Textual Conversion Packages::
* Mathematical Packages::
* Database Packages::
* Other Packages::
* About SLIB::                  Install, etc.
* Index::


File: slib-3b5.info,  Node: The Library System,  Next: Universal SLIB Procedures,  Prev: Top,  Up: Top
                                                                              |
1 The Library System
********************

"SLIB" is a portable library for the programming language "Scheme".  It
provides a platform independent framework for using "packages" of
Scheme procedures and syntax.  As distributed, SLIB contains useful
packages for all Scheme implementations.  Its catalog can be
transparently extended to accomodate packages specific to a site,
implementation, user, or directory.

* Menu:

* Feature::                     SLIB names.
* Require::
* Library Catalogs::
* Catalog Creation::
* Catalog Vicinities::
* Compiling Scheme::


File: slib-3b5.info,  Node: Feature,  Next: Require,  Prev: The Library System,  Up: The Library System
                                                                              |
1.1 Feature
===========

SLIB denotes "features" by symbols.  SLIB maintains a list of features
supported by a Scheme "session".  The set of features provided by a
session may change during that session.  Some features are properties
of the Scheme implementation being used.  The following "intrinsic
feature"s detail what sort of numbers are available from an
implementation:

   * 'inexact

   * 'rational

   * 'real

   * 'complex

   * 'bignum

SLIB initialization (in `require.scm') tests and "provide"s any of
these numeric features which are appropriate.

Other features correspond to the presence of packages of Scheme
procedures or syntax (macros).

 -- Function: provided? feature
     Returns `#t' if FEATURE is present in the current Scheme session;
     otherwise `#f'.  More specifically, `provided?' returns `#t' if
     the symbol FEATURE is the `software-type', the
     `scheme-implementation-type' (1), or if FEATURE has been provided
     by a module already loaded; and `#f' otherwise.

     In some implementations `provided?' tests whether a module has
     been `require'd by any module or in any thread; other
     implementations will have `provided?' reflect only the modules
     `require'd by that particular session or thread.

     To work portably in both scenarios, use `provided?' only to test
     whether intrinsic properties (like those above) are present.

     The FEATURE argument can also be an expression calling `and',
     `or', and `not' of features.  The boolean result of the logical
     question asked by FEATURE is returned.

The generalization of `provided?' for arbitrary features and catalog is
`feature-eval':

 -- Function: feature-eval expression provided?
     Evaluates `and', `or', and `not' forms in EXPRESSION, using the
     values returned by calling PROVIDED?  on the leaf symbols.
     `feature-eval' returns the boolean result of the logical
     combinations.

 -- Procedure: provide feature
     Informs SLIB that FEATURE is supported in this session.

     (provided? 'foo)    => #f
     (provide 'foo)
     (provided? 'foo)    => #t

  ---------- Footnotes ----------

  (1) scheme-implementation-type is the name symbol of the running
Scheme implementation (RScheme, |STk|, Bigloo, chez, Elk, gambit,
gauche, guile, JScheme, kawa, MacScheme, MITScheme, Pocket-Scheme, S7,        |
Scheme48, Scheme->C, Scheme48, Scsh, SISC, T, umb-scheme, or Vscm).           |
Dependence on scheme-implementation-type is almost always the wrong way       |
to do things.                                                                 |


File: slib-3b5.info,  Node: Require,  Next: Library Catalogs,  Prev: Feature,  Up: The Library System
                                                                              |
1.2 Require
===========

SLIB creates and maintains a "catalog" mapping features to locations of
files introducing procedures and syntax denoted by those features.

 -- Variable: *catalog*
     Is an association list of features (symbols) and pathnames which
     will supply those features.  The pathname can be either a string
     or a pair.  If pathname is a pair then the first element should be
     a macro feature symbol, `source', `compiled', or one of the other
     cases described in *note Library Catalogs::.  The cdr of the
     pathname should be either a string or a list.

At the beginning of each section of this manual, there is a line like
`(require 'FEATURE)'.  The Scheme files comprising SLIB are cataloged
so that these feature names map to the corresponding files.

SLIB provides a form, `require', which loads the files providing the
requested feature.

 -- Procedure: require feature
        * If `(provided? FEATURE)' is true, then `require' just returns.

        * Otherwise, if FEATURE is found in the catalog, then the
          corresponding files will be loaded and `(provided?  FEATURE)'
          will henceforth return `#t'.  That FEATURE is thereafter
          `provided'.

        * Otherwise (FEATURE not found in the catalog), an error is
          signaled.

There is a related form `require-if', used primarily for enabling
compilers to statically include modules which would be dynamically
loaded by interpreters.

 -- Procedure: require-if condition feature
     Requires FEATURE if CONDITION is true.

The `random' module uses `require-if' to flag `object->string' as a
(dynamic) required module.

     (require 'byte)
     (require 'logical)
     (require-if 'compiling 'object->string)

The `batch' module uses `require-if' to flag `posix-time' as a module
to load if the implementation supports large precision exact integers.

     (require-if '(and bignum compiling) 'posix-time)

The catalog can also be queried using `slib:in-catalog?'.

 -- Function: slib:in-catalog? feature
     Returns a `CDR' of the catalog entry if one was found for the
     symbol FEATURE in the alist `*catalog*' (and transitively through
     any symbol aliases encountered).  Otherwise, returns `#f'.  The
     format of catalog entries is explained in *note Library Catalogs::.


File: slib-3b5.info,  Node: Library Catalogs,  Next: Catalog Creation,  Prev: Require,  Up: The Library System
                                                                              |
1.3 Library Catalogs
====================

Catalog files consist of one or more "association list"s.  In the
circumstance where a feature symbol appears in more than one list, the
latter list's association is retrieved.  Here are the supported formats
for elements of catalog lists:

`(FEATURE . <symbol>)'
     Redirects to the feature named <symbol>.

`(FEATURE . "<path>")'
     Loads file <path>.

`(FEATURE source "<path>")'
     `slib:load's the Scheme source file <path>.

`(FEATURE compiled "<path>" ...)'
     `slib:load-compiled's the files <path> ....

`(FEATURE aggregate <symbol> ...)'
     `require's the features <symbol> ....

The various macro styles first `require' the named macro package, then
just load <path> or load-and-macro-expand <path> as appropriate for the
implementation.

`(FEATURE defmacro "<path>")'
     `defmacro:load's the Scheme source file <path>.

`(FEATURE macro-by-example "<path>")'
     `defmacro:load's the Scheme source file <path>.

`(FEATURE macro "<path>")'
     `macro:load's the Scheme source file <path>.

`(FEATURE macros-that-work "<path>")'
     `macro:load's the Scheme source file <path>.

`(FEATURE syntax-case "<path>")'
     `macro:load's the Scheme source file <path>.

`(FEATURE syntactic-closures "<path>")'
     `macro:load's the Scheme source file <path>.


File: slib-3b5.info,  Node: Catalog Creation,  Next: Catalog Vicinities,  Prev: Library Catalogs,  Up: The Library System
                                                                              |
1.4 Catalog Creation
====================

At the start of an interactive session no catalog is present, but is
created with the first catalog inquiry (such as `(require 'random)').
Several sources of catalog information are combined to produce the
catalog:

   * standard SLIB packages.

   * additional packages of interest to this site.

   * packages specifically for the variety of Scheme which this session
     is running.  This catalog, if it exists, is the file `implcat' in
     `implementation-invicinity', which is created by loading
     `mkimpcat.scm' in `implementation-invicinity' if it exists.

   * packages this user wants to always have available.  This catalog
     is the file `homecat' in the user's "HOME" directory.  

   * packages germane to working in this (current working) directory.
     This catalog is the file `usercat' in the directory to which it
     applies.  One would typically `cd' to this directory before
     starting the Scheme session.

   * packages which are part of an application program.

SLIB combines the catalog information which doesn't vary per user into
the file `slibcat' in the implementation-vicinity.  Therefore `slibcat'
needs change only when new software is installed or compiled.  Because
the actual pathnames of files can differ from installation to
installation, SLIB builds a separate catalog for each implementation it
is used with.

The definition of `*slib-version*' in SLIB file `require.scm' is
checked against the catalog association of `*slib-version*' to
ascertain when versions have changed.  It is a reasonable practice to
change the definition of `*slib-version*' whenever the library is
changed.  If multiple implementations of Scheme use SLIB, remember that
recompiling one `slibcat' will update only that implementation's
catalog.

The compilation scripts of Scheme implementations which work with SLIB
can automatically trigger catalog compilation by deleting `slibcat' or
by invoking `require' of a special feature:

 -- Procedure: require 'new-catalog
     This will load `mklibcat', which compiles and writes a new
     `slibcat'.

Another special feature of `require' erases SLIB's catalog, forcing it
to be reloaded the next time the catalog is queried.

 -- Procedure: require #f
     Removes SLIB's catalog information.  This should be done before
     saving an executable image so that, when restored, its catalog
     will be loaded afresh.


File: slib-3b5.info,  Node: Catalog Vicinities,  Next: Compiling Scheme,  Prev: Catalog Creation,  Up: The Library System
                                                                              |
1.5 Catalog Vicinities
======================

Each file in the table below is descibed in terms of its file-system
independent "vicinity" (*note Vicinity::).  The entries of a catalog in
the table override those of catalogs above it in the table.

`implementation-vicinity' `slibcat'
     This file contains the associations for the packages comprising
     SLIB, the `implcat' and the `sitecat's.  The associations in the
     other catalogs override those of the standard catalog.

`library-vicinity' `mklibcat.scm'
     creates `slibcat'.

`library-vicinity' `sitecat'
     This file contains the associations specific to an SLIB
     installation.

`implementation-vicinity' `implcat'
     This file contains the associations specific to an implementation
     of Scheme.  Different implementations of Scheme should have
     different `implementation-vicinity'.

`implementation-vicinity' `mkimpcat.scm'
     if present, creates `implcat'.

`implementation-vicinity' `sitecat'
     This file contains the associations specific to a Scheme
     implementation installation.

`home-vicinity' `homecat'
     This file contains the associations specific to an SLIB user.

`user-vicinity' `usercat'
     This file contains associations affecting only those sessions whose
     "working directory" is `user-vicinity'.


Here is an example of a `usercat' catalog.  A program in this directory
can invoke the `run' feature with `(require 'run)'.

     ;;; "usercat": SLIB catalog additions for SIMSYNCH.     -*-scheme-*-
     (
      (simsynch      . "../synch/simsynch.scm")
      (run           . "../synch/run.scm")
      (schlep        . "schlep.scm")
     )

Copying `usercat' to many directories is inconvenient.  Application
programs which aren't always run in specially prepared directories can
nonetheless register their features during initialization.

 -- Procedure: catalog:read vicinity catalog
     Reads file named by string CATALOG in VICINITY, resolving all
     paths relative to VICINITY, and adds those feature associations to
     *CATALOG*.

     `catalog:read' would typically be used by an application program
     having dynamically loadable modules.  For instance, to register
     factoring and other modules in *CATALOG*, JACAL does:

          (catalog:read (program-vicinity) "jacalcat")


For an application program there are three appropriate venues for
registering its catalog associations:

   * in a `usercat' file in the directory where the program runs; or

   * in an `implcat' file in the `implementation-vicinity'; or

   * in an application program directory; loaded by calling
     `catalog:read'.


File: slib-3b5.info,  Node: Compiling Scheme,  Prev: Catalog Vicinities,  Up: The Library System
                                                                              |
1.6 Compiling Scheme
====================

To use Scheme compilers effectively with SLIB the compiler needs to
know which SLIB modules are to be compiled and which symbols are
exported from those modules.

  The procedures in this section automate the extraction of this
information from SLIB modules.  They are guaranteed to work on SLIB
modules; to use them on other sources, those sources should follow SLIB
conventions.

* Menu:

* Module Conventions::
* Module Manifests::
* Module Semantics::
* Top-level Variable References::
* Module Analysis::


File: slib-3b5.info,  Node: Module Conventions,  Next: Module Manifests,  Prev: Compiling Scheme,  Up: Compiling Scheme
                                                                              |
1.6.1 Module Conventions
------------------------

   * All the top-level `require' commands have one quoted argument and
     are positioned before other Scheme definitions and expressions in
     the file.

   * Any conditionally `require'd SLIB modules (1) also appear at the
     beginning of their files conditioned on the feature `compiling'
     using `require-if' (*note require-if: Require.).

          (require 'logical)
          (require 'multiarg/and-)
          (require-if 'compiling 'sort)
          (require-if 'compiling 'ciexyz)

   * Schmooz-style comments preceding a definition, identify that
     definition as an exported identifier (*note Schmooz::).  For
     non-schmooz files, putting `;@' at the beginning of the line
     immediately preceding the definition (`define', `define-syntax',
     or `defmacro') suffices.

          ;@
          (define (identity <obj>) <obj>)

   * Syntax (macro) definitions are grouped at the end of a module file.

   * Modules defining macros do not invoke those macros.  SLIB macro
     implementations are exempt from this rule.

     An example of how to expand macro invocations is:

          (require 'macros-that-work)
          (require 'yasos)
          (require 'pprint-file)
          (pprint-filter-file "collect.scm" macwork:expand)


  ---------- Footnotes ----------

  (1) There are some functions with internal `require' calls to delay
loading modules until they are needed.  While this reduces startup
latency for interpreters, it can produce headaches for compilers.


File: slib-3b5.info,  Node: Module Manifests,  Next: Module Semantics,  Prev: Module Conventions,  Up: Compiling Scheme
                                                                              |
1.6.2 Module Manifests
----------------------

`(require 'manifest)' 

In some of these examples, SLIB:CATALOG is the SLIB part of the
catalog; it is free of compiled and implementation-specific entries.
It would be defined by:

     (define slib:catalog (cdr (member (assq 'null *catalog*) *catalog*)))

 -- Function: file->requires file provided? catalog
     Returns a list of the features `require'd by FILE assuming the
     predicate PROVIDED? and association-list CATALOG.

     (define (provided+? . features)
       (lambda (feature)
         (or (memq feature features) (provided? feature))))

     (file->requires "obj2str.scm" (provided+? 'compiling) '())
             => (string-port generic-write)

     (file->requires "obj2str.scm" provided? '())
             => (string-port)

 -- Function: feature->requires feature provided? catalog
     Returns a list of the features `require'd by FEATURE assuming the
     predicate PROVIDED? and association-list CATALOG.

     (feature->requires 'batch (provided+? 'compiling) *catalog*)
             => (tree line-i/o databases parameters string-port
                        pretty-print common-list-functions posix-time)

     (feature->requires 'batch provided? *catalog*)
             => (tree line-i/o databases parameters string-port
                        pretty-print common-list-functions)

     (feature->requires 'batch provided? '((batch . "batch")))
             => (tree line-i/o databases parameters string-port
                        pretty-print common-list-functions)

 -- Function: feature->requires* feature provided? catalog
     Returns a list of the features transitively `require'd by FEATURE
     assuming the predicate PROVIDED? and association-list CATALOG.

 -- Function: file->requires* file provided? catalog
     Returns a list of the features transitively `require'd by FILE
     assuming the predicate PROVIDED? and association-list CATALOG.

 -- Function: file->loads file
     Returns a list of strings naming existing files loaded (load
     slib:load slib:load-source macro:load defmacro:load syncase:load
     synclo:load macwork:load) by FILE or any of the files it loads.

     (file->loads (in-vicinity (library-vicinity) "scainit.scm"))
             => ("/usr/local/lib/slib/scaexpp.scm"
                 "/usr/local/lib/slib/scaglob.scm"
                 "/usr/local/lib/slib/scaoutp.scm")

 -- Function: load->path exp
     Given a `(load '<expr>)', where <expr> is a string or vicinity
     stuff), `(load->path <expr>)' figures a path to the file.
     `load->path' returns that path if it names an existing file;
     otherwise #f.

     (load->path '(in-vicinity (library-vicinity) "mklibcat"))
             => "/usr/local/lib/slib/mklibcat.scm"

 -- Function: file->definitions file definer ...
     Returns a list of the identifier symbols defined by SLIB (or
     SLIB-style) file FILE.  The optional arguments DEFINERS should be
     symbols signifying a defining form.  If none are supplied, then
     the symbols `define-operation', `define', `define-syntax', and
     `defmacro' are captured.

     (file->definitions "random.scm")
             => (*random-state* make-random-state
                seed->random-state copy-random-state random
                random:chunk)

 -- Function: file->exports file definer ...
     Returns a list of the identifier symbols exported (advertised) by
     SLIB (or SLIB-style) file FILE.  The optional arguments DEFINERS
     should be symbols signifying a defining form.  If none are
     supplied, then the symbols `define-operation', `define',
     `define-syntax', and `defmacro' are captured.

     (file->exports "random.scm")
             => (make-random-state seed->random-state
                 copy-random-state random)

     (file->exports "randinex.scm")
             => (random:solid-sphere! random:hollow-sphere!
                 random:normal-vector! random:normal
                 random:exp random:uniform)

 -- Function: feature->export-alist feature catalog
     Returns a list of lists; each sublist holding the name of the file
     implementing FEATURE, and the identifier symbols exported
     (advertised) by SLIB (or SLIB-style) feature FEATURE, in CATALOG.

 -- Function: feature->exports feature catalog
     Returns a list of all exports of FEATURE.

In the case of `aggregate' features, more than one file may have export
lists to report:

     (feature->export-alist 'r5rs slib:catalog))
             => (("/usr/local/lib/slib/values.scm"
                  call-with-values values)
                 ("/usr/local/lib/slib/mbe.scm"
                  define-syntax macro:expand
                  macro:load macro:eval)
                 ("/usr/local/lib/slib/eval.scm"
                  eval scheme-report-environment
                  null-environment interaction-environment))

     (feature->export-alist 'stdio *catalog*)
             => (("/usr/local/lib/slib/scanf.scm"
                  fscanf sscanf scanf scanf-read-list)
                 ("/usr/local/lib/slib/printf.scm"
                  sprintf printf fprintf)
                 ("/usr/local/lib/slib/stdio.scm"
                  stderr stdout stdin))

     (feature->exports 'stdio slib:catalog)
             => (fscanf sscanf scanf scanf-read-list
                  sprintf printf fprintf stderr stdout stdin)


File: slib-3b5.info,  Node: Module Semantics,  Next: Top-level Variable References,  Prev: Module Manifests,  Up: Compiling Scheme
                                                                              |
1.6.3 Module Semantics
----------------------

For the purpose of compiling Scheme code, each top-level `require'
makes the identifiers exported by its feature's module `defined' (or
defmacroed or defined-syntaxed) within the file (being compiled) headed
with those requires.

  Top-level occurrences of `require-if' make defined the exports from
the module named by the second argument _if_ the FEATURE-EXPRESSION
first argument is true in the target environment.  The target feature
`compiling' should be provided during this phase of compilation.

  Non-top-level SLIB occurences of `require' and `require-if' of quoted
features can be ignored by compilers.  The SLIB modules will all have
top-level constructs for those features.

  Note that aggregate catalog entries import more than one module.
Implementations of `require' may or may _not_ be transitive; code which
uses module exports without requiring the providing module is in error.

  In the SLIB modules `modular', `batch', `hash', `common-lisp-time',
`commutative-ring', `charplot', `logical', `common-list-functions',
`coerce' and `break' there is code conditional on features being
`provided?'.  Most are testing for the presence of features which are
intrinsic to implementations (inexacts, bignums, ...).

  In all cases these `provided?' tests can be evaluated at compile-time
using `feature-eval' (*note feature-eval: Feature.).  The simplest way
to compile these constructs may be to treat `provided?' as a macro.


File: slib-3b5.info,  Node: Top-level Variable References,  Next: Module Analysis,  Prev: Module Semantics,  Up: Compiling Scheme
                                                                              |
1.6.4 Top-level Variable References
-----------------------------------

`(require 'top-refs)' 

These procedures complement those in *note Module Manifests:: by
finding the top-level variable references in Scheme source code.  They
work by traversing expressions and definitions, keeping track of
bindings encountered.  It is certainly possible to foil these
functions, but they return useful information about SLIB source code.

 -- Function: top-refs obj
     Returns a list of the top-level variables referenced by the Scheme
     expression OBJ.

 -- Function: top-refs<-file filename
     FILENAME should be a string naming an existing file containing
     Scheme source code.  `top-refs<-file' returns a list of the
     top-level variable references made by expressions in the file
     named by FILENAME.

     Code in modules which FILENAME `require's is not traversed.  Code
     in files loaded from top-level _is_ traversed if the expression
     argument to `load', `slib:load', `slib:load-source', `macro:load',
     `defmacro:load', `synclo:load', `syncase:load', or `macwork:load'
     is a literal string constant or composed of combinations of
     vicinity functions and string literal constants; and the resulting
     file exists (possibly with ".scm" appended).

The following function parses an "Info" Index.  (1)

 -- Function: exports<-info-index file n ...
     N ... must be an increasing series of positive integers.
     `exports<-info-index' returns a list of all the identifiers
     appearing in the Nth ... (info) indexes of FILE.  The identifiers
     have the case that the implementation's `read' uses for symbols.
     Identifiers containing spaces (eg. `close-base on base-table') are
     _not_ included.  #f is returned if the index is not found.

     Each info index is headed by a `* Menu:' line.  To list the
     symbols in the first and third info indexes do:

          (exports<-info-index "slib.info" 1 3)

  ---------- Footnotes ----------

  (1) Although it will work on large info files, feeding it an excerpt
is much faster; and has less chance of being confused by unusual text
in the info file.  This command excerpts the SLIB index into
`slib-index.info':

     info -f slib2d6.info -n "Index" -o slib-index.info


File: slib-3b5.info,  Node: Module Analysis,  Prev: Top-level Variable References,  Up: Compiling Scheme
                                                                              |
1.6.5 Module Analysis
---------------------

`(require 'vet)' 

 -- Function: vet-slib file1 ...
     Using the procedures in the `top-refs' and `manifest' modules,
     `vet-slib' analyzes each SLIB module and FILE1, ..., reporting
     about any procedure or macro defined whether it is:

    orphaned
          defined, not called, not exported;

    missing
          called, not defined, and not exported by its `require'd
          modules;

    undocumented-export
          Exported by module, but no index entry in `slib.info';


     And for the library as a whole:

    documented-unexport
          Index entry in `slib.info', but no module exports it.


     This straightforward analysis caught three full days worth of
     never-executed branches, transitive require assumptions, spelling
     errors, undocumented procedures, missing procedures, and cyclic
     dependencies in SLIB.

     The optional arguments FILE1, ... provide a simple way to vet
     prospective SLIB modules.


File: slib-3b5.info,  Node: Universal SLIB Procedures,  Next: Scheme Syntax Extension Packages,  Prev: The Library System,  Up: Top
                                                                              |
2 Universal SLIB Procedures
***************************

The procedures described in these sections are supported by all
implementations as part of the `*.init' files or by `require.scm'.

* Menu:

* Vicinity::                    Pathname Management
* Configuration::               Characteristics of Scheme Implementation
* Input/Output::                Things not provided by the Scheme specs.
* System::                      LOADing, EVALing, ERRORing, and EXITing
* Miscellany::


File: slib-3b5.info,  Node: Vicinity,  Next: Configuration,  Prev: Universal SLIB Procedures,  Up: Universal SLIB Procedures
                                                                              |
2.1 Vicinity
============

A vicinity is a descriptor for a place in the file system.  Vicinities
hide from the programmer the concepts of host, volume, directory, and
version.  Vicinities express only the concept of a file environment
where a file name can be resolved to a file in a system independent
manner.  Vicinities can even be used on "flat" file systems (which have
no directory structure) by having the vicinity express constraints on
the file name.

  All of these procedures are file-system dependent.  Use of these
vicinity procedures can make programs file-system _in_dependent.

These procedures are provided by all implementations.  On most systems
a vicinity is a string.

 -- Function: make-vicinity dirpath
     Returns DIRPATH as a vicinity for use as first argument to
     `in-vicinity'.

 -- Function: pathname->vicinity path
     Returns the vicinity containing PATH.
          (pathname->vicinity "/usr/local/lib/scm/Link.scm")
                              => "/usr/local/lib/scm/"

 -- Function: program-vicinity
     Returns the vicinity of the currently loading Scheme code.  For an
     interpreter this would be the directory containing source code.
     For a compiled system (with multiple files) this would be the
     directory where the object or executable files are.  If no file is
     currently loading, then the result is undefined.  *Warning:*
     `program-vicinity' can return incorrect values if your program
     escapes back into a `load' continuation.

 -- Function: library-vicinity
     Returns the vicinity of the shared Scheme library.

 -- Function: implementation-vicinity
     Returns the vicinity of the underlying Scheme implementation.  This
     vicinity will likely contain startup code and messages and a
     compiler.

 -- Function: user-vicinity
     Returns the vicinity of the current directory of the user.  On most
     systems this is `""' (the empty string).

 -- Function: home-vicinity
     Returns the vicinity of the user's "HOME" directory, the directory which
     typically contains files which customize a computer environment
     for a user.  If scheme is running without a user (eg. a daemon) or
     if this concept is meaningless for the platform, then
     `home-vicinity' returns `#f'.

 -- Function: vicinity:suffix? chr
     Returns the `#t' if CHR is a vicinity suffix character; and `#f'
     otherwise.  Typical vicinity suffixes are `/', `:', and `\',

 -- Function: in-vicinity vicinity filename
     Returns a filename suitable for use by `slib:load',
     `slib:load-source', `slib:load-compiled', `open-input-file',
     `open-output-file', etc.  The returned filename is FILENAME in
     VICINITY.  `in-vicinity' should allow FILENAME to override
     VICINITY when FILENAME is an absolute pathname and VICINITY is
     equal to the value of `(user-vicinity)'.  The behavior of
     `in-vicinity' when FILENAME is absolute and VICINITY is not equal
     to the value of `(user-vicinity)' is unspecified.  For most systems
     `in-vicinity' can be `string-append'.

 -- Function: sub-vicinity vicinity name
     Returns the vicinity of VICINITY restricted to NAME.  This is used
     for large systems where names of files in subsystems could
     conflict.  On systems with directory structure `sub-vicinity' will
     return a pathname of the subdirectory NAME of VICINITY.

 -- Function: with-load-pathname path thunk
     PATH should be a string naming a file being read or loaded.
     `with-load-pathname' evaluates THUNK in a dynamic scope where an
     internal variable is bound to PATH; the internal variable is used
     for messages and `program-vicinity'.  `with-load-pathname' returns
     the value returned by THUNK.


File: slib-3b5.info,  Node: Configuration,  Next: Input/Output,  Prev: Vicinity,  Up: Universal SLIB Procedures
                                                                              |
2.2 Configuration
=================

These constants and procedures describe characteristics of the Scheme
and underlying operating system.  They are provided by all
implementations.

 -- Constant: char-code-limit
     An integer 1 larger that the largest value which can be returned by
     `char->integer'.

 -- Constant: most-positive-fixnum
     In implementations which support integers of practically unlimited
     size, MOST-POSITIVE-FIXNUM is a large exact integer within the
     range of exact integers that may result from computing the length
     of a list, vector, or string.

     In implementations which do not support integers of practically
     unlimited size, MOST-POSITIVE-FIXNUM is the largest exact integer
     that may result from computing the length of a list, vector, or
     string.

 -- Constant: slib:tab
     The tab character.

 -- Constant: slib:form-feed
     The form-feed character.

 -- Function: software-type
     Returns a symbol denoting the generic operating system type.  For
     instance, `unix', `vms', `macos', `amiga', or `ms-dos'.

 -- Function: slib:report-version
     Displays the versions of SLIB and the underlying Scheme
     implementation and the name of the operating system.  An
     unspecified value is returned.

          (slib:report-version) => slib "3b5" on scm "5b1" on unix            |

 -- Function: slib:report
     Displays the information of `(slib:report-version)' followed by
     almost all the information neccessary for submitting a problem
     report.  An unspecified value is returned.

 -- Function: slib:report #t
     provides a more verbose listing.

 -- Function: slib:report filename
     Writes the verbose report to file `filename'.

          (slib:report)
          =>
          slib "3b5" on scm "5b1" on unix                                     |
          (implementation-vicinity) is "/usr/local/lib/scm/"
          (library-vicinity) is "/usr/local/lib/slib/"
          (scheme-file-suffix) is ".scm"
          loaded slib:features :
                  trace alist qp sort
                  common-list-functions macro values getopt
                  compiled
          implementation slib:features :
                  bignum complex real rational
                  inexact vicinity ed getenv
                  tmpnam abort transcript with-file
                  ieee-p1178 r4rs rev4-optional-procedures hash
                  object-hash delay eval dynamic-wind
                  multiarg-apply multiarg/and- logical defmacro
                  string-port source current-time record
                  rev3-procedures rev2-procedures sun-dl string-case
                  array dump char-ready? full-continuation
                  system
          implementation *catalog* :
                  (i/o-extensions compiled "/usr/local/lib/scm/ioext.so")
                  ...


File: slib-3b5.info,  Node: Input/Output,  Next: System,  Prev: Configuration,  Up: Universal SLIB Procedures
                                                                              |
2.3 Input/Output
================

These procedures are provided by all implementations.

 -- Function: file-exists? filename
     Returns `#t' if the specified file exists.  Otherwise, returns
     `#f'.  If the underlying implementation does not support this
     feature then `#f' is always returned.

 -- Function: delete-file filename
     Deletes the file specified by FILENAME.  If FILENAME can not be
     deleted, `#f' is returned.  Otherwise, `#t' is returned.

 -- Function: open-file filename modes
     FILENAME should be a string naming a file.  `open-file' returns a
     port depending on the symbol MODES:

    r
          an input port capable of delivering characters from the file.

    rb
          a _binary_ input port capable of delivering characters from
          the file.

    w
          an output port capable of writing characters to a new file by
          that name.

    wb
          a _binary_ output port capable of writing characters to a new
          file by that name.

     If an implementation does not distinguish between binary and
     non-binary files, then it must treat rb as r and wb as w.

     If the file cannot be opened, either #f is returned or an error is
     signalled.  For output, if a file with the given name already
     exists, the effect is unspecified.

 -- Function: port? obj
     Returns #t if OBJ is an input or output port, otherwise returns #f.

 -- Procedure: close-port port
     Closes the file associated with PORT, rendering the PORT incapable
     of delivering or accepting characters.

     `close-file' has no effect if the file has already been closed.
     The value returned is unspecified.

 -- Function: call-with-open-ports proc ports ...
 -- Function: call-with-open-ports ports ... proc
     PROC should be a procedure that accepts as many arguments as there
     are PORTS passed to `call-with-open-ports'.
     `call-with-open-ports' calls PROC with PORTS ....  If PROC
     returns, then the ports are closed automatically and the value
     yielded by the PROC is returned.  If PROC does not return, then
     the ports will not be closed automatically unless it is possible
     to prove that the ports will never again be used for a read or
     write operation.

 -- Function: tmpnam
     Returns a pathname for a file which will likely not be used by any
     other process.  Successive calls to `(tmpnam)' will return
     different pathnames.

 -- Function: current-error-port
     Returns the current port to which diagnostic and error output is
     directed.

 -- Procedure: force-output
 -- Procedure: force-output port
     Forces any pending output on PORT to be delivered to the output
     device and returns an unspecified value.  The PORT argument may be
     omitted, in which case it defaults to the value returned by
     `(current-output-port)'.

 -- Function: file-position port
 -- Function: file-position port #f
     PORT must be open to a file.  `file-position' returns the current
     position of the character in PORT which will next be read or
     written.  If the implementation does not support file-position,
     then `#f' is returned.

 -- Function: file-position port k
     PORT must be open to a file.  `file-position' sets the current
     position in PORT which will next be read or written.  If
     successful, `#t' is returned; otherwise `file-position' returns
     `#f'.

 -- Function: output-port-width
 -- Function: output-port-width port
     Returns the width of PORT, which defaults to
     `(current-output-port)' if absent.  If the width cannot be
     determined 79 is returned.

 -- Function: output-port-height
 -- Function: output-port-height port
     Returns the height of PORT, which defaults to
     `(current-output-port)' if absent.  If the height cannot be
     determined 24 is returned.


File: slib-3b5.info,  Node: System,  Next: Miscellany,  Prev: Input/Output,  Up: Universal SLIB Procedures
                                                                              |
2.4 System
==========

These procedures are provided by all implementations.

 -- Procedure: slib:load-source name
     Loads a file of Scheme source code from NAME with the default
     filename extension used in SLIB.  For instance if the filename
     extension used in SLIB is `.scm' then `(slib:load-source "foo")'
     will load from file `foo.scm'.

 -- Procedure: slib:load-compiled name
     On implementations which support separtely loadable compiled
     modules, loads a file of compiled code from NAME with the
     implementation's filename extension for compiled code appended.

 -- Procedure: slib:load name
     Loads a file of Scheme source or compiled code from NAME with the
     appropriate suffixes appended.  If both source and compiled code
     are present with the appropriate names then the implementation
     will load just one.  It is up to the implementation to choose
     which one will be loaded.

     If an implementation does not support compiled code then
     `slib:load' will be identical to `slib:load-source'.

 -- Procedure: slib:eval obj
     `eval' returns the value of OBJ evaluated in the current top level
     environment.  *note Eval:: provides a more general evaluation
     facility.

 -- Procedure: slib:eval-load filename eval
     FILENAME should be a string.  If filename names an existing file,
     the Scheme source code expressions and definitions are read from
     the file and EVAL called with them sequentially.  The
     `slib:eval-load' procedure does not affect the values returned by
     `current-input-port', `current-error-port', and
     `current-output-port'.

 -- Procedure: slib:warn arg1 arg2 ...
     Outputs a warning message containing the arguments.

 -- Procedure: slib:error arg1 arg2 ...
     Outputs an error message containing the arguments, aborts
     evaluation of the current form and responds in a system dependent
     way to the error.  Typical responses are to abort the program or
     to enter a read-eval-print loop.

 -- Procedure: slib:exit n
 -- Procedure: slib:exit
     Exits from the Scheme session returning status N to the system.
     If N is omitted or `#t', a success status is returned to the
     system (if possible).  If N is `#f' a failure is returned to the
     system (if possible).  If N is an integer, then N is returned to
     the system (if possible).  If the Scheme session cannot exit, then
     an unspecified value is returned from `slib:exit'.

 -- Function: browse-url url
     Web browsers have become so ubiquitous that programming languagues
     should support a uniform interface to them.

     If a browser is running, `browse-url' causes the browser to
     display the page specified by string URL and returns `#t'.

     If the browser is not running, `browse-url' starts a browser
     displaying the argument URL.  If the browser starts as a
     background job, `browse-url' returns `#t' immediately; if the
     browser starts as a foreground job, then `browse-url' returns `#t'
     when the browser exits; otherwise (if no browser) it returns `#f'.


File: slib-3b5.info,  Node: Miscellany,  Prev: System,  Up: Universal SLIB Procedures
                                                                              |
2.5 Miscellany
==============

These procedures are provided by all implementations.

 -- Function: identity x
     IDENTITY returns its argument.

     Example:
          (identity 3)
             => 3
          (identity '(foo bar))
             => (foo bar)
          (map identity LST)
             == (copy-list LST)

2.5.1 Mutual Exclusion
----------------------

An "exchanger" is a procedure of one argument regulating mutually exclusive
access to a resource.  When a exchanger is called, its current content
is returned, while being replaced by its argument in an atomic
operation.

 -- Function: make-exchanger obj
     Returns a new exchanger with the argument OBJ as its initial
     content.

          (define queue (make-exchanger (list a)))

     A queue implemented as an exchanger holding a list can be
     protected from reentrant execution thus:

          (define (pop queue)
            (let ((lst #f))
              (dynamic-wind
                  (lambda () (set! lst (queue #f)))
                  (lambda () (and lst (not (null? lst))
                                  (let ((ret (car lst)))
                                    (set! lst (cdr lst))
                                    ret)))
                  (lambda () (and lst (queue lst))))))

          (pop queue)         => a

          (pop queue)         => #f

2.5.2 Legacy
------------

The following procedures were present in Scheme until R4RS (*note
Language changes: (r4rs)Notes.).  They are provided by all SLIB
implementations.

 -- Constant: t
     Defined as `#t'.

 -- Constant: nil
     Defined as `#f'.

 -- Function: last-pair l
     Returns the last pair in the list L.  Example:
          (last-pair (cons 1 2))
             => (1 . 2)
          (last-pair '(1 2))
             => (2)
              == (cons 2 '())


File: slib-3b5.info,  Node: Scheme Syntax Extension Packages,  Next: Textual Conversion Packages,  Prev: Universal SLIB Procedures,  Up: Top
                                                                              |
3 Scheme Syntax Extension Packages
**********************************

* Menu:

* Defmacro::                    Supported by all implementations

* R4RS Macros::                 'macro
* Macro by Example::            'macro-by-example
* Macros That Work::            'macros-that-work
* Syntactic Closures::          'syntactic-closures
* Syntax-Case Macros::          'syntax-case

Syntax extensions (macros) included with SLIB.

* Define-Structure::            'structure
* Define-Record-Type::          'define-record-type, 'srfi-9
* Fluid-Let::                   'fluid-let
* Parameter Objects::           'srfi-39
* Binding to multiple values::  'receive, 'srfi-8
* Guarded LET* special form::   'and-let*, 'srfi-2
* Guarded COND Clause::         'guarded-cond-clause, 'srfi-61
* Yasos::                       'yasos, 'oop, 'collect


File: slib-3b5.info,  Node: Defmacro,  Next: R4RS Macros,  Prev: Scheme Syntax Extension Packages,  Up: Scheme Syntax Extension Packages
                                                                              |
3.1 Defmacro
============

Defmacros are supported by all implementations.

 -- Function: gentemp
     Returns a new (interned) symbol each time it is called.  The symbol
     names are implementation-dependent
          (gentemp) => scm:G0
          (gentemp) => scm:G1

 -- Function: defmacro:eval e
     Returns the `slib:eval' of expanding all defmacros in scheme
     expression E.

 -- Function: defmacro:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `defmacro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain defmacro
     definitions.  The `defmacro:load' procedure does not affect the
     values returned by `current-input-port', `current-error-port', and
     `current-output-port'.

 -- Function: defmacro? sym
     Returns `#t' if SYM has been defined by `defmacro', `#f' otherwise.

 -- Function: macroexpand-1 form
 -- Function: macroexpand form
     If FORM is a macro call, `macroexpand-1' will expand the macro
     call once and return it.  A FORM is considered to be a macro call
     only if it is a cons whose `car' is a symbol for which a
     `defmacro' has been defined.

     `macroexpand' is similar to `macroexpand-1', but repeatedly
     expands FORM until it is no longer a macro call.

 -- Macro: defmacro name lambda-list form ...
     When encountered by `defmacro:eval', `defmacro:macroexpand*', or
     `defmacro:load' defines a new macro which will henceforth be
     expanded when encountered by `defmacro:eval',
     `defmacro:macroexpand*', or `defmacro:load'.

3.1.1 Defmacroexpand
--------------------

`(require 'defmacroexpand)' 

 -- Function: defmacro:expand* e
     Returns the result of expanding all defmacros in scheme expression
     E.


File: slib-3b5.info,  Node: R4RS Macros,  Next: Macro by Example,  Prev: Defmacro,  Up: Scheme Syntax Extension Packages
                                                                              |
3.2 R4RS Macros
===============

`(require 'macro)' is the appropriate call if you want R4RS high-level
macros but don't care about the low level implementation.  If an SLIB
R4RS macro implementation is already loaded it will be used.
Otherwise, one of the R4RS macros implemetations is loaded.

  The SLIB R4RS macro implementations support the following uniform
interface:

 -- Function: macro:expand sexpression
     Takes an R4RS expression, macro-expands it, and returns the result
     of the macro expansion.

 -- Function: macro:eval sexpression
     Takes an R4RS expression, macro-expands it, evals the result of the
     macro expansion, and returns the result of the evaluation.

 -- Procedure: macro:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port', `current-error-port', and
     `current-output-port'.


File: slib-3b5.info,  Node: Macro by Example,  Next: Macros That Work,  Prev: R4RS Macros,  Up: Scheme Syntax Extension Packages
                                                                              |
3.3 Macro by Example
====================

`(require 'macro-by-example)' 

  A vanilla implementation of `Macro by Example' (Eugene Kohlbecker,
R4RS) by Dorai Sitaram, (dorai @ cs.rice.edu) using `defmacro'.

   * generating hygienic global `define-syntax' Macro-by-Example macros
     *cheaply*.

   * can define macros which use `...'.

   * needn't worry about a lexical variable in a macro definition
     clashing with a variable from the macro use context

   * don't suffer the overhead of redefining the repl if `defmacro'
     natively supported (most implementations)


3.3.1 Caveat
------------

These macros are not referentially transparent (*note Macros:
(r4rs)Macros.).  Lexically scoped macros (i.e., `let-syntax' and
`letrec-syntax') are not supported.  In any case, the problem of
referential transparency gains poignancy only when `let-syntax' and
`letrec-syntax' are used.  So you will not be courting large-scale
disaster unless you're using system-function names as local variables
with unintuitive bindings that the macro can't use.  However, if you
must have the full `r4rs' macro functionality, look to the more
featureful (but also more expensive) versions of syntax-rules available
in slib *note Macros That Work::, *note Syntactic Closures::, and *note
Syntax-Case Macros::.

 -- Macro: define-syntax keyword transformer-spec
     The KEYWORD is an identifier, and the TRANSFORMER-SPEC should be
     an instance of `syntax-rules'.

     The top-level syntactic environment is extended by binding the
     KEYWORD to the specified transformer.

          (define-syntax let*
            (syntax-rules ()
              ((let* () body1 body2 ...)
               (let () body1 body2 ...))
              ((let* ((name1 val1) (name2 val2) ...)
                 body1 body2 ...)
               (let ((name1 val1))
                 (let* (( name2 val2) ...)
                   body1 body2 ...)))))

 -- Macro: syntax-rules literals syntax-rule ...
     LITERALS is a list of identifiers, and each SYNTAX-RULE should be
     of the form

     `(PATTERN TEMPLATE)'

     where the PATTERN and  TEMPLATE are as in the grammar above.

     An instance of `syntax-rules' produces a new macro transformer by
     specifying a sequence of hygienic rewrite rules.  A use of a macro
     whose keyword is associated with a transformer specified by
     `syntax-rules' is matched against the patterns contained in the
     SYNTAX-RULEs, beginning with the leftmost SYNTAX-RULE.  When a
     match is found, the macro use is trancribed hygienically according
     to the template.

     Each pattern begins with the keyword for the macro.  This keyword
     is not involved in the matching and is not considered a pattern
     variable or literal identifier.


File: slib-3b5.info,  Node: Macros That Work,  Next: Syntactic Closures,  Prev: Macro by Example,  Up: Scheme Syntax Extension Packages
                                                                              |
3.4 Macros That Work
====================

`(require 'macros-that-work)' 

  `Macros That Work' differs from the other R4RS macro implementations
in that it does not expand derived expression types to primitive
expression types.

 -- Function: macro:expand expression
 -- Function: macwork:expand expression
     Takes an R4RS expression, macro-expands it, and returns the result
     of the macro expansion.

 -- Function: macro:eval expression
 -- Function: macwork:eval expression
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 -- Procedure: macro:load filename
 -- Procedure: macwork:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port', `current-error-port', and
     `current-output-port'.

  References:

  The `Revised^4 Report on the Algorithmic Language Scheme' Clinger and
Rees [editors].  To appear in LISP Pointers.  Also available as a
technical report from the University of Oregon, MIT AI Lab, and Cornell.

            Macros That Work.  Clinger and Rees.  POPL '91.

  The supported syntax differs from the R4RS in that vectors are allowed
as patterns and as templates and are not allowed as pattern or template
data.

     transformer spec  ==>  (syntax-rules literals rules)

     rules  ==>  ()
              |  (rule . rules)

     rule  ==>  (pattern template)

     pattern  ==>  pattern_var      ; a symbol not in literals
                |  symbol           ; a symbol in literals
                |  ()
                |  (pattern . pattern)
                |  (ellipsis_pattern)
                |  #(pattern*)                     ; extends R4RS
                |  #(pattern* ellipsis_pattern)    ; extends R4RS
                |  pattern_datum

     template  ==>  pattern_var
                 |  symbol
                 |  ()
                 |  (template2 . template2)
                 |  #(template*)                   ; extends R4RS
                 |  pattern_datum

     template2  ==>  template
                  |  ellipsis_template

     pattern_datum  ==>  string                    ; no vector
                      |  character
                      |  boolean
                      |  number

     ellipsis_pattern  ==> pattern ...

     ellipsis_template  ==>  template ...

     pattern_var  ==>  symbol   ; not in literals

     literals  ==>  ()
                 |  (symbol . literals)

3.4.1 Definitions
-----------------

Scope of an ellipsis
     Within a pattern or template, the scope of an ellipsis (`...') is
     the pattern or template that appears to its left.

Rank of a pattern variable
     The rank of a pattern variable is the number of ellipses within
     whose scope it appears in the pattern.

Rank of a subtemplate
     The rank of a subtemplate is the number of ellipses within whose
     scope it appears in the template.

Template rank of an occurrence of a pattern variable
     The template rank of an occurrence of a pattern variable within a
     template is the rank of that occurrence, viewed as a subtemplate.

Variables bound by a pattern
     The variables bound by a pattern are the pattern variables that
     appear within it.

Referenced variables of a subtemplate
     The referenced variables of a subtemplate are the pattern
     variables that appear within it.

Variables opened by an ellipsis template
     The variables opened by an ellipsis template are the referenced
     pattern variables whose rank is greater than the rank of the
     ellipsis template.


3.4.2 Restrictions
------------------

No pattern variable appears more than once within a pattern.

  For every occurrence of a pattern variable within a template, the
template rank of the occurrence must be greater than or equal to the
pattern variable's rank.

  Every ellipsis template must open at least one variable.

  For every ellipsis template, the variables opened by an ellipsis
template must all be bound to sequences of the same length.

  The compiled form of a RULE is

     rule  ==>  (pattern template inserted)

     pattern  ==>  pattern_var
                |  symbol
                |  ()
                |  (pattern . pattern)
                |  ellipsis_pattern
                |  #(pattern)
                |  pattern_datum

     template  ==>  pattern_var
                 |  symbol
                 |  ()
                 |  (template2 . template2)
                 |  #(pattern)
                 |  pattern_datum

     template2  ==>  template
                  |  ellipsis_template

     pattern_datum  ==>  string
                      |  character
                      |  boolean
                      |  number

     pattern_var  ==>  #(V symbol rank)

     ellipsis_pattern  ==>  #(E pattern pattern_vars)

     ellipsis_template  ==>  #(E template pattern_vars)

     inserted  ==>  ()
                 |  (symbol . inserted)

     pattern_vars  ==>  ()
                     |  (pattern_var . pattern_vars)

     rank  ==>  exact non-negative integer

  where V and E are unforgeable values.

  The pattern variables associated with an ellipsis pattern are the
variables bound by the pattern, and the pattern variables associated
with an ellipsis template are the variables opened by the ellipsis
template.

  If the template contains a big chunk that contains no pattern
variables or inserted identifiers, then the big chunk will be copied
unnecessarily.  That shouldn't matter very often.


File: slib-3b5.info,  Node: Syntactic Closures,  Next: Syntax-Case Macros,  Prev: Macros That Work,  Up: Scheme Syntax Extension Packages
                                                                              |
3.5 Syntactic Closures
======================

`(require 'syntactic-closures)' 

 -- Function: macro:expand expression
 -- Function: synclo:expand expression
     Returns scheme code with the macros and derived expression types of
     EXPRESSION expanded to primitive expression types.

 -- Function: macro:eval expression
 -- Function: synclo:eval expression
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 -- Procedure: macro:load filename
 -- Procedure: synclo:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port', `current-error-port', and
     `current-output-port'.

3.5.1 Syntactic Closure Macro Facility
--------------------------------------

                  A Syntactic Closures Macro Facility
                            by Chris Hanson
                            9 November 1991

  This document describes "syntactic closures", a low-level macro
facility for the Scheme programming language.  The facility is an
alternative to the low-level macro facility described in the `Revised^4
Report on Scheme.' This document is an addendum to that report.

  The syntactic closures facility extends the BNF rule for TRANSFORMER
SPEC to allow a new keyword that introduces a low-level macro
transformer:

     TRANSFORMER SPEC := (transformer EXPRESSION)

  Additionally, the following procedures are added:
     make-syntactic-closure
     capture-syntactic-environment
     identifier?
     identifier=?

  The description of the facility is divided into three parts.  The
first part defines basic terminology.  The second part describes how
macro transformers are defined.  The third part describes the use of
"identifiers", which extend the syntactic closure mechanism to be
compatible with `syntax-rules'.

3.5.1.1 Terminology
...................

This section defines the concepts and data types used by the syntactic
closures facility.

   * "Forms" are the syntactic entities out of which programs are
     recursively constructed.  A form is any expression, any
     definition, any syntactic keyword, or any syntactic closure.  The
     variable name that appears in a `set!' special form is also a
     form.  Examples of forms:

          17
          #t
          car
          (+ x 4)
          (lambda (x) x)
          (define pi 3.14159)
          if
          define

   * An "alias" is an alternate name for a given symbol.  It can appear
     anywhere in a form that the symbol could be used, and when quoted
     it is replaced by the symbol; however, it does not satisfy the
     predicate `symbol?'.  Macro transformers rarely distinguish
     symbols from aliases, referring to both as identifiers.

   * A "syntactic" environment maps identifiers to their meanings.
     More precisely, it determines whether an identifier is a syntactic
     keyword or a variable.  If it is a keyword, the meaning is an
     interpretation for the form in which that keyword appears.  If it
     is a variable, the meaning identifies which binding of that
     variable is referenced.  In short, syntactic environments contain
     all of the contextual information necessary for interpreting the
     meaning of a particular form.

   * A "syntactic closure" consists of a form, a syntactic environment,
     and a list of identifiers.  All identifiers in the form take their
     meaning from the syntactic environment, except those in the given
     list.  The identifiers in the list are to have their meanings
     determined later.  A syntactic closure may be used in any context
     in which its form could have been used.  Since a syntactic closure
     is also a form, it may not be used in contexts where a form would
     be illegal.  For example, a form may not appear as a clause in the
     cond special form.  A syntactic closure appearing in a quoted
     structure is replaced by its form.


3.5.1.2 Transformer Definition
..............................

This section describes the `transformer' special form and the
procedures `make-syntactic-closure' and `capture-syntactic-environment'.

 -- Syntax: transformer expression
     Syntax: It is an error if this syntax occurs except as a
     TRANSFORMER SPEC.

     Semantics: The EXPRESSION is evaluated in the standard transformer
     environment to yield a macro transformer as described below.  This
     macro transformer is bound to a macro keyword by the special form
     in which the `transformer' expression appears (for example,
     `let-syntax').

     A "macro transformer" is a procedure that takes two arguments, a
     form and a syntactic environment, and returns a new form.  The
     first argument, the "input form", is the form in which the macro
     keyword occurred.  The second argument, the "usage environment",
     is the syntactic environment in which the input form occurred.
     The result of the transformer, the "output form", is automatically
     closed in the "transformer environment", which is the syntactic
     environment in which the `transformer' expression occurred.

     For example, here is a definition of a push macro using
     `syntax-rules':

          (define-syntax  push
            (syntax-rules ()
              ((push item list)
               (set! list (cons item list)))))

     Here is an equivalent definition using `transformer':
          (define-syntax push
            (transformer
             (lambda (exp env)
               (let ((item
                      (make-syntactic-closure env '() (cadr exp)))
                     (list
                      (make-syntactic-closure env '() (caddr exp))))
                 `(set! ,list (cons ,item ,list))))))

     In this example, the identifiers `set!' and `cons' are closed in
     the transformer environment, and thus will not be affected by the
     meanings of those identifiers in the usage environment `env'.

     Some macros may be non-hygienic by design.  For example, the
     following defines a loop macro that implicitly binds `exit' to an
     escape procedure.  The binding of `exit' is intended to capture
     free references to `exit' in the body of the loop, so `exit' must
     be left free when the body is closed:

          (define-syntax loop
            (transformer
             (lambda (exp env)
               (let ((body (cdr exp)))
                 `(call-with-current-continuation
                   (lambda (exit)
                     (let f ()
                       ,@(map (lambda  (exp)
                                 (make-syntactic-closure env '(exit)
                                                         exp))
                               body)
                       (f))))))))

     To assign meanings to the identifiers in a form, use
     `make-syntactic-closure' to close the form in a syntactic
     environment.

 -- Function: make-syntactic-closure environment free-names form
     ENVIRONMENT must be a syntactic environment, FREE-NAMES must be a
     list of identifiers, and FORM must be a form.
     `make-syntactic-closure' constructs and returns a syntactic closure
     of FORM in ENVIRONMENT, which can be used anywhere that FORM could
     have been used.  All the identifiers used in FORM, except those
     explicitly excepted by FREE-NAMES, obtain their meanings from
     ENVIRONMENT.

     Here is an example where FREE-NAMES is something other than the
     empty list.  It is instructive to compare the use of FREE-NAMES in
     this example with its use in the `loop' example above: the examples
     are similar except for the source of the identifier being left
     free.
          (define-syntax let1
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (exp (cadddr exp)))
                 `((lambda (,id)
                     ,(make-syntactic-closure env (list id) exp))
                   ,(make-syntactic-closure env '() init))))))

     `let1' is a simplified version of `let' that only binds a single
     identifier, and whose body consists of a single expression.  When
     the body expression is syntactically closed in its original
     syntactic environment, the identifier that is to be bound by
     `let1' must be left free, so that it can be properly captured by
     the `lambda' in the output form.

     To obtain a syntactic environment other than the usage
     environment, use `capture-syntactic-environment'.

 -- Function: capture-syntactic-environment procedure
     `capture-syntactic-environment' returns a form that will, when
     transformed, call PROCEDURE on the current syntactic environment.
     PROCEDURE should compute and return a new form to be transformed,
     in that same syntactic environment, in place of the form.

     An example will make this clear.  Suppose we wanted to define a
     simple `loop-until' keyword equivalent to

          (define-syntax loop-until
            (syntax-rules ()
              ((loop-until id init test return step)
               (letrec ((loop
                         (lambda (id)
                           (if test return (loop step)))))
                 (loop init)))))

     The following attempt at defining `loop-until' has a subtle bug:
          (define-syntax loop-until
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (test (cadddr exp))
                     (return (cadddr (cdr exp)))
                     (step (cadddr (cddr exp)))
                     (close
                      (lambda (exp free)
                        (make-syntactic-closure env free exp))))
                 `(letrec ((loop
                            (lambda (,id)
                              (if ,(close test (list id))
                                  ,(close return (list id))
                                  (loop ,(close step (list id)))))))
                    (loop ,(close init '())))))))

     This definition appears to take all of the proper precautions to
     prevent unintended captures.  It carefully closes the
     subexpressions in their original syntactic environment and it
     leaves the `id' identifier free in the `test', `return', and
     `step' expressions, so that it will be captured by the binding
     introduced by the `lambda' expression.  Unfortunately it uses the
     identifiers `if' and `loop' within that `lambda' expression, so if
     the user of `loop-until' just happens to use, say, `if' for the
     identifier, it will be inadvertently captured.

     The syntactic environment that `if' and `loop' want to be exposed
     to is the one just outside the `lambda' expression: before the
     user's identifier is added to the syntactic environment, but after
     the identifier loop has been added.
     `capture-syntactic-environment' captures exactly that environment
     as follows:

          (define-syntax loop-until
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (test (cadddr exp))
                     (return (cadddr (cdr exp)))
                     (step (cadddr (cddr exp)))
                     (close
                      (lambda (exp free)
                        (make-syntactic-closure env free exp))))
                 `(letrec ((loop
                            ,(capture-syntactic-environment
                              (lambda (env)
                                `(lambda (,id)
                                   (,(make-syntactic-closure env '() `if)
                                    ,(close test (list id))
                                    ,(close return (list id))
                                    (,(make-syntactic-closure env '()
                                                              `loop)
                                     ,(close step (list id)))))))))
                    (loop ,(close init '())))))))

     In this case, having captured the desired syntactic environment,
     it is convenient to construct syntactic closures of the
     identifiers `if' and the `loop' and use them in the body of the
     `lambda'.

     A common use of `capture-syntactic-environment' is to get the
     transformer environment of a macro transformer:

          (transformer
           (lambda (exp env)
             (capture-syntactic-environment
              (lambda (transformer-env)
                ...))))

3.5.1.3 Identifiers
...................

This section describes the procedures that create and manipulate
identifiers.  Previous syntactic closure proposals did not have an
identifier data type - they just used symbols.  The identifier data
type extends the syntactic closures facility to be compatible with the
high-level `syntax-rules' facility.

  As discussed earlier, an identifier is either a symbol or an "alias".
An alias is implemented as a syntactic closure whose "form" is an
identifier:

     (make-syntactic-closure env '() 'a)
        => an "alias"

  Aliases are implemented as syntactic closures because they behave just
like syntactic closures most of the time.  The difference is that an
alias may be bound to a new value (for example by `lambda' or
`let-syntax'); other syntactic closures may not be used this way.  If
an alias is bound, then within the scope of that binding it is looked
up in the syntactic environment just like any other identifier.

  Aliases are used in the implementation of the high-level facility
`syntax-rules'.  A macro transformer created by `syntax-rules' uses a
template to generate its output form, substituting subforms of the
input form into the template.  In a syntactic closures implementation,
all of the symbols in the template are replaced by aliases closed in
the transformer environment, while the output form itself is closed in
the usage environment.  This guarantees that the macro transformation
is hygienic, without requiring the transformer to know the syntactic
roles of the substituted input subforms.

 -- Function: identifier? object
     Returns `#t' if OBJECT is an identifier, otherwise returns `#f'.
     Examples:

          (identifier? 'a)
             => #t
          (identifier? (make-syntactic-closure env '() 'a))
             => #t
          (identifier? "a")
             => #f
          (identifier? #\a)
             => #f
          (identifier? 97)
             => #f
          (identifier? #f)
             => #f
          (identifier? '(a))
             => #f
          (identifier? '#(a))
             => #f

     The predicate `eq?' is used to determine if two identifers are
     "the same".  Thus `eq?' can be used to compare identifiers exactly
     as it would be used to compare symbols.  Often, though, it is
     useful to know whether two identifiers "mean the same thing".  For
     example, the `cond' macro uses the symbol `else' to identify the
     final clause in the conditional.  A macro transformer for `cond'
     cannot just look for the symbol `else', because the `cond' form
     might be the output of another macro transformer that replaced the
     symbol `else' with an alias.  Instead the transformer must look
     for an identifier that "means the same thing" in the usage
     environment as the symbol `else' means in the transformer
     environment.

 -- Function: identifier=? environment1 identifier1 environment2
          identifier2
     ENVIRONMENT1 and ENVIRONMENT2 must be syntactic environments, and
     IDENTIFIER1 and IDENTIFIER2 must be identifiers.  `identifier=?'
     returns `#t' if the meaning of IDENTIFIER1 in ENVIRONMENT1 is the
     same as that of IDENTIFIER2 in ENVIRONMENT2, otherwise it returns
     `#f'.  Examples:

          (let-syntax
              ((foo
                (transformer
                 (lambda (form env)
                   (capture-syntactic-environment
                    (lambda (transformer-env)
                      (identifier=? transformer-env 'x env 'x)))))))
            (list (foo)
                  (let ((x 3))
                    (foo))))
             => (#t #f)

          (let-syntax ((bar foo))
            (let-syntax
                ((foo
                  (transformer
                   (lambda (form env)
                     (capture-syntactic-environment
                      (lambda (transformer-env)
                        (identifier=? transformer-env 'foo
                                      env (cadr form))))))))
              (list (foo foo)
                    (foobar))))
             => (#f #t)

3.5.1.4 Acknowledgements
........................

The syntactic closures facility was invented by Alan Bawden and Jonathan
Rees.  The use of aliases to implement `syntax-rules' was invented by
Alan Bawden (who prefers to call them "synthetic names").  Much of this
proposal is derived from an earlier proposal by Alan Bawden.


File: slib-3b5.info,  Node: Syntax-Case Macros,  Next: Define-Structure,  Prev: Syntactic Closures,  Up: Scheme Syntax Extension Packages
                                                                              |
3.6 Syntax-Case Macros
======================

`(require 'syntax-case)' 

 -- Function: macro:expand expression
 -- Function: syncase:expand expression
     Returns scheme code with the macros and derived expression types of
     EXPRESSION expanded to primitive expression types.

 -- Function: macro:eval expression
 -- Function: syncase:eval expression
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 -- Procedure: macro:load filename
 -- Procedure: syncase:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port', `current-error-port', and
     `current-output-port'.

  This is version 2.1 of `syntax-case', the low-level macro facility
proposed and implemented by Robert Hieb and R. Kent Dybvig.

  This version is further adapted by Harald Hanche-Olsen <hanche @
imf.unit.no> to make it compatible with, and easily usable with, SLIB.
Mainly, these adaptations consisted of:

   * Removing white space from `expand.pp' to save space in the
     distribution.  This file is not meant for human readers anyway...

   * Removed a couple of Chez scheme dependencies.

   * Renamed global variables used to minimize the possibility of name
     conflicts.

   * Adding an SLIB-specific initialization file.

   * Removing a couple extra files, most notably the documentation (but
     see below).

  If you wish, you can see exactly what changes were done by reading the
shell script in the file `syncase.sh'.

  The two PostScript files were omitted in order to not burden the SLIB
distribution with them.  If you do intend to use `syntax-case',
however, you should get these files and print them out on a PostScript
printer.  They are available with the original `syntax-case'
distribution by anonymous FTP in
`cs.indiana.edu:/pub/scheme/syntax-case'.

  In order to use syntax-case from an interactive top level, execute:
     (require 'syntax-case)
     (require 'repl)
     (repl:top-level macro:eval)
  See the section Repl (*note Repl::) for more information.

  To check operation of syntax-case get
`cs.indiana.edu:/pub/scheme/syntax-case', and type
     (require 'syntax-case)
     (syncase:sanity-check)

  Beware that `syntax-case' takes a long time to load - about 20s on a
SPARCstation SLC (with SCM) and about 90s on a Macintosh SE/30 (with
Gambit).

3.6.1 Notes
-----------

All R4RS syntactic forms are defined, including `delay'.  Along with
`delay' are simple definitions for `make-promise' (into which `delay'
expressions expand) and `force'.

  `syntax-rules' and `with-syntax' (described in `TR356') are defined.

  `syntax-case' is actually defined as a macro that expands into calls
to the procedure `syntax-dispatch' and the core form `syntax-lambda';
do not redefine these names.

  Several other top-level bindings not documented in TR356 are created:
   * the "hooks" in `hooks.ss'

   * the `build-' procedures in `output.ss'

   * `expand-syntax' (the expander)

  The syntax of define has been extended to allow `(define ID)', which
assigns ID to some unspecified value.

  We have attempted to maintain R4RS compatibility where possible.  The
incompatibilities should be confined to `hooks.ss'.  Please let us know
if there is some incompatibility that is not flagged as such.

  Send bug reports, comments, suggestions, and questions to Kent Dybvig
(dyb @ iuvax.cs.indiana.edu).


File: slib-3b5.info,  Node: Define-Structure,  Next: Define-Record-Type,  Prev: Syntax-Case Macros,  Up: Scheme Syntax Extension Packages
                                                                              |
3.7 Define-Structure
====================

`(require 'structure)'

Included with the `syntax-case' files was `structure.scm' which defines
a macro `define-structure'.  Here is its documentation from Gambit-4.0:       |

 -- special form: define-structure (NAME FIELD...)                            |
     Record data types similar to Pascal records and C `struct' types
     can be defined using the `define-structure' special form.  The
     identifier NAME specifies the name of the new data type.  The
     structure name is followed by K identifiers naming each field of
     the record.  The `define-structure' expands into a set of
     definitions of the following procedures:

        * `make-NAME' - A K argument procedure which constructs a new
          record from the value of its K fields.

        * `NAME?' - A procedure which tests if its single argument is
          of the given record type.

        * `NAME-FIELD' - For each field, a procedure taking as its
          single argument a value of the given record type and returning
          the content of the corresponding field of the record.

        * `NAME-FIELD-set!' - For each field, a two argument procedure
          taking as its first argument a value of the given record
          type.  The second argument gets assigned to the corresponding
          field of the record and the void object is returned.


     Gambit record data types have a printed representation that
     includes the name of the type and the name and value of each field.

     For example:

          > (require 'syntax-case)                                            |
          > (require 'repl)                                                   |
          > (repl:top-level macro:eval)                                       |
          > (require 'structure)                                              |
          > (define-structure (point x y color))                              |
          > (define p (make-point 3 5 'red))
          > p
          #<point #3 x: 3 y: 5 color: red>
          > (point-x p)
          3
          > (point-color p)
          red
          > (point-color-set! p 'black)
          > p
          #<point #3 x: 3 y: 5 color: black>



File: slib-3b5.info,  Node: Define-Record-Type,  Next: Fluid-Let,  Prev: Define-Structure,  Up: Scheme Syntax Extension Packages
                                                                              |
3.8 Define-Record-Type
======================

`(require 'define-record-type)' or `(require 'srfi-9)' 

  `http://srfi.schemers.org/srfi-9/srfi-9.html'

 -- Special Form: define-record-type <type-name> (<constructor-name>
          <field-tag> ...) <predicate-name> <field-spec> ...
     Where
          <field-spec> == (<field-tag> <accessor-name>)
                       == (<field-tag> <accessor-name> <modifier-name>)

     `define-record-type' is a syntax wrapper for the SLIB `record'
     module.


File: slib-3b5.info,  Node: Fluid-Let,  Next: Parameter Objects,  Prev: Define-Record-Type,  Up: Scheme Syntax Extension Packages
                                                                              |
3.9 Fluid-Let
=============

`(require 'fluid-let)' 

     _Note:_ `fluid-let' is not thread-safe.  It is better to use *note       |
     Parameter Objects:: (srfi-39) or *note Dynamic Data Type::, both of      |
     which will be made thread-safe in the future.                            |
                                                                              |
 -- Syntax: fluid-let `(BINDINGS ...)' FORMS...

     (fluid-let ((VARIABLE INIT) ...)
        EXPRESSION EXPRESSION ...)

  The INITs are evaluated in the current environment (in some
unspecified order), the current values of the VARIABLEs are saved, the
results are assigned to the VARIABLEs, the EXPRESSIONs are evaluated
sequentially in the current environment, the VARIABLEs are restored to
their original values, and the value of the last EXPRESSION is returned.

  The syntax of this special form is similar to that of `let', but
`fluid-let' temporarily rebinds existing VARIABLEs.  Unlike `let',
`fluid-let' creates no new bindings; instead it _assigns_ the values of
each INIT to the binding (determined by the rules of lexical scoping)
of its corresponding VARIABLE.


File: slib-3b5.info,  Node: Parameter Objects,  Next: Binding to multiple values,  Prev: Fluid-Let,  Up: Scheme Syntax Extension Packages
                                                                              |
3.10 Parameter Objects                                                        |
======================                                                        |
                                                                              |
`(require 'srfi-39)'                                                          |
                                                                              |
  `http://srfi.schemers.org/srfi-39/srfi-39.html'                             |
                                                                              |

File: slib-3b5.info,  Node: Binding to multiple values,  Next: Guarded LET* special form,  Prev: Parameter Objects,  Up: Scheme Syntax Extension Packages
                                                                              |
3.11 Binding to multiple values                                               |
===============================

`(require 'receive)' or `(require 'srfi-8)' 

 -- Special Form: receive formals expression body ...
     `http://srfi.schemers.org/srfi-8/srfi-8.html'

  `(require 'let-values)' or `(require 'srfi-11)' 

 -- Special Form: let-values ((formals expression) ...) body ...
 -- Special Form: let-values* ((formals expression) ...) body ...
     `http://srfi.schemers.org/srfi-11/srfi-11.html'


File: slib-3b5.info,  Node: Guarded LET* special form,  Next: Guarded COND Clause,  Prev: Binding to multiple values,  Up: Scheme Syntax Extension Packages
                                                                              |
3.12 Guarded LET* special form                                                |
==============================

`(require 'and-let*)' or `(require 'srfi-2)' 

 -- Macro: and-let* claws body ...
     `http://srfi.schemers.org/srfi-2/srfi-2.html'


File: slib-3b5.info,  Node: Guarded COND Clause,  Next: Yasos,  Prev: Guarded LET* special form,  Up: Scheme Syntax Extension Packages
                                                                              |
3.13 Guarded COND Clause                                                      |
========================

`(require 'guarded-cond-clause)' or `(require 'srfi-61)' 

  `http://srfi.schemers.org/srfi-61/srfi-61.html'

 -- library syntax: cond <clause1> <clause2> ...
     _Syntax:_ Each <clause> should be of the form

     (<test> <expression1> ...)

     where <test> is any expression.  Alternatively, a <clause> may be
     of the form

     (<test> => <expression>)

     The <clause> production in the formal syntax of Scheme as written
     by R5RS in section 7.1.3 is extended with a new option: 

     <clause> => (<generator> <guard> => <receiver>)

     where <generator>, <guard>, & <receiver> are all <expression>s.

          Clauses of this form have the following semantics:
          <generator> is evaluated.  It may return arbitrarily many
          values.  <Guard> is applied to an argument list containing
          the values in order that <generator> returned.  If <guard>
          returns a true value for that argument list, <receiver> is
          applied with an equivalent argument list.  If <guard> returns
          a false value, however, the clause is abandoned and the next
          one is tried.

     The last <clause> may be an "else clause," which has the form

     (else <expression1> <expression2> ...).

This `port->char-list' procedure accepts an input port and returns a
list of all the characters it produces until the end.

     (define (port->char-list port)
       (cond ((read-char port) char?
              => (lambda (c) (cons c (port->char-list port))))
             (else '())))

     (call-with-input-string "foo" port->char-list)  ==>  (#\f #\o #\o)


File: slib-3b5.info,  Node: Yasos,  Prev: Guarded COND Clause,  Up: Scheme Syntax Extension Packages
                                                                              |
3.14 Yasos                                                                    |
==========

`(require 'oop)' or `(require 'yasos)' 

  `Yet Another Scheme Object System' is a simple object system for
Scheme based on the paper by Norman Adams and Jonathan Rees: `Object
Oriented Programming in Scheme', Proceedings of the 1988 ACM Conference
on LISP and Functional Programming, July 1988 [ACM #552880].

  Another reference is:

  Ken Dickey.                                                                 |
Scheming with Objects                                                         |
`AI Expert' Volume 7, Number 10 (October 1992), pp. 24-33.                    |
`ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/swob.txt'            |

* Menu:

* Yasos terms::                 Definitions and disclaimer.
* Yasos interface::             The Yasos macros and procedures.
* Setters::                     Dylan-like setters in Yasos.
* Yasos examples::              Usage of Yasos and setters.


File: slib-3b5.info,  Node: Yasos terms,  Next: Yasos interface,  Prev: Yasos,  Up: Yasos
                                                                              |
3.14.1 Terms                                                                  |
------------

"Object"
     Any Scheme data object.

"Instance"
     An instance of the OO system; an "object".

"Operation"
     A METHOD.

_Notes:_
     The object system supports multiple inheritance.  An instance can
     inherit from 0 or more ancestors.  In the case of multiple
     inherited operations with the same identity, the operation used is
     that from the first ancestor which contains it (in the ancestor
     `let').  An operation may be applied to any Scheme data
     object--not just instances.  As code which creates instances is
     just code, there are no "classes" and no meta-ANYTHING.  Method
     dispatch is by a procedure call a la CLOS rather than by `send'
     syntax a la Smalltalk.

_Disclaimer:_
     There are a number of optimizations which can be made.  This
     implementation is expository (although performance should be quite
     reasonable).  See the L&FP paper for some suggestions.


File: slib-3b5.info,  Node: Yasos interface,  Next: Setters,  Prev: Yasos terms,  Up: Yasos
                                                                              |
3.14.2 Interface                                                              |
----------------

 -- Syntax: define-operation `('opname self arg ...`)' DEFAULT-BODY
     Defines a default behavior for data objects which don't handle the
     operation OPNAME.  The default behavior (for an empty
     DEFAULT-BODY) is to generate an error.

 -- Syntax: define-predicate opname?
     Defines a predicate OPNAME?, usually used for determining the
     "type" of an object, such that `(OPNAME? OBJECT)' returns `#t' if
     OBJECT has an operation OPNAME? and `#f' otherwise.

 -- Syntax: object `((NAME SELF ARG ...) BODY)' ...
     Returns an object (an instance of the object system) with
     operations.  Invoking `(NAME OBJECT ARG ...)' executes the BODY of       |
     the OBJECT with SELF bound to OBJECT and with argument(s) ARG....

 -- Syntax: object-with-ancestors `(('ancestor1 init1`)' ...`)'
          operation ...
     A `let'-like form of `object' for multiple inheritance.  It
     returns an object inheriting the behaviour of ANCESTOR1 etc.  An
     operation will be invoked in an ancestor if the object itself does
     not provide such a method.  In the case of multiple inherited
     operations with the same identity, the operation used is the one
     found in the first ancestor in the ancestor list.

 -- Syntax: operate-as component operation self arg ...
     Used in an operation definition (of SELF) to invoke the OPERATION
     in an ancestor COMPONENT but maintain the object's identity.  Also
     known as "send-to-super".

 -- Procedure: print obj port
     A default `print' operation is provided which is just `(format
     PORT OBJ)' (*note Format::) for non-instances and prints OBJ
     preceded by `#<INSTANCE>' for instances.

 -- Function: size obj
     The default method returns the number of elements in OBJ if it is
     a vector, string or list, `2' for a pair, `1' for a character and
     by default id an error otherwise.  Objects such as collections
     (*note Collections::) may override the default in an obvious way.


File: slib-3b5.info,  Node: Setters,  Next: Yasos examples,  Prev: Yasos interface,  Up: Yasos
                                                                              |
3.14.3 Setters                                                                |
--------------

"Setters" implement "generalized locations" for objects associated with
some sort of mutable state.  A "getter" operation retrieves a value
from a generalized location and the corresponding setter operation
stores a value into the location.  Only the getter is named - the
setter is specified by a procedure call as below.  (Dylan uses special
syntax.)  Typically, but not necessarily, getters are access operations
to extract values from Yasos objects (*note Yasos::).  Several setters
are predefined, corresponding to getters `car', `cdr', `string-ref' and
`vector-ref' e.g., `(setter car)' is equivalent to `set-car!'.

  This implementation of setters is similar to that in Dylan(TM)
(`Dylan: An object-oriented dynamic language', Apple Computer Eastern
Research and Technology).  Common LISP provides similar facilities
through `setf'.

 -- Function: setter getter
     Returns the setter for the procedure GETTER.  E.g., since
     `string-ref' is the getter corresponding to a setter which is
     actually `string-set!':
          (define foo "foo")
          ((setter string-ref) foo 0 #\F) ; set element 0 of foo
          foo => "Foo"

 -- Syntax: set place new-value
     If PLACE is a variable name, `set' is equivalent to `set!'.
     Otherwise, PLACE must have the form of a procedure call, where the
     procedure name refers to a getter and the call indicates an
     accessible generalized location, i.e., the call would return a
     value.  The return value of `set' is usually unspecified unless
     used with a setter whose definition guarantees to return a useful
     value.
          (set (string-ref foo 2) #\O)  ; generalized location with getter
          foo => "FoO"
          (set foo "foo")               ; like set!
          foo => "foo"

 -- Procedure: add-setter getter setter
     Add procedures GETTER and SETTER to the (inaccessible) list of
     valid setter/getter pairs.  SETTER implements the store operation
     corresponding to the GETTER access operation for the relevant
     state.  The return value is unspecified.

 -- Procedure: remove-setter-for getter
     Removes the setter corresponding to the specified GETTER from the
     list of valid setters.  The return value is unspecified.

 -- Syntax: define-access-operation getter-name
     Shorthand for a Yasos `define-operation' defining an operation
     GETTER-NAME that objects may support to return the value of some
     mutable state.  The default operation is to signal an error.  The
     return value is unspecified.


File: slib-3b5.info,  Node: Yasos examples,  Prev: Setters,  Up: Yasos
                                                                              |
3.14.4 Examples                                                               |
---------------

     ;;; These definitions for PRINT and SIZE are
     ;;; already supplied by
     (require 'yasos)

     (define-operation (print obj port)
       (format port
               (if (instance? obj) "#<instance>" "~s")
               obj))

     (define-operation (size obj)
       (cond
        ((vector? obj) (vector-length obj))
        ((list?   obj) (length obj))
        ((pair?   obj) 2)
        ((string? obj) (string-length obj))
        ((char?   obj) 1)
        (else
         (slib:error "Operation not supported: size" obj))))

     (define-predicate cell?)
     (define-operation (fetch obj))
     (define-operation (store! obj newValue))

     (define (make-cell value)
       (object
        ((cell? self) #t)
        ((fetch self) value)
        ((store! self newValue)
         (set! value newValue)
         newValue)
        ((size self) 1)
        ((print self port)
         (format port "#<Cell: ~s>" (fetch self)))))

     (define-operation (discard obj value)
       (format #t "Discarding ~s~%" value))

     (define (make-filtered-cell value filter)
       (object-with-ancestors
        ((cell (make-cell value)))
        ((store! self newValue)
        (if (filter newValue)
            (store! cell newValue)
            (discard self newValue)))))

     (define-predicate array?)
     (define-operation (array-ref array index))
     (define-operation (array-set! array index value))

     (define (make-array num-slots)
       (let ((anArray (make-vector num-slots)))
         (object
          ((array? self) #t)
          ((size self) num-slots)
          ((array-ref self index)
           (vector-ref  anArray index))
          ((array-set! self index newValue)
           (vector-set! anArray index newValue))
          ((print self port)
           (format port "#<Array ~s>" (size self))))))

     (define-operation (position obj))
     (define-operation (discarded-value obj))

     (define (make-cell-with-history value filter size)
       (let ((pos 0) (most-recent-discard #f))
         (object-with-ancestors
          ((cell (make-filtered-call value filter))
           (sequence (make-array size)))
          ((array? self) #f)
          ((position self) pos)
          ((store! self newValue)
           (operate-as cell store! self newValue)
           (array-set! self pos newValue)
           (set! pos (+ pos 1)))
          ((discard self value)
           (set! most-recent-discard value))
          ((discarded-value self) most-recent-discard)
          ((print self port)
           (format port "#<Cell-with-history ~s>"
                   (fetch self))))))

     (define-access-operation fetch)
     (add-setter fetch store!)
     (define foo (make-cell 1))
     (print foo #f)
     => "#<Cell: 1>"
     (set (fetch foo) 2)
     =>
     (print foo #f)
     => "#<Cell: 2>"
     (fetch foo)
     => 2


File: slib-3b5.info,  Node: Textual Conversion Packages,  Next: Mathematical Packages,  Prev: Scheme Syntax Extension Packages,  Up: Top
                                                                              |
4 Textual Conversion Packages
*****************************

* Menu:

* Precedence Parsing::
* Format::                      Common-Lisp Format
* Standard Formatted I/O::      Posix printf and scanf
* Programs and Arguments::
* HTML::                        Generating
* HTML Tables::                 Databases meet HTML
* HTTP and CGI::                Serve WWW sites
* Parsing HTML::                'html-for-each
* URI::                         Uniform Resource Identifier
* Parsing XML::                 'parse-xml or 'ssax
* Printing Scheme::             Nicely
* Time and Date::
* NCBI-DNA::                    DNA and protein sequences
* Schmooz::                     Documentation markup for Scheme programs


File: slib-3b5.info,  Node: Precedence Parsing,  Next: Format,  Prev: Textual Conversion Packages,  Up: Textual Conversion Packages
                                                                              |
4.1 Precedence Parsing
======================

`(require 'precedence-parse)' or `(require 'parse)' 

This package implements:

   * a Pratt style precedence parser;

   * a "tokenizer" which congeals tokens according to assigned classes
     of constituent characters;

   * procedures giving direct control of parser rulesets;

   * procedures for higher level specification of rulesets.

* Menu:

* Precedence Parsing Overview::
* Rule Types::
* Ruleset Definition and Use::
* Token definition::
* Nud and Led Definition::
* Grammar Rule Definition::


File: slib-3b5.info,  Node: Precedence Parsing Overview,  Next: Rule Types,  Prev: Precedence Parsing,  Up: Precedence Parsing
                                                                              |
4.1.1 Precedence Parsing Overview
---------------------------------

This package offers improvements over previous parsers.

   * Common computer language constructs are concisely specified.

   * Grammars can be changed dynamically.  Operators can be assigned
     different meanings within a lexical context.

   * Rulesets don't need compilation.  Grammars can be changed
     incrementally.

   * Operator precedence is specified by integers.

   * All possibilities of bad input are handled (1) and return as much
     structure as was parsed when the error occured; The symbol `?' is
     substituted for missing input.

The notion of "binding power" may be unfamiliar to those accustomed to
BNF grammars.

When two consecutive objects are parsed, the first might be the prefix
to the second, or the second might be a suffix of the first.  Comparing
the left and right binding powers of the two objects decides which way
to interpret them.

Objects at each level of syntactic grouping have binding powers.

A syntax tree is not built unless the rules explicitly do so.  The call
graph of grammar rules effectively instantiate the sytnax tree.

The JACAL symbolic math system
(`http://people.csail.mit.edu/jaffer/JACAL') uses precedence-parse.
Its grammar definitions in the file `jacal/English.scm' can serve as
examples of use.

  ---------- Footnotes ----------

  (1) How do I know this?  I parsed 250kbyte of random input (an e-mail
file) with a non-trivial grammar utilizing all constructs.


File: slib-3b5.info,  Node: Rule Types,  Next: Ruleset Definition and Use,  Prev: Precedence Parsing Overview,  Up: Precedence Parsing
                                                                              |
4.1.2 Rule Types
----------------

Here are the higher-level syntax types and an example of each.
Precedence considerations are omitted for clarity.  See *note Grammar
Rule Definition:: for full details.

 -- Grammar: nofix bye exit
          bye
     calls the function `exit' with no arguments.

 -- Grammar: prefix - negate
          - 42
     Calls the function `negate' with the argument `42'.

 -- Grammar: infix - difference
          x - y
     Calls the function `difference' with arguments `x' and `y'.

 -- Grammar: nary + sum
          x + y + z
     Calls the function `sum' with arguments `x', `y', and `y'.

 -- Grammar: postfix ! factorial
          5 !
     Calls the function `factorial' with the argument `5'.

 -- Grammar: prestfix set set!
          set foo bar
     Calls the function `set!' with the arguments `foo' and `bar'.

 -- Grammar: commentfix /* */
          /* almost any text here */
     Ignores the comment delimited by `/*' and `*/'.

 -- Grammar: matchfix { list }
          {0, 1, 2}
     Calls the function `list' with the arguments `0', `1', and `2'.

 -- Grammar: inmatchfix ( funcall )
          f(x, y)
     Calls the function `funcall' with the arguments `f', `x', and `y'.

 -- Grammar: delim ;
          set foo bar;
     delimits the extent of the restfix operator `set'.


File: slib-3b5.info,  Node: Ruleset Definition and Use,  Next: Token definition,  Prev: Rule Types,  Up: Precedence Parsing
                                                                              |
4.1.3 Ruleset Definition and Use
--------------------------------

 -- Variable: *syn-defs*
     A grammar is built by one or more calls to `prec:define-grammar'.
     The rules are appended to *SYN-DEFS*.  The value of *SYN-DEFS* is
     the grammar suitable for passing as an argument to `prec:parse'.

 -- Constant: *syn-ignore-whitespace*
     Is a nearly empty grammar with whitespace characters set to group
     0, which means they will not be made into tokens.  Most rulesets
     will want to start with `*syn-ignore-whitespace*'

In order to start defining a grammar, either

     (set! *syn-defs* '())
  or

     (set! *syn-defs* *syn-ignore-whitespace*)

 -- Function: prec:define-grammar rule1 ...
     Appends RULE1 ... to *SYN-DEFS*.  `prec:define-grammar' is used to
     define both the character classes and rules for tokens.

Once your grammar is defined, save the value of `*syn-defs*' in a
variable (for use when calling `prec:parse').

     (define my-ruleset *syn-defs*)

 -- Function: prec:parse ruleset delim column
 -- Function: prec:parse ruleset delim column port
     The RULESET argument must be a list of rules as constructed by
     `prec:define-grammar' and extracted from *SYN-DEFS*.

     The token DELIM may be a character, symbol, or string.  A
     character DELIM argument will match only a character token; i.e. a
     character for which no token-group is assigned.  A symbol or
     string will match only a token string; i.e. a token resulting from
     a token group.

     `prec:parse' reads a RULESET grammar expression delimited by DELIM
     from the given input PORT.  `prec:parse' returns the next object
     parsable from the given input PORT, updating PORT to point to the
     first character past the end of the external representation of the
     object.

     For the purpose of reporting problems in error messages, this
     package keeps track of the "current column".  Its initial value is
     passed as the third argument to `prec:parse'.

     If an end of file is encountered in the input before any
     characters are found that can begin an object, then an end of file
     object is returned.  If a delimiter (such as DELIM) is found
     before any characters are found that can begin an object, then
     `#f' is returned.

     The PORT argument may be omitted, in which case it defaults to the
     value returned by `current-input-port'.  It is an error to parse
     from a closed port.  


File: slib-3b5.info,  Node: Token definition,  Next: Nud and Led Definition,  Prev: Ruleset Definition and Use,  Up: Precedence Parsing
                                                                              |
4.1.4 Token definition
----------------------

 -- Function: tok:char-group group chars chars-proc
     The argument CHARS may be a single character, a list of
     characters, or a string.  Each character in CHARS is treated as
     though `tok:char-group' was called with that character alone.

     The argument CHARS-PROC must be a procedure of one argument, a
     list of characters.  After `tokenize' has finished accumulating
     the characters for a token, it calls CHARS-PROC with the list of
     characters.  The value returned is the token which `tokenize'
     returns.

     The argument GROUP may be an exact integer or a procedure of one
     character argument.  The following discussion concerns the
     treatment which the tokenizing routine, `tokenize', will accord to
     characters on the basis of their groups.

     When GROUP is a non-zero integer, characters whose group number is
     equal to or exactly one less than GROUP will continue to
     accumulate.  Any other character causes the accumulation to stop
     (until a new token is to be read).

     The GROUP of zero is special.  These characters are ignored when
     parsed pending a token, and stop the accumulation of token
     characters when the accumulation has already begun.  Whitespace
     characters are usually put in group 0.

     If GROUP is a procedure, then, when triggerd by the occurence of
     an initial (no accumulation) CHARS character, this procedure will
     be repeatedly called with each successive character from the input
     stream until the GROUP procedure returns a non-false value.

The following convenient constants are provided for use with
`tok:char-group'.

 -- Constant: tok:decimal-digits
     Is the string `"0123456789"'.

 -- Constant: tok:upper-case
     Is the string consisting of all upper-case letters
     ("ABCDEFGHIJKLMNOPQRSTUVWXYZ").

 -- Constant: tok:lower-case
     Is the string consisting of all lower-case letters
     ("abcdefghijklmnopqrstuvwxyz").

 -- Constant: tok:whitespaces
     Is the string consisting of all characters between 0 and 255 for
     which `char-whitespace?' returns true.


File: slib-3b5.info,  Node: Nud and Led Definition,  Next: Grammar Rule Definition,  Prev: Token definition,  Up: Precedence Parsing
                                                                              |
4.1.5 Nud and Led Definition
----------------------------

This section describes advanced features.  You can skip this section on
first reading.

The "Null Denotation" (or "nud") of a token is the procedure and
arguments applying for that token when "Left", an unclaimed parsed
expression is not extant.

The "Left Denotation" (or "led") of a token is the procedure,
arguments, and lbp applying for that token when there is a "Left", an
unclaimed parsed expression.

In his paper,

     Pratt, V. R.  Top Down Operator Precendence.  `SIGACT/SIGPLAN
     Symposium on Principles of Programming Languages', Boston, 1973,
     pages 41-51

  the "left binding power" (or "lbp") was an independent property of
tokens.  I think this was done in order to allow tokens with NUDs but
not LEDs to also be used as delimiters, which was a problem for
statically defined syntaxes.  It turns out that _dynamically binding_
NUDs and LEDs allows them independence.

For the rule-defining procedures that follow, the variable TK may be a
character, string, or symbol, or a list composed of characters,
strings, and symbols.  Each element of TK is treated as though the
procedure were called for each element.

Character TK arguments will match only character tokens; i.e.
characters for which no token-group is assigned.  Symbols and strings
will both match token strings; i.e. tokens resulting from token groups.

 -- Function: prec:make-nud tk sop arg1 ...
     Returns a rule specifying that SOP be called when TK is parsed.
     If SOP is a procedure, it is called with TK and ARG1 ... as its
     arguments; the resulting value is incorporated into the expression
     being built.  Otherwise, `(list SOP ARG1 ...)' is incorporated.

If no NUD has been defined for a token; then if that token is a string,
it is converted to a symbol and returned; if not a string, the token is
returned.

 -- Function: prec:make-led tk sop arg1 ...
     Returns a rule specifying that SOP be called when TK is parsed and
     LEFT has an unclaimed parsed expression.  If SOP is a procedure,
     it is called with LEFT, TK, and ARG1 ... as its arguments; the
     resulting value is incorporated into the expression being built.
     Otherwise, LEFT is incorporated.

If no LED has been defined for a token, and LEFT is set, the parser
issues a warning.


File: slib-3b5.info,  Node: Grammar Rule Definition,  Prev: Nud and Led Definition,  Up: Precedence Parsing
                                                                              |
4.1.6 Grammar Rule Definition
-----------------------------

Here are procedures for defining rules for the syntax types introduced
in *note Precedence Parsing Overview::.

For the rule-defining procedures that follow, the variable TK may be a
character, string, or symbol, or a list composed of characters,
strings, and symbols.  Each element of TK is treated as though the
procedure were called for each element.

For procedures prec:delim, ..., prec:prestfix, if the SOP argument is
`#f', then the token which triggered this rule is converted to a symbol
and returned.  A false SOP argument to the procedures prec:commentfix,
prec:matchfix, or prec:inmatchfix has a different meaning.

Character TK arguments will match only character tokens; i.e.
characters for which no token-group is assigned.  Symbols and strings
will both match token strings; i.e. tokens resulting from token groups.

 -- Function: prec:delim tk
     Returns a rule specifying that TK should not be returned from
     parsing; i.e. TK's function is purely syntactic.  The end-of-file
     is always treated as a delimiter.

 -- Function: prec:nofix tk sop
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * If SOP is a procedure, it is called with no arguments; the
          resulting value is incorporated into the expression being
          built.  Otherwise, the list of SOP is incorporated.

 -- Function: prec:prefix tk sop bp rule1 ...
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * `prec:parse1' is called with binding-power BP.

        * If SOP is a procedure, it is called with the expression
          returned from `prec:parse1'; the resulting value is
          incorporated into the expression being built.  Otherwise, the
          list of SOP and the expression returned from `prec:parse1' is
          incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 -- Function: prec:infix tk sop lbp bp rule1 ...
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * One expression is parsed with binding-power LBP.  If instead a
          delimiter is encountered, a warning is issued.

        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expression; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of SOP,
          the LEFT expression, and the parsed expression is
          incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 -- Function: prec:nary tk sop bp
     Returns a rule declaring the left-binding-precedence of the token
     TK is BP and specifying the following actions take place when TK
     is parsed:
        * Expressions are parsed with binding-power BP as far as they
          are interleaved with the token TK.

        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expressions; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of SOP,
          the LEFT expression, and the parsed expressions is
          incorporated.

 -- Function: prec:postfix tk sop lbp
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * If SOP is a procedure, it is called with the LEFT expression;
          the resulting value is incorporated into the expression being
          built.  Otherwise, the list of SOP and the LEFT expression is
          incorporated.

 -- Function: prec:prestfix tk sop bp rule1 ...
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * Expressions are parsed with binding-power BP until a
          delimiter is reached.

        * If SOP is a procedure, it is applied to the list of parsed
          expressions; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          parsed expressions is incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 -- Function: prec:commentfix tk stp match rule1 ...
     Returns rules specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * Characters are read until and end-of-file or a sequence of
          characters is read which matches the _string_ MATCH.

        * If STP is a procedure, it is called with the string of all
          that was read between the TK and MATCH (exclusive).

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

     Parsing of commentfix syntax differs from the others in several
     ways.  It reads directly from input without tokenizing; It calls
     STP but does not return its value; nay any value.  I added the STP
     argument so that comment text could be echoed.

 -- Function: prec:matchfix tk sop sep match rule1 ...
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * A rule declaring the token MATCH a delimiter takes effect.

        * Expressions are parsed with binding-power `0' until the token
          MATCH is reached.  If the token SEP does not appear between
          each pair of expressions parsed, a warning is issued.

        * If SOP is a procedure, it is applied to the list of parsed
          expressions; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          parsed expressions is incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 -- Function: prec:inmatchfix tk sop sep match lbp rule1 ...
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * A rule declaring the token MATCH a delimiter takes effect.

        * Expressions are parsed with binding-power `0' until the token
          MATCH is reached.  If the token SEP does not appear between
          each pair of expressions parsed, a warning is issued.

        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expressions; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of SOP,
          the LEFT expression, and the parsed expressions is
          incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.


File: slib-3b5.info,  Node: Format,  Next: Standard Formatted I/O,  Prev: Precedence Parsing,  Up: Textual Conversion Packages
                                                                              |
4.2 Format (version 3.1)
========================

`(require 'format)' or `(require 'srfi-28)' 

* Menu:

* Format Interface::
* Format Specification::


File: slib-3b5.info,  Node: Format Interface,  Next: Format Specification,  Prev: Format,  Up: Format
                                                                              |
4.2.1 Format Interface
----------------------

 -- Function: format destination format-string . arguments
     An almost complete implementation of Common LISP format description
     according to the CL reference book `Common LISP' from Guy L.
     Steele, Digital Press.  Backward compatible to most of the
     available Scheme format implementations.

     Returns `#t', `#f' or a string; has side effect of printing
     according to FORMAT-STRING.  If DESTINATION is `#t', the output is
     to the current output port and `#t' is returned.  If DESTINATION
     is `#f', a formatted string is returned as the result of the call.
     NEW: If DESTINATION is a string, DESTINATION is regarded as the
     format string; FORMAT-STRING is then the first argument and the
     output is returned as a string. If DESTINATION is a number, the
     output is to the current error port if available by the
     implementation. Otherwise DESTINATION must be an output port and
     `#t' is returned.

     FORMAT-STRING must be a string.  In case of a formatting error
     format returns `#f' and prints a message on the current output or
     error port.  Characters are output as if the string were output by
     the `display' function with the exception of those prefixed by a
     tilde (~).  For a detailed description of the FORMAT-STRING syntax
     please consult a Common LISP format reference manual.  For a test
     suite to verify this format implementation load `formatst.scm'.



File: slib-3b5.info,  Node: Format Specification,  Prev: Format Interface,  Up: Format
                                                                              |
4.2.2 Format Specification (Format version 3.1)
-----------------------------------------------

Please consult a Common LISP format reference manual for a detailed
description of the format string syntax.  For a demonstration of the
implemented directives see `formatst.scm'.

  This implementation supports directive parameters and modifiers (`:'
and `@' characters). Multiple parameters must be separated by a comma
(`,').  Parameters can be numerical parameters (positive or negative),
character parameters (prefixed by a quote character (`''), variable
parameters (`v'), number of rest arguments parameter (`#'), empty and
default parameters.  Directive characters are case independent. The
general form of a directive is:

DIRECTIVE ::= ~{DIRECTIVE-PARAMETER,}[:][@]DIRECTIVE-CHARACTER

DIRECTIVE-PARAMETER ::= [ [-|+]{0-9}+ | 'CHARACTER | v | # ]

4.2.2.1 Implemented CL Format Control Directives
................................................

Documentation syntax: Uppercase characters represent the corresponding
control directive characters. Lowercase characters represent control
directive parameter descriptions.

`~A'
     Any (print as `display' does).
    `~@A'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARA'
          full padding.

`~S'
     S-expression (print as `write' does).
    `~@S'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARS'
          full padding.

`~D'
     Decimal.
    `~@D'
          print number sign always.

    `~:D'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARD'
          padding.

`~X'
     Hexadecimal.
    `~@X'
          print number sign always.

    `~:X'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARX'
          padding.

`~O'
     Octal.
    `~@O'
          print number sign always.

    `~:O'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARO'
          padding.

`~B'
     Binary.
    `~@B'
          print number sign always.

    `~:B'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARB'
          padding.

`~NR'
     Radix N.
    `~N,MINCOL,PADCHAR,COMMACHARR'
          padding.

`~@R'
     print a number as a Roman numeral.

`~:@R'
     print a number as an "old fashioned" Roman numeral.

`~:R'
     print a number as an ordinal English number.

`~R'
     print a number as a cardinal English number.

`~P'
     Plural.
    `~@P'
          prints `y' and `ies'.

    `~:P'
          as `~P but jumps 1 argument backward.'

    `~:@P'
          as `~@P but jumps 1 argument backward.'

`~C'
     Character.
    `~@C'
          prints a character as the reader can understand it (i.e. `#\'
          prefixing).

    `~:C'
          prints a character as emacs does (eg. `^C' for ASCII 03).

`~F'
     Fixed-format floating-point (prints a flonum like MMM.NNN).
    `~WIDTH,DIGITS,SCALE,OVERFLOWCHAR,PADCHARF'

    `~@F'
          If the number is positive a plus sign is printed.

`~E'
     Exponential floating-point (prints a flonum like MMM.NNN`E'EE).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARE'

    `~@E'
          If the number is positive a plus sign is printed.

`~G'
     General floating-point (prints a flonum either fixed or
     exponential).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARG'

    `~@G'
          If the number is positive a plus sign is printed.

`~$'
     Dollars floating-point (prints a flonum in fixed with signs
     separated).
    `~DIGITS,SCALE,WIDTH,PADCHAR$'

    `~@$'
          If the number is positive a plus sign is printed.

    `~:@$'
          A sign is always printed and appears before the padding.

    `~:$'
          The sign appears before the padding.

`~%'
     Newline.
    `~N%'
          print N newlines.

`~&'
     print newline if not at the beginning of the output line.
    `~N&'
          prints `~&' and then N-1 newlines.

`~|'
     Page Separator.
    `~N|'
          print N page separators.

`~~'
     Tilde.
    `~N~'
          print N tildes.

`~'<newline>
     Continuation Line.
    `~:'<newline>
          newline is ignored, white space left.

    `~@'<newline>
          newline is left, white space ignored.

`~T'
     Tabulation.
    `~@T'
          relative tabulation.

    `~COLNUM,COLINCT'
          full tabulation.

`~?'
     Indirection (expects indirect arguments as a list).
    `~@?'
          extracts indirect arguments from format arguments.

`~(STR~)'
     Case conversion (converts by `string-downcase').
    `~:(STR~)'
          converts by `string-capitalize'.

    `~@(STR~)'
          converts by `string-capitalize-first'.

    `~:@(STR~)'
          converts by `string-upcase'.

`~*'
     Argument Jumping (jumps 1 argument forward).
    `~N*'
          jumps N arguments forward.

    `~:*'
          jumps 1 argument backward.

    `~N:*'
          jumps N arguments backward.

    `~@*'
          jumps to the 0th argument.

    `~N@*'
          jumps to the Nth argument (beginning from 0)

`~[STR0~;STR1~;...~;STRN~]'
     Conditional Expression (numerical clause conditional).
    `~N['
          take argument from N.

    `~@['
          true test conditional.

    `~:['
          if-else-then conditional.

    `~;'
          clause separator.

    `~:;'
          default clause follows.

`~{STR~}'
     Iteration (args come from the next argument (a list)). Iteration
     bounding is controlled by configuration variables
     FORMAT:ITERATION-BOUNDED and FORMAT:MAX-ITERATIONS.  With both
     variables default, a maximum of 100 iterations will be performed.
    `~N{'
          at most N iterations.

    `~:{'
          args from next arg (a list of lists).

    `~@{'
          args from the rest of arguments.

    `~:@{'
          args from the rest args (lists).

`~^'
     Up and out.
    `~N^'
          aborts if N = 0

    `~N,M^'
          aborts if N = M

    `~N,M,K^'
          aborts if N <= M <= K

4.2.2.2 Not Implemented CL Format Control Directives
....................................................

`~:A'
     print `#f' as an empty list (see below).

`~:S'
     print `#f' as an empty list (see below).

`~<~>'
     Justification.

`~:^'
     (sorry I don't understand its semantics completely)

4.2.2.3 Extended, Replaced and Additional Control Directives
............................................................

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHD'

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHX'

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHO'

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHB'

`~N,MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHR'
     COMMAWIDTH is the number of characters between two comma
     characters.

`~I'
     print a R4RS complex number as `~F~@Fi' with passed parameters for
     `~F'.

`~Y'
     Pretty print formatting of an argument for scheme code lists.

`~K'
     Same as `~?.'

`~!'
     Flushes the output if format DESTINATION is a port.

`~_'
     Print a `#\space' character
    `~N_'
          print N `#\space' characters.

`~/'
     Print a `#\tab' character
    `~N/'
          print N `#\tab' characters.

`~NC'
     Takes N as an integer representation for a character. No arguments
     are consumed. N is converted to a character by `integer->char'.  N
     must be a positive decimal number.

`~:S'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~:A'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~Q'
     Prints information and a copyright notice on the format
     implementation.
    `~:Q'
          prints format version.

`~F, ~E, ~G, ~$'
     may also print number strings, i.e. passing a number as a string
     and format it accordingly.

4.2.2.4 Configuration Variables
...............................

Format has some configuration variables at the beginning of
`format.scm' to suit the systems and users needs. There should be no
modification necessary for the configuration that comes with SLIB.  If
modification is desired the variable should be set after the format
code is loaded. Format detects automatically if the running scheme
system implements floating point numbers and complex numbers.

FORMAT:SYMBOL-CASE-CONV
     Symbols are converted by `symbol->string' so the case type of the
     printed symbols is implementation dependent.
     `format:symbol-case-conv' is a one arg closure which is either
     `#f' (no conversion), `string-upcase', `string-downcase' or
     `string-capitalize'. (default `#f')

FORMAT:IOBJ-CASE-CONV
     As FORMAT:SYMBOL-CASE-CONV but applies for the representation of
     implementation internal objects. (default `#f')

FORMAT:EXPCH
     The character prefixing the exponent value in `~E' printing.
     (default `#\E')

FORMAT:ITERATION-BOUNDED
     When `#t', a `~{...~}' control will iterate no more than the
     number of times specified by FORMAT:MAX-ITERATIONS regardless of
     the number of iterations implied by modifiers and arguments.  When
     `#f', a `~{...~}' control will iterate the number of times implied
     by modifiers and arguments, unless termination is forced by
     language or system limitations. (default `#t')

FORMAT:MAX-ITERATIONS
     The maximum number of iterations performed by a `~{...~}' control.
     Has effect only when FORMAT:ITERATION-BOUNDED is `#t'.  (default
     100)


4.2.2.5 Compatibility With Other Format Implementations
.......................................................

SLIB format 2.x:
     See `format.doc'.

SLIB format 1.4:
     Downward compatible except for padding support and `~A', `~S',
     `~P', `~X' uppercase printing.  SLIB format 1.4 uses C-style
     `printf' padding support which is completely replaced by the CL
     `format' padding style.

MIT C-Scheme 7.1:
     Downward compatible except for `~', which is not documented
     (ignores all characters inside the format string up to a newline
     character).  (7.1 implements `~a', `~s', ~NEWLINE, `~~', `~%',
     numerical and variable parameters and `:/@' modifiers in the CL
     sense).

Elk 1.5/2.0:
     Downward compatible except for `~A' and `~S' which print in
     uppercase.  (Elk implements `~a', `~s', `~~', and `~%' (no
     directive parameters or modifiers)).

Scheme->C 01nov91:
     Downward compatible except for an optional destination parameter:
     S2C accepts a format call without a destination which returns a
     formatted string. This is equivalent to a #f destination in S2C.
     (S2C implements `~a', `~s', `~c', `~%', and `~~' (no directive
     parameters or modifiers)).


  This implementation of format is solely useful in the SLIB context
because it requires other components provided by SLIB.


File: slib-3b5.info,  Node: Standard Formatted I/O,  Next: Programs and Arguments,  Prev: Format,  Up: Textual Conversion Packages
                                                                              |
4.3 Standard Formatted I/O
==========================

* Menu:

* Standard Formatted Output::   'printf
* Standard Formatted Input::    'scanf

4.3.1 stdio
-----------

`(require 'stdio)' 

  `require's `printf' and `scanf' and additionally defines the symbols:

 -- Variable: stdin
     Defined to be `(current-input-port)'.

 -- Variable: stdout
     Defined to be `(current-output-port)'.

 -- Variable: stderr
     Defined to be `(current-error-port)'.


File: slib-3b5.info,  Node: Standard Formatted Output,  Next: Standard Formatted Input,  Prev: Standard Formatted I/O,  Up: Standard Formatted I/O
                                                                              |
4.3.2 Standard Formatted Output
-------------------------------

`(require 'printf)' 

 -- Procedure: printf format arg1 ...
 -- Procedure: fprintf port format arg1 ...
 -- Procedure: sprintf str format arg1 ...
 -- Procedure: sprintf #f format arg1 ...
 -- Procedure: sprintf k format arg1 ...
     Each function converts, formats, and outputs its ARG1 ...
     arguments according to the control string FORMAT argument and
     returns the number of characters output.

     `printf' sends its output to the port `(current-output-port)'.
     `fprintf' sends its output to the port PORT.  `sprintf'
     `string-set!'s locations of the non-constant string argument STR
     to the output characters.

     Two extensions of `sprintf' return new strings.  If the first
     argument is `#f', then the returned string's length is as many
     characters as specified by the FORMAT and data; if the first
     argument is a non-negative integer K, then the length of the
     returned string is also bounded by K.

     The string FORMAT contains plain characters which are copied to
     the output stream, and conversion specifications, each of which
     results in fetching zero or more of the arguments ARG1 ....  The
     results are undefined if there are an insufficient number of
     arguments for the format.  If FORMAT is exhausted while some of the
     ARG1 ... arguments remain unused, the excess ARG1 ... arguments
     are ignored.

     The conversion specifications in a format string have the form:

          % [ FLAGS ] [ WIDTH ] [ . PRECISION ] [ TYPE ] CONVERSION

     An output conversion specifications consist of an initial `%'
     character followed in sequence by:

        * Zero or more "flag characters" that modify the normal
          behavior of the conversion specification.

         `-'
               Left-justify the result in the field.  Normally the
               result is right-justified.

         `+'
               For the signed `%d' and `%i' conversions and all inexact
               conversions, prefix a plus sign if the value is positive.

         ` '
               For the signed `%d' and `%i' conversions, if the result
               doesn't start with a plus or minus sign, prefix it with
               a space character instead.  Since the `+' flag ensures
               that the result includes a sign, this flag is ignored if
               both are specified.

         `#'
               For inexact conversions, `#' specifies that the result
               should always include a decimal point, even if no digits
               follow it.  For the `%g' and `%G' conversions, this also
               forces trailing zeros after the decimal point to be
               printed where they would otherwise be elided.

               For the `%o' conversion, force the leading digit to be
               `0', as if by increasing the precision.  For `%x' or
               `%X', prefix a leading `0x' or `0X' (respectively) to
               the result.  This doesn't do anything useful for the
               `%d', `%i', or `%u' conversions.  Using this flag
               produces output which can be parsed by the `scanf'
               functions with the `%i' conversion (*note Standard
               Formatted Input::).

         `0'
               Pad the field with zeros instead of spaces.  The zeros
               are placed after any indication of sign or base.  This
               flag is ignored if the `-' flag is also specified, or if
               a precision is specified for an exact converson.

        * An optional decimal integer specifying the "minimum field
          width".  If the normal conversion produces fewer characters
          than this, the field is padded (with spaces or zeros per the
          `0' flag) to the specified width.  This is a _minimum_ width;
          if the normal conversion produces more characters than this,
          the field is _not_ truncated.  

          Alternatively, if the field width is `*', the next argument
          in the argument list (before the actual value to be printed)
          is used as the field width.  The width value must be an
          integer.  If the value is negative it is as though the `-'
          flag is set (see above) and the absolute value is used as the
          field width.

        * An optional "precision" to specify the number of digits to be
          written for numeric conversions and the maximum field width
          for string conversions.  The precision is specified by a
          period (`.') followed optionally by a decimal integer (which
          defaults to zero if omitted).  

          Alternatively, if the precision is `.*', the next argument in
          the argument list (before the actual value to be printed) is
          used as the precision.  The value must be an integer, and is
          ignored if negative.  If you specify `*' for both the field
          width and precision, the field width argument precedes the
          precision argument.  The `.*' precision is an enhancement.  C
          library versions may not accept this syntax.

          For the `%f', `%e', and `%E' conversions, the precision
          specifies how many digits follow the decimal-point character.
          The default precision is `6'.  If the precision is explicitly
          `0', the decimal point character is suppressed.

          For the `%g' and `%G' conversions, the precision specifies how
          many significant digits to print.  Significant digits are the
          first digit before the decimal point, and all the digits
          after it.  If the precision is `0' or not specified for `%g'
          or `%G', it is treated like a value of `1'.  If the value
          being printed cannot be expressed accurately in the specified
          number of digits, the value is rounded to the nearest number
          that fits.

          For exact conversions, if a precision is supplied it
          specifies the minimum number of digits to appear; leading
          zeros are produced if necessary.  If a precision is not
          supplied, the number is printed with as many digits as
          necessary.  Converting an exact `0' with an explicit
          precision of zero produces no characters.

        * An optional one of `l', `h' or `L', which is ignored for
          numeric conversions.  It is an error to specify these
          modifiers for non-numeric conversions.

        * A character that specifies the conversion to be applied.

     Exact Conversions                                                        |

    `b', `B'
          Print an integer as an unsigned binary number.

          _Note:_ `%b' and `%B' are SLIB extensions.

    `d', `i'
          Print an integer as a signed decimal number.  `%d' and `%i'
          are synonymous for output, but are different when used with
          `scanf' for input (*note Standard Formatted Input::).

    `o'
          Print an integer as an unsigned octal number.

    `u'
          Print an integer as an unsigned decimal number.

    `x', `X'
          Print an integer as an unsigned hexadecimal number.  `%x'
          prints using the digits `0123456789abcdef'.  `%X' prints
          using the digits `0123456789ABCDEF'.

     Inexact Conversions                                                      |

    `f'
          Print a floating-point number in fixed-point notation.

    `e', `E'
          Print a floating-point number in exponential notation.  `%e'
          prints `e' between mantissa and exponont.  `%E' prints `E'
          between mantissa and exponont.

    `g', `G'
          Print a floating-point number in either fixed or exponential
          notation, whichever is more appropriate for its magnitude.
          Unless an `#' flag has been supplied, trailing zeros after a
          decimal point will be stripped off.  `%g' prints `e' between
          mantissa and exponont.  `%G' prints `E' between mantissa and
          exponent.

    `k', `K'
          Print a number like `%g', except that an SI prefix is output
          after the number, which is scaled accordingly.  `%K' outputs a
          dot between number and prefix, `%k' does not.


     Other Conversions                                                        |

    `c'
          Print a single character.  The `-' flag is the only one which
          can be specified.  It is an error to specify a precision.

    `s'
          Print a string.  The `-' flag is the only one which can be
          specified.  A precision specifies the maximum number of
          characters to output; otherwise all characters in the string
          are output.

    `a', `A'
          Print a scheme expression.  The `-' flag left-justifies the
          output.  The `#' flag specifies that strings and characters
          should be quoted as by `write' (which can be read using
          `read'); otherwise, output is as `display' prints.  A
          precision specifies the maximum number of characters to
          output; otherwise as many characters as needed are output.

          _Note:_ `%a' and `%A' are SLIB extensions.

    `%'
          Print a literal `%' character.  No argument is consumed.  It
          is an error to specify flags, field width, precision, or type
          modifiers with `%%'.


File: slib-3b5.info,  Node: Standard Formatted Input,  Prev: Standard Formatted Output,  Up: Standard Formatted I/O
                                                                              |
4.3.3 Standard Formatted Input
------------------------------

`(require 'scanf)' 

 -- Function: scanf-read-list format
 -- Function: scanf-read-list format port
 -- Function: scanf-read-list format string

 -- Macro: scanf format arg1 ...
 -- Macro: fscanf port format arg1 ...
 -- Macro: sscanf str format arg1 ...
     Each function reads characters, interpreting them according to the
     control string FORMAT argument.

     `scanf-read-list' returns a list of the items specified as far as
     the input matches FORMAT.  `scanf', `fscanf', and `sscanf' return
     the number of items successfully matched and stored.  `scanf',
     `fscanf', and `sscanf' also set the location corresponding to ARG1
     ... using the methods:

    symbol
          `set!'

    car expression
          `set-car!'

    cdr expression
          `set-cdr!'

    vector-ref expression
          `vector-set!'

    substring expression
          `substring-move-left!'

     The argument to a `substring' expression in ARG1 ... must be a
     non-constant string.  Characters will be stored starting at the
     position specified by the second argument to `substring'.  The
     number of characters stored will be limited by either the position
     specified by the third argument to `substring' or the length of the
     matched string, whichever is less.

     The control string, FORMAT, contains conversion specifications and
     other characters used to direct interpretation of input sequences.
     The control string contains:

        * White-space characters (blanks, tabs, newlines, or formfeeds)
          that cause input to be read (and discarded) up to the next
          non-white-space character.

        * An ordinary character (not `%') that must match the next
          character of the input stream.

        * Conversion specifications, consisting of the character `%', an
          optional assignment suppressing character `*', an optional
          numerical maximum-field width, an optional `l', `h' or `L'
          which is ignored, and a conversion code.


     Unless the specification contains the `n' conversion character
     (described below), a conversion specification directs the
     conversion of the next input field.  The result of a conversion
     specification is returned in the position of the corresponding
     argument points, unless `*' indicates assignment suppression.
     Assignment suppression provides a way to describe an input field
     to be skipped.  An input field is defined as a string of
     characters; it extends to the next inappropriate character or
     until the field width, if specified, is exhausted.

          _Note:_ This specification of format strings differs from the
          `ANSI C' and `POSIX' specifications.  In SLIB, white space
          before an input field is not skipped unless white space
          appears before the conversion specification in the format
          string.  In order to write format strings which work
          identically with `ANSI C' and SLIB, prepend whitespace to all
          conversion specifications except `[' and `c'.

     The conversion code indicates the interpretation of the input
     field; For a suppressed field, no value is returned.  The
     following conversion codes are legal:

    `%'
          A single % is expected in the input at this point; no value
          is returned.

    `d', `D'
          A decimal integer is expected.

    `u', `U'
          An unsigned decimal integer is expected.

    `o', `O'
          An octal integer is expected.

    `x', `X'
          A hexadecimal integer is expected.

    `i'
          An integer is expected.  Returns the value of the next input
          item, interpreted according to C conventions; a leading `0'
          implies octal, a leading `0x' implies hexadecimal; otherwise,
          decimal is assumed.

    `n'
          Returns the total number of bytes (including white space)
          read by `scanf'.  No input is consumed by `%n'.

    `f', `F', `e', `E', `g', `G'
          A floating-point number is expected.  The input format for
          floating-point numbers is an optionally signed string of
          digits, possibly containing a radix character `.', followed
          by an optional exponent field consisting of an `E' or an `e',
          followed by an optional `+', `-', or space, followed by an
          integer.

    `c', `C'
          WIDTH characters are expected.  The normal
          skip-over-white-space is suppressed in this case; to read the
          next non-space character, use `%1s'.  If a field width is
          given, a string is returned; up to the indicated number of
          characters is read.

    `s', `S'
          A character string is expected The input field is terminated
          by a white-space character.  `scanf' cannot read a null
          string.

    `['
          Indicates string data and the normal
          skip-over-leading-white-space is suppressed.  The left
          bracket is followed by a set of characters, called the
          scanset, and a right bracket; the input field is the maximal
          sequence of input characters consisting entirely of
          characters in the scanset.  `^', when it appears as the first
          character in the scanset, serves as a complement operator and
          redefines the scanset as the set of all characters not
          contained in the remainder of the scanset string.
          Construction of the scanset follows certain conventions.  A
          range of characters may be represented by the construct
          first-last, enabling `[0123456789]' to be expressed `[0-9]'.
          Using this convention, first must be lexically less than or
          equal to last; otherwise, the dash stands for itself.  The
          dash also stands for itself when it is the first or the last
          character in the scanset.  To include the right square
          bracket as an element of the scanset, it must appear as the
          first character (possibly preceded by a `^') of the scanset,
          in which case it will not be interpreted syntactically as the
          closing bracket.  At least one character must match for this
          conversion to succeed.

     The `scanf' functions terminate their conversions at end-of-file,
     at the end of the control string, or when an input character
     conflicts with the control string.  In the latter case, the
     offending character is left unread in the input stream.


File: slib-3b5.info,  Node: Programs and Arguments,  Next: HTML,  Prev: Standard Formatted I/O,  Up: Textual Conversion Packages
                                                                              |
4.4 Program and Arguments
=========================

* Menu:

* Getopt::                      Command Line option parsing
* Command Line::                A command line reader for Scheme shells
* Parameter lists::             'parameters
* Getopt Parameter lists::      'getopt-parameters
* Filenames::                   'filename
* Batch::                       'batch


File: slib-3b5.info,  Node: Getopt,  Next: Command Line,  Prev: Programs and Arguments,  Up: Programs and Arguments
                                                                              |
4.4.1 Getopt
------------

`(require 'getopt)' 

  This routine implements Posix command line argument parsing.  Notice
that returning values through global variables means that `getopt' is
_not_ reentrant.

  Obedience to Posix format for the `getopt' calls sows confusion.
Passing ARGC and ARGV as arguments while referencing OPTIND as a global
variable leads to strange behavior, especially when the calls to
`getopt' are buried in other procedures.

  Even in C, ARGC can be derived from ARGV; what purpose does it serve
beyond providing an opportunity for ARGV/ARGC mismatch?  Just such a
mismatch existed for years in a SLIB `getopt--' example.

  I have removed the ARGC and ARGV arguments to getopt procedures; and
replaced them with a global variable:

 -- Variable: *argv*
     Define *ARGV* with a list of arguments before calling getopt
     procedures.  If you don't want the first (0th) element to be
     ignored, set *OPTIND* to 0 (after requiring getopt).

 -- Variable: *optind*
     Is the index of the current element of the command line.  It is
     initially one.  In order to parse a new command line or reparse an
     old one, *OPTIND* must be reset.

 -- Variable: *optarg*
     Is set by getopt to the (string) option-argument of the current
     option.

 -- Function: getopt optstring
     Returns the next option letter in *ARGV* (starting from
     `(vector-ref argv *optind*)') that matches a letter in OPTSTRING.
     *ARGV* is a vector or list of strings, the 0th of which getopt
     usually ignores.  OPTSTRING is a string of recognized option
     characters; if a character is followed by a colon, the option
     takes an argument which may be immediately following it in the
     string or in the next element of *ARGV*.

     *OPTIND* is the index of the next element of the *ARGV* vector to
     be processed.  It is initialized to 1 by `getopt.scm', and
     `getopt' updates it when it finishes with each element of *ARGV*.

     `getopt' returns the next option character from *ARGV* that
     matches a character in OPTSTRING, if there is one that matches.
     If the option takes an argument, `getopt' sets the variable
     *OPTARG* to the option-argument as follows:

        * If the option was the last character in the string pointed to
          by an element of *ARGV*, then *OPTARG* contains the next
          element of *ARGV*, and *OPTIND* is incremented by 2.  If the
          resulting value of *OPTIND* is greater than or equal to
          `(length *ARGV*)', this indicates a missing option argument,
          and `getopt' returns an error indication.

        * Otherwise, *OPTARG* is set to the string following the option
          character in that element of *ARGV*, and *OPTIND* is
          incremented by 1.

     If, when `getopt' is called, the string `(vector-ref argv
     *optind*)' either does not begin with the character `#\-' or is
     just `"-"', `getopt' returns `#f' without changing *OPTIND*.  If
     `(vector-ref argv *optind*)' is the string `"--"', `getopt'
     returns `#f' after incrementing *OPTIND*.

     If `getopt' encounters an option character that is not contained in
     OPTSTRING, it returns the question-mark `#\?' character.  If it
     detects a missing option argument, it returns the colon character
     `#\:' if the first character of OPTSTRING was a colon, or a
     question-mark character otherwise.  In either case, `getopt' sets
     the variable GETOPT:OPT to the option character that caused the
     error.

     The special option `"--"' can be used to delimit the end of the
     options; `#f' is returned, and `"--"' is skipped.

     RETURN VALUE

     `getopt' returns the next option character specified on the command
     line.  A colon `#\:' is returned if `getopt' detects a missing
     argument and the first character of OPTSTRING was a colon `#\:'.

     A question-mark `#\?' is returned if `getopt' encounters an option
     character not in OPTSTRING or detects a missing argument and the
     first character of OPTSTRING was not a colon `#\:'.

     Otherwise, `getopt' returns `#f' when all command line options
     have been parsed.

     Example:
          #! /usr/local/bin/scm
          (require 'program-arguments)
          (require 'getopt)
          (define argv (program-arguments))
          
          (define opts ":a:b:cd")
          (let loop ((opt (getopt (length argv) argv opts)))
            (case opt
              ((#\a) (print "option a: " *optarg*))
              ((#\b) (print "option b: " *optarg*))
              ((#\c) (print "option c"))
              ((#\d) (print "option d"))
              ((#\?) (print "error" getopt:opt))
              ((#\:) (print "missing arg" getopt:opt))
              ((#f) (if (< *optind* (length argv))
                        (print "argv[" *optind* "]="
                               (list-ref argv *optind*)))
                    (set! *optind* (+ *optind* 1))))
            (if (< *optind* (length argv))
                (loop (getopt (length argv) argv opts))))

          (slib:exit)

4.4.2 Getopt--
--------------

 -- Function: `getopt--' optstring
     The procedure `getopt--' is an extended version of `getopt' which
     parses "long option names" of the form `--hold-the-onions' and
     `--verbosity-level=extreme'.  `Getopt--' behaves as `getopt'
     except for non-empty options beginning with `--'.

     Options beginning with `--' are returned as strings rather than
     characters.  If a value is assigned (using `=') to a long option,
     `*optarg*' is set to the value.  The `=' and value are not
     returned as part of the option string.

     No information is passed to `getopt--' concerning which long
     options should be accepted or whether such options can take
     arguments.  If a long option did not have an argument, `*optarg*'
     will be set to `#f'.  The caller is responsible for detecting and
     reporting errors.

          (define opts ":-:b:")
          (define *argv* '("foo" "-b9" "--f1" "--2=" "--g3=35234.342" "--"))
          (define *optind* 1)
          (define *optarg* #f)
          (require 'qp)
          (do ((i 5 (+ -1 i)))
              ((zero? i))
            (let ((opt (getopt-- opts)))
              (print *optind* opt *optarg*)))
          -|
          2 #\b "9"
          3 "f1" #f
          4 "2" ""
          5 "g3" "35234.342"
          5 #f "35234.342"


File: slib-3b5.info,  Node: Command Line,  Next: Parameter lists,  Prev: Getopt,  Up: Programs and Arguments
                                                                              |
4.4.3 Command Line
------------------

`(require 'read-command)' 

 -- Function: read-command port
 -- Function: read-command
     `read-command' converts a "command line" into a list of strings suitable
     for parsing by `getopt'.  The syntax of command lines supported
     resembles that of popular "shell"s.  `read-command' updates PORT
     to point to the first character past the command delimiter.

     If an end of file is encountered in the input before any
     characters are found that can begin an object or comment, then an
     end of file object is returned.

     The PORT argument may be omitted, in which case it defaults to the
     value returned by `current-input-port'.

     The fields into which the command line is split are delimited by
     whitespace as defined by `char-whitespace?'.  The end of a command
     is delimited by end-of-file or unescaped semicolon (<;>) or
     <newline>.  Any character can be literally included in a field by
     escaping it with a backslach (<\>).

     The initial character and types of fields recognized are:
    `\'
          The next character has is taken literally and not interpreted
          as a field delimiter.  If <\> is the last character before a
          <newline>, that <newline> is just ignored.  Processing
          continues from the characters after the <newline> as though
          the backslash and <newline> were not there.

    `"'
          The characters up to the next unescaped <"> are taken
          literally, according to [R4RS] rules for literal strings
          (*note Strings: (r4rs)Strings.).

    `(', `%''
          One scheme expression is `read' starting with this character.
          The `read' expression is evaluated, converted to a string
          (using `display'), and replaces the expression in the returned
          field.

    `;'
          Semicolon delimits a command.  Using semicolons more than one
          command can appear on a line.  Escaped semicolons and
          semicolons inside strings do not delimit commands.

     The comment field differs from the previous fields in that it must
     be the first character of a command or appear after whitespace in
     order to be recognized.  <#> can be part of fields if these
     conditions are not met.  For instance, `ab#c' is just the field
     ab#c.

    `#'
          Introduces a comment.  The comment continues to the end of
          the line on which the semicolon appears.  Comments are
          treated as whitespace by `read-dommand-line' and backslashes
          before <newline>s in comments are also ignored.

 -- Function: read-options-file filename
     `read-options-file' converts an "options file" into a list of strings
     suitable for parsing by `getopt'.  The syntax of options files is
     the same as the syntax for command lines, except that <newline>s
     do not terminate reading (only <;> or end of file).

     If an end of file is encountered before any characters are found
     that can begin an object or comment, then an end of file object is
     returned.


File: slib-3b5.info,  Node: Parameter lists,  Next: Getopt Parameter lists,  Prev: Command Line,  Up: Programs and Arguments
                                                                              |
4.4.4 Parameter lists
---------------------

`(require 'parameters)' 

Arguments to procedures in scheme are distinguished from each other by
their position in the procedure call.  This can be confusing when a
procedure takes many arguments, many of which are not often used.

A "parameter-list" is a way of passing named information to a
procedure.  Procedures are also defined to set unused parameters to
default values, check parameters, and combine parameter lists.

A PARAMETER has the form `(parameter-name value1 ...)'.  This format
allows for more than one value per parameter-name.

A PARAMETER-LIST is a list of PARAMETERs, each with a different
PARAMETER-NAME.

 -- Function: make-parameter-list parameter-names
     Returns an empty parameter-list with slots for PARAMETER-NAMES.

 -- Function: parameter-list-ref parameter-list parameter-name
     PARAMETER-NAME must name a valid slot of PARAMETER-LIST.
     `parameter-list-ref' returns the value of parameter PARAMETER-NAME
     of PARAMETER-LIST.

 -- Function: remove-parameter parameter-name parameter-list
     Removes the parameter PARAMETER-NAME from PARAMETER-LIST.
     `remove-parameter' does not alter the argument PARAMETER-LIST.

     If there are more than one PARAMETER-NAME parameters, an error is
     signaled.

 -- Procedure: adjoin-parameters! parameter-list parameter1 ...
     Returns PARAMETER-LIST with PARAMETER1 ... merged in.

 -- Procedure: parameter-list-expand expanders parameter-list
     EXPANDERS is a list of procedures whose order matches the order of
     the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.  For each non-false element of EXPANDERS
     that procedure is mapped over the corresponding parameter value
     and the returned parameter lists are merged into PARAMETER-LIST.

     This process is repeated until PARAMETER-LIST stops growing.  The
     value returned from `parameter-list-expand' is unspecified.

 -- Function: fill-empty-parameters defaulters parameter-list
     DEFAULTERS is a list of procedures whose order matches the order
     of the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.  `fill-empty-parameters' returns a new
     parameter-list with each empty parameter replaced with the list
     returned by calling the corresponding DEFAULTER with
     PARAMETER-LIST as its argument.

 -- Function: check-parameters checks parameter-list
     CHECKS is a list of procedures whose order matches the order of
     the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.

     `check-parameters' returns PARAMETER-LIST if each CHECK of the
     corresponding PARAMETER-LIST returns non-false.  If some CHECK
     returns `#f' a warning is signaled.

In the following procedures ARITIES is a list of symbols.  The elements
of `arities' can be:

`single'
     Requires a single parameter.

`optional'
     A single parameter or no parameter is acceptable.

`boolean'
     A single boolean parameter or zero parameters is acceptable.

`nary'
     Any number of parameters are acceptable.

`nary1'
     One or more of parameters are acceptable.

 -- Function: parameter-list->arglist positions arities parameter-list
     Returns PARAMETER-LIST converted to an argument list.  Parameters
     of ARITY type `single' and `boolean' are converted to the single
     value associated with them.  The other ARITY types are converted
     to lists of the value(s).

     POSITIONS is a list of positive integers whose order matches the
     order of the PARAMETER-NAMEs in the call to `make-parameter-list'
     which created PARAMETER-LIST.  The integers specify in which
     argument position the corresponding parameter should appear.


File: slib-3b5.info,  Node: Getopt Parameter lists,  Next: Filenames,  Prev: Parameter lists,  Up: Programs and Arguments
                                                                              |
4.4.5 Getopt Parameter lists
----------------------------

`(require 'getopt-parameters)' 

 -- Function: getopt->parameter-list optnames arities types aliases
          desc ...
     Returns *ARGV* converted to a parameter-list.  OPTNAMES are the
     parameter-names.  ARITIES and TYPES are lists of symbols
     corresponding to OPTNAMES.

     ALIASES is a list of lists of strings or integers paired with
     elements of OPTNAMES.  Each one-character string will be treated
     as a single `-' option by `getopt'.  Longer strings will be
     treated as long-named options (*note getopt-: Getopt.).

     If the ALIASES association list has only strings as its `car's,
     then all the option-arguments after an option (and before the next
     option) are adjoined to that option.

     If the ALIASES association list has integers, then each (string)
     option will take at most one option-argument.  Unoptioned
     arguments are collected in a list.  A `-1' alias will take the
     last argument in this list; `+1' will take the first argument in
     the list.  The aliases -2 then +2; -3 then +3; ... are tried so
     long as a positive or negative consecutive alias is found and
     arguments remain in the list.  Finally a `0' alias, if found,
     absorbs any remaining arguments.

     In all cases, if unclaimed arguments remain after processing, a
     warning is signaled and #f is returned.

 -- Function: getopt->arglist optnames positions arities types
          defaulters checks aliases desc ...
     Like `getopt->parameter-list', but converts *ARGV* to an
     argument-list as specified by OPTNAMES, POSITIONS, ARITIES, TYPES,
     DEFAULTERS, CHECKS, and ALIASES.  If the options supplied violate
     the ARITIES or CHECKS constraints, then a warning is signaled and
     #f is returned.

These `getopt' functions can be used with SLIB relational databases.
For an example, *Note make-command-server: Using Databases.

If errors are encountered while processing options, directions for using
the options (and argument strings DESC ...) are printed to
`current-error-port'.

     (begin
       (set! *optind* 1)
       (set! *argv* '("cmd" "-?")
       (getopt->parameter-list
        '(flag number symbols symbols string flag2 flag3 num2 num3)
        '(boolean optional nary1 nary single boolean boolean nary nary)
        '(boolean integer symbol symbol string boolean boolean integer integer)
        '(("flag" flag)
          ("f" flag)
          ("Flag" flag2)
          ("B" flag3)
          ("optional" number)
          ("o" number)
          ("nary1" symbols)
          ("N" symbols)
          ("nary" symbols)
          ("n" symbols)
          ("single" string)
          ("s" string)
          ("a" num2)
          ("Abs" num3))))
     -|
     Usage: cmd [OPTION ARGUMENT ...] ...

       -f, --flag
       -o, --optional=<number>
       -n, --nary=<symbols> ...
       -N, --nary1=<symbols> ...
       -s, --single=<string>
           --Flag
       -B
       -a        <num2> ...
           --Abs=<num3> ...

     ERROR: getopt->parameter-list "unrecognized option" "-?"


File: slib-3b5.info,  Node: Filenames,  Next: Batch,  Prev: Getopt Parameter lists,  Up: Programs and Arguments
                                                                              |
4.4.6 Filenames
---------------

`(require 'filename)' 

 -- Function: filename:match?? pattern
 -- Function: filename:match-ci?? pattern
     Returns a predicate which returns a non-false value if its string
     argument matches (the string) PATTERN, false otherwise.  Filename
     matching is like "glob" expansion described the bash manpage,
     except that names beginning with `.' are matched and `/'
     characters are not treated specially.

     These functions interpret the following characters specially in
     PATTERN strings:
    `*'
          Matches any string, including the null string.

    `?'
          Matches any single character.

    `[...]'
          Matches any one of the enclosed characters.  A pair of
          characters separated by a minus sign (-) denotes a range; any
          character lexically between those two characters, inclusive,
          is matched.  If the first character following the `[' is a
          `!' or a `^' then any character not enclosed is matched.  A
          `-' or `]' may be matched by including it as the first or
          last character in the set.

 -- Function: filename:substitute?? pattern template
 -- Function: filename:substitute-ci?? pattern template
     Returns a function transforming a single string argument according
     to glob patterns PATTERN and TEMPLATE.  PATTERN and TEMPLATE must
     have the same number of wildcard specifications, which need not be
     identical.  PATTERN and TEMPLATE may have a different number of
     literal sections. If an argument to the function matches PATTERN
     in the sense of `filename:match??' then it returns a copy of
     TEMPLATE in which each wildcard specification is replaced by the
     part of the argument matched by the corresponding wildcard
     specification in PATTERN.  A `*' wildcard matches the longest
     leftmost string possible.  If the argument does not match PATTERN
     then false is returned.

     TEMPLATE may be a function accepting the same number of string
     arguments as there are wildcard specifications in PATTERN.  In the
     case of a match the result of applying TEMPLATE to a list of the
     substrings matched by wildcard specifications will be returned,
     otherwise TEMPLATE will not be called and `#f' will be returned.

     ((filename:substitute?? "scm_[0-9]*.html" "scm5c4_??.htm")
      "scm_10.html")
     => "scm5c4_10.htm"
     ((filename:substitute?? "??" "beg?mid?end") "AZ")
     => "begAmidZend"
     ((filename:substitute?? "*na*" "?NA?") "banana")
     => "banaNA"
     ((filename:substitute?? "?*?" (lambda (s1 s2 s3) (string-append s3 s1)))
      "ABZ")
     => "ZA"

 -- Function: replace-suffix str old new
     STR can be a string or a list of strings.  Returns a new string
     (or strings) similar to `str' but with the suffix string OLD
     removed and the suffix string NEW appended.  If the end of STR
     does not match OLD, an error is signaled.

     (replace-suffix "/usr/local/lib/slib/batch.scm" ".scm" ".c")
     => "/usr/local/lib/slib/batch.c"

 -- Function: call-with-tmpnam proc k
 -- Function: call-with-tmpnam proc
     Calls PROC with K arguments, strings returned by successive calls
     to `tmpnam'.  If PROC returns, then any files named by the
     arguments to PROC are deleted automatically and the value(s)
     yielded by the PROC is(are) returned.  K may be ommited, in which
     case it defaults to `1'.


 -- Function: call-with-tmpnam proc suffix1 ...
     Calls PROC with strings returned by successive calls to `tmpnam',
     each with the corresponding SUFFIX string appended.  If PROC
     returns, then any files named by the arguments to PROC are deleted
     automatically and the value(s) yielded by the PROC is(are)
     returned.


File: slib-3b5.info,  Node: Batch,  Prev: Filenames,  Up: Programs and Arguments
                                                                              |
4.4.7 Batch
-----------

`(require 'batch)' 

The batch procedures provide a way to write and execute portable scripts
for a variety of operating systems.  Each `batch:' procedure takes as
its first argument a parameter-list (*note Parameter lists::).  This
parameter-list argument PARMS contains named associations.  Batch
currently uses 2 of these:

`batch-port'
     The port on which to write lines of the batch file.

`batch-dialect'
     The syntax of batch file to generate.  Currently supported are:
        * unix

        * dos

        * vms

        * amigaos

        * system

        * *unknown*

The `batch' module uses 2 enhanced relational tables (*note Using
Databases::) to store information linking the names of
`operating-system's to `batch-dialect'es.

 -- Function: batch:initialize! database
     Defines `operating-system' and `batch-dialect' tables and adds the
     domain `operating-system' to the enhanced relational database
     DATABASE.

 -- Variable: *operating-system*
     Is batch's best guess as to which operating-system it is running
     under.  `*operating-system*' is set to `(software-type)' (*note
     Configuration::) unless `(software-type)' is `unix', in which case
     finer distinctions are made.

 -- Function: batch:call-with-output-script parms file proc
     PROC should be a procedure of one argument.  If FILE is an
     output-port, `batch:call-with-output-script' writes an appropriate
     header to FILE and then calls PROC with FILE as the only argument.
     If FILE is a string, `batch:call-with-output-script' opens a
     output-file of name FILE, writes an appropriate header to FILE,
     and then calls PROC with the newly opened port as the only
     argument.  Otherwise, `batch:call-with-output-script' acts as if
     it was called with the result of `(current-output-port)' as its
     third argument.

The rest of the `batch:' procedures write (or execute if
`batch-dialect' is `system') commands to the batch port which has been
added to PARMS or `(copy-tree PARMS)' by the code:

     (adjoin-parameters! PARMS (list 'batch-port PORT))

 -- Function: batch:command parms string1 string2 ...
     Calls `batch:try-command' (below) with arguments, but signals an
     error if `batch:try-command' returns `#f'.

These functions return a non-false value if the command was successfully
translated into the batch dialect and `#f' if not.  In the case of the
`system' dialect, the value is non-false if the operation suceeded.

 -- Function: batch:try-command parms string1 string2 ...
     Writes a command to the `batch-port' in PARMS which executes the
     program named STRING1 with arguments STRING2 ....

 -- Function: batch:try-chopped-command parms arg1 arg2 ... list
     breaks the last argument LIST into chunks small enough so that the
     command:

          ARG1 ARG2 ... CHUNK

     fits withing the platform's maximum command-line length.

     `batch:try-chopped-command' calls `batch:try-command' with the
     command and returns non-false only if the commands all fit and
     `batch:try-command' of each command line returned non-false.

 -- Function: batch:run-script parms string1 string2 ...
     Writes a command to the `batch-port' in PARMS which executes the
     batch script named STRING1 with arguments STRING2 ....

     _Note:_ `batch:run-script' and `batch:try-command' are not the
     same for some operating systems (VMS).

 -- Function: batch:comment parms line1 ...
     Writes comment lines LINE1 ... to the `batch-port' in PARMS.

 -- Function: batch:lines->file parms file line1 ...
     Writes commands to the `batch-port' in PARMS which create a file
     named FILE with contents LINE1 ....

 -- Function: batch:delete-file parms file
     Writes a command to the `batch-port' in PARMS which deletes the
     file named FILE.

 -- Function: batch:rename-file parms old-name new-name
     Writes a command to the `batch-port' in PARMS which renames the
     file OLD-NAME to NEW-NAME.

In addition, batch provides some small utilities very useful for writing
scripts:

 -- Function: truncate-up-to path char
 -- Function: truncate-up-to path string
 -- Function: truncate-up-to path charlist
     PATH can be a string or a list of strings.  Returns PATH sans any
     prefixes ending with a character of the second argument.  This can
     be used to derive a filename moved locally from elsewhere.

          (truncate-up-to "/usr/local/lib/slib/batch.scm" "/")
          => "batch.scm"

 -- Function: string-join joiner string1 ...
     Returns a new string consisting of all the strings STRING1 ...  in
     order appended together with the string JOINER between each
     adjacent pair.

 -- Function: must-be-first list1 list2
     Returns a new list consisting of the elements of LIST2 ordered so
     that if some elements of LIST1 are `equal?' to elements of LIST2,
     then those elements will appear first and in the order of LIST1.

 -- Function: must-be-last list1 list2
     Returns a new list consisting of the elements of LIST1 ordered so
     that if some elements of LIST2 are `equal?' to elements of LIST1,
     then those elements will appear last and in the order of LIST2.

 -- Function: os->batch-dialect osname
     Returns its best guess for the `batch-dialect' to be used for the
     operating-system named OSNAME.  `os->batch-dialect' uses the
     tables added to DATABASE by `batch:initialize!'.

Here is an example of the use of most of batch's procedures:

     (require 'databases)
     (require 'parameters)
     (require 'batch)
     (require 'filename)
     
     (define batch (create-database #f 'alist-table))
     (batch:initialize! batch)

     (define my-parameters
       (list (list 'batch-dialect (os->batch-dialect *operating-system*))
             (list 'operating-system *operating-system*)
             (list 'batch-port (current-output-port)))) ;gets filled in later

     (batch:call-with-output-script
      my-parameters
      "my-batch"
      (lambda (batch-port)
        (adjoin-parameters! my-parameters (list 'batch-port batch-port))
        (and
         (batch:comment my-parameters
                        "================ Write file with C program.")
         (batch:rename-file my-parameters "hello.c" "hello.c~")
         (batch:lines->file my-parameters "hello.c"
                            "#include <stdio.h>"
                            "int main(int argc, char **argv)"
                            "{"
                            "  printf(\"hello world\\n\");"
                            "  return 0;"
                            "}" )
         (batch:command my-parameters "cc" "-c" "hello.c")
         (batch:command my-parameters "cc" "-o" "hello"
                       (replace-suffix "hello.c" ".c" ".o"))
         (batch:command my-parameters "hello")
         (batch:delete-file my-parameters "hello")
         (batch:delete-file my-parameters "hello.c")
         (batch:delete-file my-parameters "hello.o")
         (batch:delete-file my-parameters "my-batch")
         )))

Produces the file `my-batch':

     #! /bin/sh
     # "my-batch" script created by SLIB/batch Sun Oct 31 18:24:10 1999
     # ================ Write file with C program.
     mv -f hello.c hello.c~
     rm -f hello.c
     echo '#include <stdio.h>'>>hello.c
     echo 'int main(int argc, char **argv)'>>hello.c
     echo '{'>>hello.c
     echo '  printf("hello world\n");'>>hello.c
     echo '  return 0;'>>hello.c
     echo '}'>>hello.c
     cc -c hello.c
     cc -o hello hello.o
     hello
     rm -f hello
     rm -f hello.c
     rm -f hello.o
     rm -f my-batch

When run, `my-batch' prints:

     bash$ my-batch
     mv: hello.c: No such file or directory
     hello world


File: slib-3b5.info,  Node: HTML,  Next: HTML Tables,  Prev: Programs and Arguments,  Up: Textual Conversion Packages
                                                                              |
4.5 HTML
========

`(require 'html-form)' 

 -- Function: html:atval txt
     Returns a string with character substitutions appropriate to send
     TXT as an "attribute-value".  

 -- Function: html:plain txt
     Returns a string with character substitutions appropriate to send
     TXT as an "plain-text".  

 -- Function: html:meta name content
     Returns a tag of meta-information suitable for passing as the
     third argument to `html:head'.  The tag produced is `<META
     NAME="NAME" CONTENT="CONTENT">'.  The string or symbol NAME can be
     `author', `copyright', `keywords', `description', `date',
     `robots', ....

 -- Function: html:http-equiv name content
     Returns a tag of HTTP information suitable for passing as the
     third argument to `html:head'.  The tag produced is `<META
     HTTP-EQUIV="NAME" CONTENT="CONTENT">'.  The string or symbol NAME
     can be `Expires', `PICS-Label', `Content-Type', `Refresh', ....

 -- Function: html:meta-refresh delay uri
 -- Function: html:meta-refresh delay
     Returns a tag suitable for passing as the third argument to
     `html:head'.  If URI argument is supplied, then DELAY seconds after
     displaying the page with this tag, Netscape or IE browsers will
     fetch and display URI.  Otherwise, DELAY seconds after displaying
     the page with this tag, Netscape or IE browsers will fetch and
     redisplay this page.

 -- Function: html:head title backlink tags ...
 -- Function: html:head title backlink
 -- Function: html:head title
     Returns header string for an HTML page named TITLE.  If BACKLINK
     is a string, it is used verbatim between the `H1' tags; otherwise
     TITLE is used.  If string arguments TAGS ... are supplied, then
     they are included verbatim within the <HEAD> section.

 -- Function: html:body body ...
     Returns HTML string to end a page.

 -- Function: html:pre line1 line ...
     Returns the strings LINE1, LINES as "PRE"formmated plain text (rendered
     in fixed-width font).  Newlines are inserted between LINE1, LINES.
     HTML tags (`<tag>') within LINES will be visible verbatim.

 -- Function: html:comment line1 line ...
     Returns the strings LINE1 as HTML comments.

4.6 HTML Forms
==============

 -- Function: html:form method action body ...
     The symbol METHOD is either `get', `head', `post', `put', or
     `delete'.  The strings BODY form the body of the form.
     `html:form' returns the HTML "form".  

 -- Function: html:hidden name value
     Returns HTML string which will cause NAME=VALUE in form.

 -- Function: html:checkbox pname default
     Returns HTML string for check box.

 -- Function: html:text pname default size ...
     Returns HTML string for one-line text box.

 -- Function: html:text-area pname default-list
     Returns HTML string for multi-line text box.

 -- Function: html:select pname arity default-list foreign-values
     Returns HTML string for pull-down menu selector.

 -- Function: html:buttons pname arity default-list foreign-values
     Returns HTML string for any-of selector.

 -- Function: form:submit submit-label command
 -- Function: form:submit submit-label
     The string or symbol SUBMIT-LABEL appears on the button which
     submits the form.  If the optional second argument COMMAND is
     given, then `*command*=COMMAND' and `*button*=SUBMIT-LABEL' are
     set in the query.  Otherwise, `*command*=SUBMIT-LABEL' is set in
     the query.

 -- Function: form:image submit-label image-src
     The IMAGE-SRC appears on the button which submits the form.

 -- Function: form:reset
     Returns a string which generates a "reset" button.  

 -- Function: form:element pname arity default-list foreign-values
     Returns a string which generates an INPUT element for the field
     named PNAME.  The element appears in the created form with its
     representation determined by its ARITY and domain.  For domains
     which are foreign-keys:

    `single'
          select menu

    `optional'
          select menu

    `nary'
          check boxes

    `nary1'
          check boxes

     If the foreign-key table has a field named `visible-name', then
     the contents of that field are the names visible to the user for
     those choices.  Otherwise, the foreign-key itself is visible.

     For other types of domains:

    `single'
          text area

    `optional'
          text area

    `boolean'
          check box

    `nary'
          text area

    `nary1'
          text area

 -- Function: form:delimited pname doc aliat arity default-list
          foreign-values
     Returns a HTML string for a form element embedded in a line of a
     delimited list.  Apply map `form:delimited' to the list returned by
     `command->p-specs'.

 -- Function: html:delimited-list row ...
     Wraps its arguments with delimited-list (`DL' command.

 -- Function: get-foreign-choices tab
     Returns a list of the `visible-name' or first fields of table TAB.

 -- Function: command->p-specs rdb command-table command
     The symbol COMMAND-TABLE names a command table in the RDB
     relational database.  The symbol COMMAND names a key in
     COMMAND-TABLE.

     `command->p-specs' returns a list of lists of PNAME, DOC, ALIAT,
     ARITY, DEFAULT-LIST, and FOREIGN-VALUES.  The returned list has
     one element for each parameter of command COMMAND.

     This example demonstrates how to create a HTML-form for the `build'
     command.

          (require (in-vicinity (implementation-vicinity) "build.scm"))
          (call-with-output-file "buildscm.html"
            (lambda (port)
              (display
               (string-append
                (html:head 'commands)
                (html:body
                 (sprintf #f "<H2>%s:</H2><BLOCKQUOTE>%s</BLOCKQUOTE>\\n"
                          (html:plain 'build)
                          (html:plain ((comtab 'get 'documentation) 'build)))
                 (html:form
                  'post
                  (or "http://localhost:8081/buildscm" "/cgi-bin/build.cgi")
                  (apply html:delimited-list
                         (apply map form:delimited
                                (command->p-specs build '*commands* 'build)))
                  (form:submit 'build)
                  (form:reset))))
               port)))


File: slib-3b5.info,  Node: HTML Tables,  Next: HTTP and CGI,  Prev: HTML,  Up: Textual Conversion Packages
                                                                              |
4.7 HTML Tables
===============

`(require 'db->html)' 

 -- Function: html:table options row ...

 -- Function: html:caption caption align
 -- Function: html:caption caption
     ALIGN can be `top' or `bottom'.

 -- Function: html:heading columns
     Outputs a heading row for the currently-started table.

 -- Function: html:href-heading columns uris
     Outputs a heading row with column-names COLUMNS linked to URIs
     URIS.

 -- Function: html:linked-row-converter k foreigns
     The positive integer K is the primary-key-limit (number of
     primary-keys) of the table.  FOREIGNS is a list of the filenames of
     foreign-key field pages and #f for non foreign-key fields.

     `html:linked-row-converter' returns a procedure taking a row for
     its single argument.  This returned procedure returns the html
     string for that table row.

 -- Function: table-name->filename table-name
     Returns the symbol TABLE-NAME converted to a filename.

 -- Function: table->linked-html caption db table-name match-key1 ...
     Returns HTML string for DB table TABLE-NAME chopped into 50-row
     HTML tables.  Every foreign-key value is linked to the page (of
     the table) defining that key.

     The optional MATCH-KEY1 ... arguments restrict actions to a subset
     of the table.  *Note match-key: Table Operations.

 -- Function: table->linked-page db table-name index-filename arg ...
     Returns a complete HTML page.  The string INDEX-FILENAME names the
     page which refers to this one.

     The optional ARGS ... arguments restrict actions to a subset of
     the table.  *Note match-key: Table Operations.

 -- Function: catalog->html db caption arg ...
     Returns HTML string for the catalog table of DB.

4.7.1 HTML editing tables
-------------------------

A client can modify one row of an editable table at a time.  For any
change submitted, these routines check if that row has been modified
during the time the user has been editing the form.  If so, an error
page results.

The behavior of edited rows is:

   * If no fields are changed, then no change is made to the table.

   * If the primary keys equal null-keys (parameter defaults), and no
     other user has modified that row, then that row is deleted.

   * If only primary keys are changed, there are non-key fields, and no
     row with the new keys is in the table, then the old row is deleted
     and one with the new keys is inserted.

   * If only non-key fields are changed, and that row has not been
     modified by another user, then the row is changed to reflect the
     fields.

   * If both keys and non-key fields are changed, and no row with the
     new keys is in the table, then a row is created with the new keys
     and fields.

   * If fields are changed, all fields are primary keys, and no row with
     the new keys is in the table, then a row is created with the new
     keys.

After any change to the table, a `sync-database' of the database is
performed.

 -- Function: command:modify-table table-name null-keys update delete
          retrieve
 -- Function: command:modify-table table-name null-keys update delete
 -- Function: command:modify-table table-name null-keys update
 -- Function: command:modify-table table-name null-keys
     Returns procedure (of DB) which returns procedure to modify row of
     TABLE-NAME.  NULL-KEYS is the list of "null" keys indicating the
     row is to be deleted when any matches its corresponding primary
     key.  Optional arguments UPDATE, DELETE, and RETRIEVE default to
     the `row:update', `row:delete', and `row:retrieve' of TABLE-NAME
     in DB.

 -- Function: command:make-editable-table rdb table-name arg ...
     Given TABLE-NAME in RDB, creates parameter and `*command*' tables
     for editing one row of TABLE-NAME at a time.
     `command:make-editable-table' returns a procedure taking a row
     argument which returns the HTML string for editing that row.

     Optional ARGS are expressions (lists) added to the call to
     `command:modify-table'.

     The domain name of a column determines the expected arity of the
     data stored in that column.  Domain names ending in:

    `*'
          have arity `nary';

    `+'
          have arity `nary1'.

 -- Function: html:editable-row-converter k names edit-point
          edit-converter
     The positive integer K is the primary-key-limit (number of
     primary-keys) of the table.  NAMES is a list of the field-names.
     EDIT-POINT is the list of primary-keys denoting the row to edit
     (or #f).  EDIT-CONVERTER is the procedure called with K, NAMES,
     and the row to edit.

     `html:editable-row-converter' returns a procedure taking a row for
     its single argument.  This returned procedure returns the html
     string for that table row.

     Each HTML table constructed using `html:editable-row-converter'
     has first K fields (typically the primary key fields) of each row
     linked to a text encoding of these fields (the result of calling
     `row->anchor').  The page so referenced typically allows the user
     to edit fields of that row.

4.7.2 HTML databases
--------------------

 -- Function: db->html-files db dir index-filename caption
     DB must be a relational database.  DIR must be #f or a non-empty
     string naming an existing sub-directory of the current directory.

     `db->html-files' creates an html page for each table in the
     database DB in the sub-directory named DIR, or the current
     directory if DIR is #f.  The top level page with the catalog of
     tables (captioned CAPTION) is written to a file named
     INDEX-FILENAME.

 -- Function: db->html-directory db dir index-filename
 -- Function: db->html-directory db dir
     DB must be a relational database.  DIR must be a non-empty string
     naming an existing sub-directory of the current directory or one
     to be created.  The optional string INDEX-FILENAME names the
     filename of the top page, which defaults to `index.html'.

     `db->html-directory' creates sub-directory DIR if neccessary, and
     calls `(db->html-files DB DIR INDEX-FILENAME DIR)'.  The `file:'
     URI of INDEX-FILENAME is returned.

 -- Function: db->netscape db dir index-filename
 -- Function: db->netscape db dir
     `db->netscape' is just like `db->html-directory', but calls
     `browse-url' with the uri for the top page after the pages are
     created.


File: slib-3b5.info,  Node: HTTP and CGI,  Next: Parsing HTML,  Prev: HTML Tables,  Up: Textual Conversion Packages
                                                                              |
4.8 HTTP and CGI
================

`(require 'http)' or `(require 'cgi)' 

 -- Function: http:header alist
     Returns a string containing lines for each element of ALIST; the
     `car' of which is followed by `: ', then the `cdr'.

 -- Function: http:content alist body ...
     Returns the concatenation of strings BODY with the `(http:header
     ALIST)' and the `Content-Length' prepended.

 -- Variable: *http:byline*
     String appearing at the bottom of error pages.

 -- Function: http:error-page status-code reason-phrase html-string ...
     STATUS-CODE and REASON-PHRASE should be an integer and string as
     specified in `RFC 2068'.  The returned page (string) will show the
     STATUS-CODE and REASON-PHRASE and any additional HTML-STRINGS ...;
     with *HTTP:BYLINE* or SLIB's default at the bottom.

 -- Function: http:forwarding-page title dly uri html-string ...
     The string or symbol TITLE is the page title.  DLY is a
     non-negative integer.  The HTML-STRINGS ... are typically used to
     explain to the user why this page is being forwarded.

     `http:forwarding-page' returns an HTML string for a page which
     automatically forwards to URI after DLY seconds.  The returned
     page (string) contains any HTML-STRINGS ... followed by a manual
     link to URI, in case the browser does not forward automatically.

 -- Function: http:serve-query serve-proc input-port output-port
     reads the "URI" and "query-string" from INPUT-PORT.  If the query
     is a valid `"POST"' or `"GET"' query, then `http:serve-query' calls
     SERVE-PROC with three arguments, the REQUEST-LINE, QUERY-STRING,
     and HEADER-ALIST.  Otherwise, `http:serve-query' calls SERVE-PROC
     with the REQUEST-LINE, #f, and HEADER-ALIST.

     If SERVE-PROC returns a string, it is sent to OUTPUT-PORT.  If
     SERVE-PROC returns a list whose first element is an integer, then        |
     an error page with the status integer which is the first element         |
     of the list and strings from the list.  If SERVE-PROC returns a          |
     list whose first element isn't an number, then an error page with        |
     the status code 500 and strings from the list.  If SERVE-PROC            |
     returns #f, then a `Bad Request' (400) page is sent to OUTPUT-PORT.      |

     Otherwise, `http:serve-query' replies (to OUTPUT-PORT) with
     appropriate HTML describing the problem.

  This example services HTTP queries from PORT-NUMBER:

     (define socket (make-stream-socket AF_INET 0))
     (and (socket:bind socket port-number) ; AF_INET INADDR_ANY
          (socket:listen socket 10)        ; Queue up to 10 requests.
          (dynamic-wind
              (lambda () #f)
              (lambda ()
                (do ((port (socket:accept socket) (socket:accept socket)))
                    (#f)
                  (let ((iport (duplicate-port port "r"))
                        (oport (duplicate-port port "w")))
                    (http:serve-query build:serve iport oport)
                    (close-port iport)
                    (close-port oport))
                  (close-port port)))
              (lambda () (close-port socket))))

 -- Function: cgi:serve-query serve-proc
     reads the "URI" and "query-string" from `(current-input-port)'.
     If the query is a valid `"POST"' or `"GET"' query, then
     `cgi:serve-query' calls SERVE-PROC with three arguments, the
     REQUEST-LINE, QUERY-STRING, and HEADER-ALIST.  Otherwise,
     `cgi:serve-query' calls SERVE-PROC with the REQUEST-LINE, #f, and
     HEADER-ALIST.

     If SERVE-PROC returns a string, it is sent to
     `(current-ouput-port)'.  If SERVE-PROC returns a list whose first        |
     element is an integer, then an error page with the status integer        |
     which is the first element of the list and strings from the list.        |
     If SERVE-PROC returns a list whose first element isn't an number,        |
     then an error page with the status code 500 and strings from the         |
     list.  If SERVE-PROC returns #f, then a `Bad Request' (400) page         |
     is sent to `(current-ouput-port)'.                                       |

     Otherwise, `cgi:serve-query' replies (to `(current-output-port)')        |
     with appropriate HTML describing the problem.

 -- Function: make-query-alist-command-server rdb command-table
 -- Function: make-query-alist-command-server rdb command-table #t
     Returns a procedure of one argument.  When that procedure is called
     with a QUERY-ALIST (as returned by `uri:decode-query', the value
     of the `*command*' association will be the command invoked in
     COMMAND-TABLE.  If `*command*' is not in the QUERY-ALIST then the
     value of `*suggest*' is tried.  If neither name is in the
     QUERY-ALIST, then the literal value `*default*' is tried in
     COMMAND-TABLE.

     If optional third argument is non-false, then the command is called
     with just the parameter-list; otherwise, command is called with the
     arguments described in its table.


File: slib-3b5.info,  Node: Parsing HTML,  Next: URI,  Prev: HTTP and CGI,  Up: Textual Conversion Packages
                                                                              |
4.9 Parsing HTML
================

`(require 'html-for-each)' 

 -- Function: html-for-each file word-proc markup-proc white-proc
          newline-proc
     FILE is an input port or a string naming an existing file
     containing HTML text.  WORD-PROC is a procedure of one argument or
     #f.  MARKUP-PROC is a procedure of one argument or #f.  WHITE-PROC
     is a procedure of one argument or #f.  NEWLINE-PROC is a procedure
     of no arguments or #f.

     `html-for-each' opens and reads characters from port FILE or the
     file named by string FILE.  Sequential groups of characters are
     assembled into strings which are either

        * enclosed by `<' and `>' (hypertext markups or comments);

        * end-of-line;

        * whitespace; or

        * none of the above (words).

     Procedures are called according to these distinctions in order of
     the string's occurrence in FILE.

     NEWLINE-PROC is called with no arguments for end-of-line _not
     within a markup or comment_.

     WHITE-PROC is called with strings of non-newline whitespace.

     MARKUP-PROC is called with hypertext markup strings (including `<'
     and `>').

     WORD-PROC is called with the remaining strings.

     `html-for-each' returns an unspecified value.

 -- Function: html:read-title file limit
 -- Function: html:read-title file
     FILE is an input port or a string naming an existing file
     containing HTML text.  If supplied, LIMIT must be an integer.
     LIMIT defaults to 1000.

     `html:read-title' opens and reads HTML from port FILE or the file
     named by string FILE, until reaching the (mandatory) `TITLE'
     field.  `html:read-title' returns the title string with adjacent
     whitespaces collapsed to one space.  `html:read-title' returns #f
     if the title field is empty, absent, if the first character read
     from FILE is not `#\<', or if the end of title is not found within
     the first (approximately) LIMIT words.

 -- Function: htm-fields htm
     HTM is a hypertext markup string.

     If HTM is a (hypertext) comment or DTD, then `htm-fields' returns
     #f.  Otherwise `htm-fields' returns the hypertext element string
     consed onto an association list of the attribute name-symbols and
     values.  If the tag ends with "/>", then "/" is appended to the
     hypertext element string.  The name-symbols are created by
     `string-ci->symbol'.  Each value is a string; or #t if the name
     had no value assigned within the markup.


File: slib-3b5.info,  Node: URI,  Next: Parsing XML,  Prev: Parsing HTML,  Up: Textual Conversion Packages
                                                                              |
4.10 URI
========

`(require 'uri)' 

Implements "Uniform Resource Identifiers" (URI) as described in RFC
2396.

 -- Function: make-uri
 -- Function: make-uri fragment
 -- Function: make-uri query fragment
 -- Function: make-uri path query fragment
 -- Function: make-uri authority path query fragment
 -- Function: make-uri scheme authority path query fragment
     Returns a Uniform Resource Identifier string from component
     arguments.

 -- Function: uri:make-path path
     Returns a URI string combining the components of list PATH.

 -- Function: html:anchor name
     Returns a string which defines this location in the (HTML) file as
     NAME.  The hypertext `<A HREF="#NAME">' will link to this point.

          (html:anchor "(section 7)")
          =>
          "<A NAME=\"(section%207)\"></A>"

 -- Function: html:link uri highlighted
     Returns a string which links the HIGHLIGHTED text to URI.

          (html:link (make-uri "(section 7)") "section 7")
          =>
          "<A HREF=\"#(section%207)\">section 7</A>"

 -- Function: html:base uri
     Returns a string specifying the "base" URI of a document, for inclusion
     in the HEAD of the document (*note head: HTML.).

 -- Function: html:isindex prompt
     Returns a string specifying the search PROMPT of a document, for
     inclusion in the HEAD of the document (*note head: HTML.).

 -- Function: uri->tree uri-reference base-tree
 -- Function: uri->tree uri-reference
     Returns a list of 5 elements corresponding to the parts (SCHEME
     AUTHORITY PATH QUERY FRAGMENT) of string URI-REFERENCE.  Elements
     corresponding to absent parts are #f.

     The PATH is a list of strings.  If the first string is empty, then
     the path is absolute; otherwise relative.  The optional BASE-TREE
     is a tree as returned by `uri->tree'; and is used as the base
     address for relative URIs.

     If the AUTHORITY component is a "Server-based Naming Authority",
     then it is a list of the USERINFO, HOST, and PORT strings (or #f).
     For other types of AUTHORITY components the AUTHORITY will be a
     string.

          (uri->tree "http://www.ics.uci.edu/pub/ietf/uri/#Related")
          =>
          (http "www.ics.uci.edu" ("" "pub" "ietf" "uri" "") #f "Related")

 -- Function: uri:split-fields txt chr
     Returns a list of TXT split at each occurrence of CHR.  CHR does
     not appear in the returned list of strings.

 -- Function: uri:decode-query query-string
     Converts a "URI" encoded QUERY-STRING to a query-alist.  

`uric:' prefixes indicate procedures dealing with URI-components.

 -- Function: uric:encode uri-component allows
     Returns a copy of the string URI-COMPONENT in which all "unsafe"
     octets (as defined in RFC 2396) have been `%' "escaped".  `uric:decode'
     decodes strings encoded by `uric:encode'.

 -- Function: uric:decode uri-component
     Returns a copy of the string URI-COMPONENT in which each `%'
     escaped characters in URI-COMPONENT is replaced with the character
     it encodes.  This routine is useful for showing URI contents on
     error pages.

 -- Function: uri:path->keys path-list ptypes
     PATH-LIST is a path-list as returned by `uri:split-fields'.
     `uri:path->keys' returns a list of items returned by
     `uri:decode-path', coerced to types PTYPES.

File-system Locators and Predicates
-----------------------------------

 -- Function: path->uri path
     Returns a URI-string for PATH on the local host.

 -- Function: absolute-uri? str
     Returns #t if STR is an absolute-URI as indicated by a
     syntactically valid (per RFC 2396) "scheme"; otherwise returns #f.

 -- Function: absolute-path? file-name
     Returns #t if FILE-NAME is a fully specified pathname (does not
     depend on the current working directory); otherwise returns #f.

 -- Function: null-directory? str
     Returns #t if changing directory to STR would leave the current
     directory unchanged; otherwise returns #f.

 -- Function: glob-pattern? str
     Returns #t if the string STR contains characters used for
     specifying glob patterns, namely `*', `?', or `['.

Before RFC 2396, the "File Transfer Protocol" (FTP) served a similar
purpose.

 -- Function: parse-ftp-address uri
     Returns a list of the decoded FTP URI; or #f if indecipherable.
     FTP "Uniform Resource Locator", "ange-ftp", and "getit" formats
     are handled.  The returned list has four elements which are
     strings or #f:

       0. username

       1. password

       2. remote-site

       3. remote-directory


File: slib-3b5.info,  Node: Parsing XML,  Next: Printing Scheme,  Prev: URI,  Up: Textual Conversion Packages
                                                                              |
4.11 Parsing XML
================

`(require 'xml-parse)' or `(require 'ssax)'

The XML standard document referred to in this module is
`http://www.w3.org/TR/1998/REC-xml-19980210.html'.

The present frameworks fully supports the XML Namespaces Recommendation
`http://www.w3.org/TR/REC-xml-names'.

4.11.1 String Glue
------------------

 -- Function: ssax:reverse-collect-str list-of-frags
     Given the list of fragments (some of which are text strings),
     reverse the list and concatenate adjacent text strings.  If
     LIST-OF-FRAGS has zero or one element, the result of the procedure
     is `equal?' to its argument.

 -- Function: ssax:reverse-collect-str-drop-ws list-of-frags
     Given the list of fragments (some of which are text strings),
     reverse the list and concatenate adjacent text strings while
     dropping "unsignificant" whitespace, that is, whitespace in front,
     behind and between elements.  The whitespace that is included in
     character data is not affected.

     Use this procedure to "intelligently" drop "insignificant"
     whitespace in the parsed SXML.  If the strict compliance with the
     XML Recommendation regarding the whitespace is desired, use the
     `ssax:reverse-collect-str' procedure instead.

4.11.2 Character and Token Functions
------------------------------------

The following functions either skip, or build and return tokens,
according to inclusion or delimiting semantics.  The list of characters
to expect, include, or to break at may vary from one invocation of a
function to another.  This allows the functions to easily parse even
context-sensitive languages.

  Exceptions are mentioned specifically.  The list of expected
characters (characters to skip until, or break-characters) may include
an EOF "character", which is coded as symbol *eof*

  The input stream to parse is specified as a PORT, which is the last
argument.

 -- Function: ssax:assert-current-char char-list string port
     Reads a character from the PORT and looks it up in the CHAR-LIST
     of expected characters.  If the read character was found among
     expected, it is returned.  Otherwise, the procedure writes a
     message using STRING as a comment and quits.

 -- Function: ssax:skip-while char-list port
     Reads characters from the PORT and disregards them, as long as they
     are mentioned in the CHAR-LIST.  The first character (which may be
     EOF) peeked from the stream that is _not_ a member of the
     CHAR-LIST is returned.

 -- Function: ssax:init-buffer
     Returns an initial buffer for `ssax:next-token*' procedures.
     `ssax:init-buffer' may allocate a new buffer at each invocation.

 -- Function: ssax:next-token prefix-char-list break-char-list
          comment-string port
     Skips any number of the prefix characters (members of the
     PREFIX-CHAR-LIST), if any, and reads the sequence of characters up
     to (but not including) a break character, one of the
     BREAK-CHAR-LIST.

     The string of characters thus read is returned.  The break
     character is left on the input stream.  BREAK-CHAR-LIST may
     include the symbol `*eof*'; otherwise, EOF is fatal, generating an
     error message including a specified COMMENT-STRING.

`ssax:next-token-of' is similar to `ssax:next-token' except that it
implements an inclusion rather than delimiting semantics.

 -- Function: ssax:next-token-of inc-charset port
     Reads characters from the PORT that belong to the list of
     characters INC-CHARSET.  The reading stops at the first character
     which is not a member of the set.  This character is left on the
     stream.  All the read characters are returned in a string.


 -- Function: ssax:next-token-of pred port
     Reads characters from the PORT for which PRED (a procedure of one
     argument) returns non-#f.  The reading stops at the first
     character for which PRED returns #f.  That character is left on
     the stream.  All the results of evaluating of PRED up to #f are
     returned in a string.

     PRED is a procedure that takes one argument (a character or the
     EOF object) and returns a character or #f.  The returned character
     does not have to be the same as the input argument to the PRED.
     For example,

          (ssax:next-token-of (lambda (c)
                                (cond ((eof-object? c) #f)
                                      ((char-alphabetic? c) (char-downcase c))
                                      (else #f)))
                              (current-input-port))

     will try to read an alphabetic token from the current input port,
     and return it in lower case.

 -- Function: ssax:read-string len port
     Reads LEN characters from the PORT, and returns them in a string.
     If EOF is encountered before LEN characters are read, a shorter
     string will be returned.

4.11.3 Data Types
-----------------

`TAG-KIND'
     A symbol `START', `END', `PI', `DECL', `COMMENT', `CDSECT', or
     `ENTITY-REF' that identifies a markup token

`UNRES-NAME'
     a name (called GI in the XML Recommendation) as given in an XML
     document for a markup token: start-tag, PI target, attribute name.
     If a GI is an NCName, UNRES-NAME is this NCName converted into a
     Scheme symbol.  If a GI is a QName, `UNRES-NAME' is a pair of
     symbols: `(PREFIX . LOCALPART)'.

`RES-NAME'
     An expanded name, a resolved version of an `UNRES-NAME'.  For an
     element or an attribute name with a non-empty namespace URI,
     `RES-NAME' is a pair of symbols, `(URI-SYMB . LOCALPART)'.
     Otherwise, it's a single symbol.

`ELEM-CONTENT-MODEL'
     A symbol:
    `ANY'
          anything goes, expect an END tag.

    `EMPTY-TAG'
          no content, and no END-tag is coming

    `EMPTY'
          no content, expect the END-tag as the next token

    `PCDATA'
          expect character data only, and no children elements

    `MIXED'

    `ELEM-CONTENT'

`URI-SYMB'
     A symbol representing a namespace URI - or other symbol chosen by
     the user to represent URI.  In the former case, `URI-SYMB' is
     created by %-quoting of bad URI characters and converting the
     resulting string into a symbol.

`NAMESPACES'
     A list representing namespaces in effect.  An element of the list
     has one of the following forms:

    `(PREFIX URI-SYMB . URI-SYMB) or'

    `(PREFIX USER-PREFIX . URI-SYMB)'
          USER-PREFIX is a symbol chosen by the user to represent the
          URI.

    `(#f USER-PREFIX . URI-SYMB)'
          Specification of the user-chosen prefix and a URI-SYMBOL.

    `(*DEFAULT* USER-PREFIX . URI-SYMB)'
          Declaration of the default namespace

    `(*DEFAULT* #f . #f)'
          Un-declaration of the default namespace.  This notation
          represents overriding of the previous declaration


     A NAMESPACES list may contain several elements for the same PREFIX.
     The one closest to the beginning of the list takes effect.

`ATTLIST'
     An ordered collection of (NAME . VALUE) pairs, where NAME is a
     RES-NAME or an UNRES-NAME.  The collection is an ADT.

`STR-HANDLER'
     A procedure of three arguments: STRING1 STRING2 SEED returning a
     new SEED.  The procedure is supposed to handle a chunk of
     character data STRING1 followed by a chunk of character data
     STRING2.  STRING2 is a short string, often `"\n"' and even `""'.

`ENTITIES'
     An assoc list of pairs:
             (NAMED-ENTITY-NAME . NAMED-ENTITY-BODY)

     where NAMED-ENTITY-NAME is a symbol under which the entity was
     declared, NAMED-ENTITY-BODY is either a string, or (for an
     external entity) a thunk that will return an input port (from which
     the entity can be read).  NAMED-ENTITY-BODY may also be #f.  This
     is an indication that a NAMED-ENTITY-NAME is currently being
     expanded.  A reference to this NAMED-ENTITY-NAME will be an error:
     violation of the WFC nonrecursion.

`XML-TOKEN'
     This record represents a markup, which is, according to the XML
     Recommendation, "takes the form of start-tags, end-tags,
     empty-element tags, entity references, character references,
     comments, CDATA section delimiters, document type declarations, and
     processing instructions."

    kind
          a TAG-KIND

    head
          an UNRES-NAME.  For XML-TOKENs of kinds 'COMMENT and 'CDSECT,
          the head is #f.

     For example,
          <P>                   => kind=START,      head=P
          </P>                  => kind=END,        head=P
          <BR/>                 => kind=EMPTY-EL,   head=BR
          <!DOCTYPE OMF ...>    => kind=DECL,       head=DOCTYPE
          <?xml version="1.0"?> => kind=PI,         head=xml
          &my-ent;              => kind=ENTITY-REF, head=my-ent

     Character references are not represented by xml-tokens as these
     references are transparently resolved into the corresponding
     characters.

`XML-DECL'
     The record represents a datatype of an XML document: the list of
     declared elements and their attributes, declared notations, list of
     replacement strings or loading procedures for parsed general
     entities, etc.  Normally an XML-DECL record is created from a DTD
     or an XML Schema, although it can be created and filled in in many
     other ways (e.g., loaded from a file).

    ELEMS
          an (assoc) list of decl-elem or #f.  The latter instructs the
          parser to do no validation of elements and attributes.

    DECL-ELEM
          declaration of one element:

          `(ELEM-NAME ELEM-CONTENT DECL-ATTRS)'

          ELEM-NAME is an UNRES-NAME for the element.

          ELEM-CONTENT is an ELEM-CONTENT-MODEL.

          DECL-ATTRS is an `ATTLIST', of `(ATTR-NAME . VALUE)'
          associations.

          This element can declare a user procedure to handle parsing
          of an element (e.g., to do a custom validation, or to build a
          hash of IDs as they're encountered).

    DECL-ATTR
          an element of an `ATTLIST', declaration of one attribute:

          `(ATTR-NAME CONTENT-TYPE USE-TYPE DEFAULT-VALUE)'

          ATTR-NAME is an UNRES-NAME for the declared attribute.

          CONTENT-TYPE is a symbol: `CDATA', `NMTOKEN', `NMTOKENS', ...
          or a list of strings for the enumerated type.

          USE-TYPE is a symbol: `REQUIRED', `IMPLIED', or `FIXED'.

          DEFAULT-VALUE is a string for the default value, or #f if not
          given.



4.11.4 Low-Level Parsers and Scanners
-------------------------------------

These procedures deal with primitive lexical units (Names, whitespaces,
tags) and with pieces of more generic productions.  Most of these
parsers must be called in appropriate context.  For example,
`ssax:complete-start-tag' must be called only when the start-tag has
been detected and its GI has been read.

 -- Function: ssax:skip-s port
     Skip the S (whitespace) production as defined by
          [3] S ::= (#x20 | #x09 | #x0D | #x0A)

     `ssax:skip-s' returns the first not-whitespace character it
     encounters while scanning the PORT.  This character is left on the
     input stream.

 -- Function: ssax:read-ncname port
     Read a NCName starting from the current position in the PORT and
     return it as a symbol.

          [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':'
                           | CombiningChar | Extender
          [5] Name ::= (Letter | '_' | ':') (NameChar)*

     This code supports the XML Namespace Recommendation REC-xml-names,
     which modifies the above productions as follows:

          [4] NCNameChar ::= Letter | Digit | '.' | '-' | '_'
                                | CombiningChar | Extender
          [5] NCName ::= (Letter | '_') (NCNameChar)*

     As the Rec-xml-names says,

          "An XML document conforms to this specification if all other
          tokens [other than element types and attribute names] in the
          document which are required, for XML conformance, to match
          the XML production for Name, match this specification's
          production for NCName."

     Element types and attribute names must match the production QName,
     defined below.

 -- Function: ssax:read-qname port
     Read a (namespace-) Qualified Name, QName, from the current
     position in PORT; and return an UNRES-NAME.

     From REC-xml-names:
          [6] QName ::= (Prefix ':')? LocalPart
          [7] Prefix ::= NCName
          [8] LocalPart ::= NCName

 -- Function: ssax:read-markup-token port
     This procedure starts parsing of a markup token.  The current
     position in the stream must be `<'.  This procedure scans enough
     of the input stream to figure out what kind of a markup token it
     is seeing.  The procedure returns an XML-TOKEN structure
     describing the token.  Note, generally reading of the current
     markup is not finished!  In particular, no attributes of the
     start-tag token are scanned.

     Here's a detailed break out of the return values and the position
     in the PORT when that particular value is returned:

    PI-token
          only PI-target is read.  To finish the Processing-Instruction
          and disregard it, call `ssax:skip-pi'.  `ssax:read-attributes'
          may be useful as well (for PIs whose content is
          attribute-value pairs).

    END-token
          The end tag is read completely; the current position is right
          after the terminating `>' character.

    COMMENT
          is read and skipped completely.  The current position is
          right after `-->' that terminates the comment.

    CDSECT
          The current position is right after `<!CDATA['.  Use
          `ssax:read-cdata-body' to read the rest.

    DECL
          We have read the keyword (the one that follows `<!')
          identifying this declaration markup.  The current position is
          after the keyword (usually a whitespace character)

    START-token
          We have read the keyword (GI) of this start tag.  No
          attributes are scanned yet.  We don't know if this tag has an
          empty content either.  Use `ssax:complete-start-tag' to
          finish parsing of the token.


 -- Function: ssax:skip-pi port
     The current position is inside a PI.  Skip till the rest of the PI

 -- Function: ssax:read-pi-body-as-string port
     The current position is right after reading the PITarget.  We read
     the body of PI and return is as a string.  The port will point to
     the character right after `?>' combination that terminates PI.

          [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'

 -- Function: ssax:skip-internal-dtd port
     The current pos in the port is inside an internal DTD subset (e.g.,
     after reading `#\[' that begins an internal DTD subset) Skip until
     the `]>' combination that terminates this DTD.

 -- Function: ssax:read-cdata-body port str-handler seed
     This procedure must be called after we have read a string
     `<![CDATA[' that begins a CDATA section.  The current position
     must be the first position of the CDATA body.  This function reads
     _lines_ of the CDATA body and passes them to a STR-HANDLER, a
     character data consumer.

     STR-HANDLER is a procedure taking arguments: STRING1, STRING2, and
     SEED.  The first STRING1 argument to STR-HANDLER never contains a
     newline; the second STRING2 argument often will.  On the first
     invocation of STR-HANDLER, SEED is the one passed to
     `ssax:read-cdata-body' as the third argument.  The result of this
     first invocation will be passed as the SEED argument to the second
     invocation of the line consumer, and so on.  The result of the
     last invocation of the STR-HANDLER is returned by the
     `ssax:read-cdata-body'.  Note a similarity to the fundamental
     "fold" iterator.

     Within a CDATA section all characters are taken at their face
     value, with three exceptions:
        * CR, LF, and CRLF are treated as line delimiters, and passed
          as a single `#\newline' to STR-HANDLER

        * `]]>' combination is the end of the CDATA section.  `&gt;' is
          treated as an embedded `>' character.

        * `&lt;' and `&amp;' are not specially recognized (and are not
          expanded)!


 -- Function: ssax:read-char-ref port
          [66]  CharRef ::=  '&#' [0-9]+ ';'
                           | '&#x' [0-9a-fA-F]+ ';'

     This procedure must be called after we we have read `&#' that
     introduces a char reference.  The procedure reads this reference
     and returns the corresponding char.  The current position in PORT
     will be after the `;' that terminates the char reference.

     Faults detected:
     WFC: XML-Spec.html#wf-Legalchar

     According to Section `4.1 Character and Entity References' of the
     XML Recommendation:

          "[Definition: A character reference refers to a specific
          character in the ISO/IEC 10646 character set, for example one
          not directly accessible from available input devices.]"


 -- Function: ssax:handle-parsed-entity port name entities
          content-handler str-handler seed
     Expands and handles a parsed-entity reference.

     NAME is a symbol, the name of the parsed entity to expand.
     CONTENT-HANDLER is a procedure of arguments PORT, ENTITIES, and
     SEED that returns a seed.  STR-HANDLER is called if the entity in
     question is a pre-declared entity.

     `ssax:handle-parsed-entity' returns the result returned by
     CONTENT-HANDLER or STR-HANDLER.

     Faults detected:
     WFC: XML-Spec.html#wf-entdeclared
     WFC: XML-Spec.html#norecursion

 -- Function: attlist-add attlist name-value
     Add a NAME-VALUE pair to the existing ATTLIST, preserving its
     sorted ascending order; and return the new list.  Return #f if a
     pair with the same name already exists in ATTLIST

 -- Function: attlist-remove-top attlist
     Given an non-null ATTLIST, return a pair of values: the top and
     the rest.

 -- Function: ssax:read-attributes port entities
     This procedure reads and parses a production "Attribute".  

          [41] Attribute ::= Name Eq AttValue
          [10] AttValue ::=  '"' ([^<&"] | Reference)* '"'
                          | "'" ([^<&'] | Reference)* "'"
          [25] Eq ::= S? '=' S?

     The procedure returns an ATTLIST, of Name (as UNRES-NAME), Value
     (as string) pairs.  The current character on the PORT is a
     non-whitespace character that is not an NCName-starting character.

     Note the following rules to keep in mind when reading an
     "AttValue": 

          Before the value of an attribute is passed to the application
          or checked for validity, the XML processor must normalize it
          as follows:

             * A character reference is processed by appending the
               referenced character to the attribute value.

             * An entity reference is processed by recursively
               processing the replacement text of the entity.  The
               named entities `amp', `lt', `gt', `quot', and `apos' are
               pre-declared.

             * A whitespace character (#x20, #x0D, #x0A, #x09) is
               processed by appending #x20 to the normalized value,
               except that only a single #x20 is appended for a
               "#x0D#x0A" sequence that is part of an external parsed
               entity or the literal entity value of an internal parsed
               entity.

             * Other characters are processed by appending them to the
               normalized value.



     Faults detected:
     WFC: XML-Spec.html#CleanAttrVals
     WFC: XML-Spec.html#uniqattspec

 -- Function: ssax:resolve-name port unres-name namespaces
          apply-default-ns?
     Convert an UNRES-NAME to a RES-NAME, given the appropriate
     NAMESPACES declarations.  The last parameter, APPLY-DEFAULT-NS?,
     determines if the default namespace applies (for instance, it does
     not for attribute names).

     Per REC-xml-names/#nsc-NSDeclared, the "xml" prefix is considered
     pre-declared and bound to the namespace name
     "http://www.w3.org/XML/1998/namespace".

     `ssax:resolve-name' tests for the namespace constraints:
     `http://www.w3.org/TR/REC-xml-names/#nsc-NSDeclared'

 -- Function: ssax:complete-start-tag tag port elems entities namespaces
     Complete parsing of a start-tag markup.  `ssax:complete-start-tag'
     must be called after the start tag token has been read.  TAG is an
     UNRES-NAME.  ELEMS is an instance of the ELEMS slot of XML-DECL;
     it can be #f to tell the function to do _no_ validation of
     elements and their attributes.

     `ssax:complete-start-tag' returns several values:
        * ELEM-GI: a RES-NAME.

        * ATTRIBUTES: element's attributes, an ATTLIST of (RES-NAME .
          STRING) pairs.  The list does NOT include xmlns attributes.

        * NAMESPACES: the input list of namespaces amended with
          namespace (re-)declarations contained within the start-tag
          under parsing

        * ELEM-CONTENT-MODEL

     On exit, the current position in PORT will be the first character
     after `>' that terminates the start-tag markup.

     Faults detected:
     VC: XML-Spec.html#enum
     VC: XML-Spec.html#RequiredAttr
     VC: XML-Spec.html#FixedAttr
     VC: XML-Spec.html#ValueType
     WFC: XML-Spec.html#uniqattspec (after namespaces prefixes are
     resolved)
     VC: XML-Spec.html#elementvalid
     WFC: REC-xml-names/#dt-NSName

     _Note_: although XML Recommendation does not explicitly say it,
     xmlns and xmlns: attributes don't have to be declared (although
     they can be declared, to specify their default value).

 -- Function: ssax:read-external-id port
     Parses an ExternalID production:

          [75] ExternalID ::= 'SYSTEM' S SystemLiteral
                            | 'PUBLIC' S PubidLiteral S SystemLiteral
          [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")
          [12] PubidLiteral ::=  '"' PubidChar* '"'
                               | "'" (PubidChar - "'")* "'"
          [13] PubidChar ::=  #x20 | #x0D | #x0A | [a-zA-Z0-9]
                                   | [-'()+,./:=?;!*#@$_%]

     Call `ssax:read-external-id' when an ExternalID is expected; that
     is, the current character must be either #\S or #\P that starts
     correspondingly a SYSTEM or PUBLIC token.  `ssax:read-external-id'
     returns the SYSTEMLITERAL as a string.  A PUBIDLITERAL is
     disregarded if present.

4.11.5 Mid-Level Parsers and Scanners
-------------------------------------

These procedures parse productions corresponding to the whole
(document) entity or its higher-level pieces (prolog, root element,
etc).

 -- Function: ssax:scan-misc port
     Scan the Misc production in the context:

          [1]  document ::=  prolog element Misc*
          [22] prolog ::= XMLDecl? Misc* (doctypedec l Misc*)?
          [27] Misc ::= Comment | PI |  S

     Call `ssax:scan-misc' in the prolog or epilog contexts.  In these
     contexts, whitespaces are completely ignored.  The return value
     from `ssax:scan-misc' is either a PI-token, a DECL-token, a START
     token, or *EOF*.  Comments are ignored and not reported.

 -- Function: ssax:read-char-data port expect-eof? str-handler iseed
     Read the character content of an XML document or an XML element.

          [43] content ::=
          (element | CharData | Reference | CDSect | PI | Comment)*

     To be more precise, `ssax:read-char-data' reads CharData, expands
     CDSect and character entities, and skips comments.
     `ssax:read-char-data' stops at a named reference, EOF, at the
     beginning of a PI, or a start/end tag.

     EXPECT-EOF? is a boolean indicating if EOF is normal; i.e., the
     character data may be terminated by the EOF.  EOF is normal while
     processing a parsed entity.

     ISEED is an argument passed to the first invocation of STR-HANDLER.

     `ssax:read-char-data' returns two results: SEED and TOKEN.  The
     SEED is the result of the last invocation of STR-HANDLER, or the
     original ISEED if STR-HANDLER was never called.

     TOKEN can be either an eof-object (this can happen only if
     EXPECT-EOF?  was #t), or:
        * an xml-token describing a START tag or an END-tag; For a
          start token, the caller has to finish reading it.

        * an xml-token describing the beginning of a PI.  It's up to an
          application to read or skip through the rest of this PI;

        * an xml-token describing a named entity reference.


     CDATA sections and character references are expanded inline and
     never returned.  Comments are silently disregarded.

     As the XML Recommendation requires, all whitespace in character
     data must be preserved.  However, a CR character (#x0D) must be
     disregarded if it appears before a LF character (#x0A), or replaced
     by a #x0A character otherwise.  See Secs. 2.10 and 2.11 of the XML
     Recommendation.  See also the canonical XML Recommendation.

 -- Function: ssax:assert-token token kind gi error-cont
     Make sure that TOKEN is of anticipated KIND and has anticipated
     GI.  Note that the GI argument may actually be a pair of two
     symbols, Namespace-URI or the prefix, and of the localname.  If
     the assertion fails, ERROR-CONT is evaluated by passing it three
     arguments: TOKEN KIND GI.  The result of ERROR-CONT is returned.

4.11.6 High-level Parsers
-------------------------

These procedures are to instantiate a SSAX parser.  A user can
instantiate the parser to do the full validation, or no validation, or
any particular validation.  The user specifies which PI he wants to be
notified about.  The user tells what to do with the parsed character
and element data.  The latter handlers determine if the parsing follows
a SAX or a DOM model.

 -- Function: ssax:make-pi-parser my-pi-handlers
     Create a parser to parse and process one Processing Element (PI).

     MY-PI-HANDLERS is an association list of pairs `(PI-TAG .
     PI-HANDLER)' where PI-TAG is an NCName symbol, the PI target; and
     PI-HANDLER is a procedure taking arguments PORT, PI-TAG, and SEED.

     PI-HANDLER should read the rest of the PI up to and including the
     combination `?>' that terminates the PI.  The handler should
     return a new seed.  One of the PI-TAGs may be the symbol
     `*DEFAULT*'.  The corresponding handler will handle PIs that no
     other handler will.  If the *DEFAULT* PI-TAG is not specified,
     `ssax:make-pi-parser' will assume the default handler that skips
     the body of the PI.

     `ssax:make-pi-parser' returns a procedure of arguments PORT,
     PI-TAG, and SEED; that will parse the current PI according to
     MY-PI-HANDLERS.

 -- Function: ssax:make-elem-parser my-new-level-seed my-finish-element
          my-char-data-handler my-pi-handlers
     Create a parser to parse and process one element, including its
     character content or children elements.  The parser is typically
     applied to the root element of a document.

    MY-NEW-LEVEL-SEED
          is a procedure taking arguments:

          ELEM-GI ATTRIBUTES NAMESPACES EXPECTED-CONTENT SEED

          where ELEM-GI is a RES-NAME of the element about to be
          processed.

          MY-NEW-LEVEL-SEED is to generate the seed to be passed to
          handlers that process the content of the element.

    MY-FINISH-ELEMENT
          is a procedure taking arguments:

          ELEM-GI ATTRIBUTES NAMESPACES PARENT-SEED SEED

          MY-FINISH-ELEMENT is called when parsing of ELEM-GI is
          finished.  The SEED is the result from the last content
          parser (or from MY-NEW-LEVEL-SEED if the element has the
          empty content).  PARENT-SEED is the same seed as was passed
          to MY-NEW-LEVEL-SEED.  MY-FINISH-ELEMENT is to generate a
          seed that will be the result of the element parser.

    MY-CHAR-DATA-HANDLER
          is a STR-HANDLER as described in Data Types above.

    MY-PI-HANDLERS
          is as described for `ssax:make-pi-handler' above.


     The generated parser is a procedure taking arguments:

     START-TAG-HEAD PORT ELEMS ENTITIES NAMESPACES PRESERVE-WS? SEED

     The procedure must be called after the start tag token has been
     read.  START-TAG-HEAD is an UNRES-NAME from the start-element tag.
     ELEMS is an instance of ELEMS slot of XML-DECL.

     Faults detected:
     VC: XML-Spec.html#elementvalid
     WFC: XML-Spec.html#GIMatch

 -- Function: ssax:make-parser user-handler-tag user-handler ...
     Create an XML parser, an instance of the XML parsing framework.
     This will be a SAX, a DOM, or a specialized parser depending on the
     supplied user-handlers.

     `ssax:make-parser' takes an even number of arguments;
     USER-HANDLER-TAG is a symbol that identifies a procedure (or
     association list for `PROCESSING-INSTRUCTIONS') (USER-HANDLER)
     that follows the tag.  Given below are tags and signatures of the
     corresponding procedures.  Not all tags have to be specified.  If
     some are omitted, reasonable defaults will apply.

    `DOCTYPE'
          handler-procedure: PORT DOCNAME SYSTEMID INTERNAL-SUBSET? SEED

          If INTERNAL-SUBSET? is #t, the current position in the port is
          right after we have read `[' that begins the internal DTD
          subset.  We must finish reading of this subset before we
          return (or must call `skip-internal-dtd' if we aren't
          interested in reading it).  PORT at exit must be at the first
          symbol after the whole DOCTYPE declaration.

          The handler-procedure must generate four values:

               ELEMS ENTITIES NAMESPACES SEED

          ELEMS is as defined for the ELEMS slot of XML-DECL.  It may be
          #f to switch off validation.  NAMESPACES will typically
          contain USER-PREFIXes for selected URI-SYMBs.  The default
          handler-procedure skips the internal subset, if any, and
          returns `(values #f '() '() seed)'.

    `UNDECL-ROOT'
          procedure: ELEM-GI SEED

          where ELEM-GI is an UNRES-NAME of the root element.  This
          procedure is called when an XML document under parsing
          contains _no_ DOCTYPE declaration.

          The handler-procedure, as a DOCTYPE handler procedure above,
          must generate four values:

               ELEMS ENTITIES NAMESPACES SEED

          The default handler-procedure returns (values #f '() '() seed)

    `DECL-ROOT'
          procedure: ELEM-GI SEED

          where ELEM-GI is an UNRES-NAME of the root element.  This
          procedure is called when an XML document under parsing does
          contains the DOCTYPE declaration.  The handler-procedure must
          generate a new SEED (and verify that the name of the root
          element matches the doctype, if the handler so wishes).  The
          default handler-procedure is the identity function.

    `NEW-LEVEL-SEED'
          procedure: see ssax:make-elem-parser, my-new-level-seed

    `FINISH-ELEMENT'
          procedure: see ssax:make-elem-parser, my-finish-element

    `CHAR-DATA-HANDLER'
          procedure: see ssax:make-elem-parser, my-char-data-handler

    `PROCESSING-INSTRUCTIONS'
          association list as is passed to `ssax:make-pi-parser'.  The
          default value is '()


     The generated parser is a procedure of arguments PORT and SEED.

     This procedure parses the document prolog and then exits to an
     element parser (created by `ssax:make-elem-parser') to handle the
     rest.

          [1]  document ::=  prolog element Misc*
          [22] prolog ::= XMLDecl? Misc* (doctypedec | Misc*)?
          [27] Misc ::= Comment | PI |  S
          [28] doctypedecl ::=  '<!DOCTYPE' S Name (S ExternalID)? S?
                        ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
          [29] markupdecl ::= elementdecl | AttlistDecl
                               | EntityDecl
                               | NotationDecl | PI
                               | Comment

4.11.7 Parsing XML to SXML
--------------------------

 -- Function: ssax:xml->sxml port namespace-prefix-assig
     This is an instance of the SSAX parser that returns an SXML
     representation of the XML document to be read from PORT.
     NAMESPACE-PREFIX-ASSIG is a list of `(USER-PREFIX . URI-STRING)'
     that assigns USER-PREFIXes to certain namespaces identified by
     particular URI-STRINGs.  It may be an empty list.
     `ssax:xml->sxml' returns an SXML tree.  The port points out to the
     first character after the root element.


File: slib-3b5.info,  Node: Printing Scheme,  Next: Time and Date,  Prev: Parsing XML,  Up: Textual Conversion Packages
                                                                              |
4.12 Printing Scheme
====================

* Menu:

* Generic-Write::               'generic-write
* Object-To-String::            'object->string
* Pretty-Print::                'pretty-print, 'pprint-file


File: slib-3b5.info,  Node: Generic-Write,  Next: Object-To-String,  Prev: Printing Scheme,  Up: Printing Scheme
                                                                              |
4.12.1 Generic-Write
--------------------

`(require 'generic-write)' 

  `generic-write' is a procedure that transforms a Scheme data value
(or Scheme program expression) into its textual representation and
prints it.  The interface to the procedure is sufficiently general to
easily implement other useful formatting procedures such as pretty
printing, output to a string and truncated output.

 -- Procedure: generic-write obj display? width output
    OBJ
          Scheme data value to transform.

    DISPLAY?
          Boolean, controls whether characters and strings are quoted.

    WIDTH
          Extended boolean, selects format:
         #f
               single line format

         integer > 0
               pretty-print (value = max nb of chars per line)

    OUTPUT
          Procedure of 1 argument of string type, called repeatedly with
          successive substrings of the textual representation.  This
          procedure can return `#f' to stop the transformation.

     The value returned by `generic-write' is undefined.

     Examples:
          (write obj) == (generic-write obj #f #f DISPLAY-STRING)
          (display obj) == (generic-write obj #t #f DISPLAY-STRING)
     where
          DISPLAY-STRING ==
          (lambda (s) (for-each write-char (string->list s)) #t)


File: slib-3b5.info,  Node: Object-To-String,  Next: Pretty-Print,  Prev: Generic-Write,  Up: Printing Scheme
                                                                              |
4.12.2 Object-To-String
-----------------------

`(require 'object->string)' 

 -- Function: object->string obj
     Returns the textual representation of OBJ as a string.

 -- Function: object->limited-string obj limit
     Returns the textual representation of OBJ as a string of length at
     most LIMIT.


File: slib-3b5.info,  Node: Pretty-Print,  Prev: Object-To-String,  Up: Printing Scheme
                                                                              |
4.12.3 Pretty-Print
-------------------

`(require 'pretty-print)' 

 -- Procedure: pretty-print obj
 -- Procedure: pretty-print obj port
     `pretty-print's OBJ on PORT.  If PORT is not specified,
     `current-output-port' is used.

     Example:
          (pretty-print '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                          (16 17 18 19 20) (21 22 23 24 25)))
             -| ((1 2 3 4 5)
             -|  (6 7 8 9 10)
             -|  (11 12 13 14 15)
             -|  (16 17 18 19 20)
             -|  (21 22 23 24 25))

 -- Procedure: pretty-print->string obj
 -- Procedure: pretty-print->string obj width
     Returns the string of OBJ `pretty-print'ed in WIDTH columns.  If
     WIDTH is not specified, `(output-port-width)' is used.

     Example:
          (pretty-print->string '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                                  (16 17 18 19 20) (21 22 23 24 25)))
          =>
          "((1 2 3 4 5)
           (6 7 8 9 10)
           (11 12 13 14 15)
           (16 17 18 19 20)
           (21 22 23 24 25))
          "
          (pretty-print->string '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                                  (16 17 18 19 20) (21 22 23 24 25))
                                16)
          =>
          "((1 2 3 4 5)
           (6 7 8 9 10)
           (11
            12
            13
            14
            15)
           (16
            17
            18
            19
            20)
           (21
            22
            23
            24
            25))
          "

  `(require 'pprint-file)' 

 -- Procedure: pprint-file infile
 -- Procedure: pprint-file infile outfile
     Pretty-prints all the code in INFILE.  If OUTFILE is specified,
     the output goes to OUTFILE, otherwise it goes to
     `(current-output-port)'.

 -- Function: pprint-filter-file infile proc outfile
 -- Function: pprint-filter-file infile proc
     INFILE is a port or a string naming an existing file.  Scheme
     source code expressions and definitions are read from the port (or
     file) and PROC is applied to them sequentially.

     OUTFILE is a port or a string.  If no OUTFILE is specified then
     `current-output-port' is assumed.  These expanded expressions are
     then `pretty-print'ed to this port.

     Whitepsace and comments (introduced by `;') which are not part of
     scheme expressions are reproduced in the output.  This procedure
     does not affect the values returned by `current-input-port',
     `current-error-port', and `current-output-port'.

  `pprint-filter-file' can be used to pre-compile macro-expansion and
thus can reduce loading time.  The following will write into
`exp-code.scm' the result of expanding all defmacros in `code.scm'.
     (require 'pprint-file)
     (require 'defmacroexpand)
     (defmacro:load "my-macros.scm")
     (pprint-filter-file "code.scm" defmacro:expand* "exp-code.scm")


File: slib-3b5.info,  Node: Time and Date,  Next: NCBI-DNA,  Prev: Printing Scheme,  Up: Textual Conversion Packages
                                                                              |
4.13 Time and Date
==================

* Menu:

* Time Zone::
* Posix Time::                  'posix-time
* Common-Lisp Time::            'common-lisp-time
* Time Infrastructure::

If `(provided? 'current-time)':

The procedures `current-time', `difftime', and `offset-time' deal with
a "calendar time" datatype which may or may not be disjoint from other
Scheme datatypes.

 -- Function: current-time
     Returns the time since 00:00:00 GMT, January 1, 1970, measured in
     seconds.  Note that the reference time is different from the
     reference time for `get-universal-time' in *note Common-Lisp
     Time::.

 -- Function: difftime caltime1 caltime0
     Returns the difference (number of seconds) between twe calendar
     times: CALTIME1 - CALTIME0.  CALTIME0 may also be a number.

 -- Function: offset-time caltime offset
     Returns the calendar time of CALTIME offset by OFFSET number of
     seconds `(+ caltime offset)'.


File: slib-3b5.info,  Node: Time Zone,  Next: Posix Time,  Prev: Time and Date,  Up: Time and Date
                                                                              |
4.13.1 Time Zone
----------------

(require 'time-zone)

 -- Data Format: TZ-string
     POSIX standards specify several formats for encoding time-zone
     rules.

    :<pathname>
          If the first character of <pathname> is `/', then <pathname>
          specifies the absolute pathname of a tzfile(5) format
          time-zone file.  Otherwise, <pathname> is interpreted as a
          pathname within TZFILE:VICINITY (/usr/lib/zoneinfo/) naming a
          tzfile(5) format time-zone file.

    <std><offset>
          The string <std> consists of 3 or more alphabetic characters.
          <offset> specifies the time difference from GMT.  The <offset>
          is positive if the local time zone is west of the Prime
          Meridian and negative if it is east.  <offset> can be the
          number of hours or hours and minutes (and optionally seconds)
          separated by `:'.  For example, `-4:30'.

    <std><offset><dst>
          <dst> is the at least 3 alphabetic characters naming the local
          daylight-savings-time.

    <std><offset><dst><doffset>
          <doffset> specifies the offset from the Prime Meridian when
          daylight-savings-time is in effect.

     The non-tzfile formats can optionally be followed by transition
     times specifying the day and time when a zone changes from
     standard to daylight-savings and back again.

    ,<date>/<time>,<date>/<time>
          The <time>s are specified like the <offset>s above, except
          that leading `+' and `-' are not allowed.

          Each <date> has one of the formats:

         J<day>
               specifies the Julian day with <day> between 1 and 365.
               February 29 is never counted and cannot be referenced.

         <day>
               This specifies the Julian day with n between 0 and 365.
               February 29 is counted in leap years and can be
               specified.

         M<month>.<week>.<day>
               This specifies day <day> (0 <= <day> <= 6) of week
               <week> (1 <= <week> <= 5) of month <month> (1 <= <month>
               <= 12).  Week 1 is the first week in which day d occurs
               and week 5 is the last week in which day <day> occurs.
               Day 0 is a Sunday.


 -- Data Type: time-zone
     is a datatype encoding how many hours from Greenwich Mean Time the
     local time is, and the "Daylight Savings Time" rules for changing
     it.

 -- Function: time-zone TZ-string
     Creates and returns a time-zone object specified by the string
     TZ-STRING.  If `time-zone' cannot interpret TZ-STRING, `#f' is
     returned.

 -- Function: tz:params caltime tz
     TZ is a time-zone object.  `tz:params' returns a list of three
     items:
       0. An integer.  0 if standard time is in effect for timezone TZ
          at CALTIME; 1 if daylight savings time is in effect for
          timezone TZ at CALTIME.

       1. The number of seconds west of the Prime Meridian timezone TZ
          is at CALTIME.

       2. The name for timezone TZ at CALTIME.

     `tz:params' is unaffected by the default timezone; inquiries can be
     made of any timezone at any calendar time.


 -- Function: tz:std-offset tz
     TZ is a time-zone object.  `tz:std-offset' returns the number of
     seconds west of the Prime Meridian timezone TZ is.


The rest of these procedures and variables are provided for POSIX
compatability.  Because of shared state they are not thread-safe.

 -- Function: tzset
     Returns the default time-zone.

 -- Function: tzset tz
     Sets (and returns) the default time-zone to TZ.

 -- Function: tzset TZ-string
     Sets (and returns) the default time-zone to that specified by
     TZ-STRING.

     `tzset' also sets the variables *TIMEZONE*, DAYLIGHT?, and TZNAME.
     This function is automatically called by the time conversion
     procedures which depend on the time zone (*note Time and Date::).

 -- Variable: *timezone*
     Contains the difference, in seconds, between Greenwich Mean Time
     and local standard time (for example, in the U.S.  Eastern time
     zone (EST), timezone is 5*60*60).  `*timezone*' is initialized by
     `tzset'.

 -- Variable: daylight?
     is `#t' if the default timezone has rules for "Daylight Savings
     Time".  _Note:_ DAYLIGHT? does not tell you when Daylight Savings
     Time is in effect, just that the default zone sometimes has
     Daylight Savings Time.

 -- Variable: tzname
     is a vector of strings.  Index 0 has the abbreviation for the
     standard timezone; If DAYLIGHT?, then index 1 has the abbreviation
     for the Daylight Savings timezone.


File: slib-3b5.info,  Node: Posix Time,  Next: Common-Lisp Time,  Prev: Time Zone,  Up: Time and Date
                                                                              |
4.13.2 Posix Time
-----------------

     (require 'posix-time)
     

 -- Data Type: Calendar-Time
     is a datatype encapsulating time.

 -- Data Type: Coordinated Universal Time
     (abbreviated "UTC") is a vector of integers representing time:

       0.  seconds (0 - 61)

       1.  minutes (0 - 59)

       2.  hours since midnight (0 - 23)

       3.  day of month (1 - 31)

       4.  month (0 - 11).  Note difference from
          `decode-universal-time'.

       5.  the number of years since 1900.  Note difference from
          `decode-universal-time'.

       6.  day of week (0 - 6)

       7.  day of year (0 - 365)

       8.  1 for daylight savings, 0 for regular time

 -- Function: gmtime caltime
     Converts the calendar time CALTIME to UTC and returns it.

 -- Function: localtime caltime tz
     Returns CALTIME converted to UTC relative to timezone TZ.

 -- Function: localtime caltime
     converts the calendar time CALTIME to a vector of integers
     expressed relative to the user's time zone.  `localtime' sets the
     variable *TIMEZONE* with the difference between Coordinated
     Universal Time (UTC) and local standard time in seconds (*note
     tzset: Time Zone.).


 -- Function: gmktime univtime
     Converts a vector of integers in GMT Coordinated Universal Time
     (UTC) format to a calendar time.

 -- Function: mktime univtime
     Converts a vector of integers in local Coordinated Universal Time
     (UTC) format to a calendar time.

 -- Function: mktime univtime tz
     Converts a vector of integers in Coordinated Universal Time (UTC)
     format (relative to time-zone TZ) to calendar time.

 -- Function: asctime univtime
     Converts the vector of integers CALTIME in Coordinated Universal
     Time (UTC) format into a string of the form `"Wed Jun 30 21:49:08
     1993"'.

 -- Function: gtime caltime
 -- Function: ctime caltime
 -- Function: ctime caltime tz
     Equivalent to `(asctime (gmtime CALTIME))', `(asctime (localtime
     CALTIME))', and `(asctime (localtime CALTIME TZ))', respectively.


File: slib-3b5.info,  Node: Common-Lisp Time,  Next: Time Infrastructure,  Prev: Posix Time,  Up: Time and Date
                                                                              |
4.13.3 Common-Lisp Time
-----------------------

 -- Function: get-decoded-time
     Equivalent to `(decode-universal-time (get-universal-time))'.

 -- Function: get-universal-time
     Returns the current time as "Universal Time", number of seconds
     since 00:00:00 Jan 1, 1900 GMT.  Note that the reference time is
     different from `current-time'.

 -- Function: decode-universal-time univtime
     Converts UNIVTIME to "Decoded Time" format.  Nine values are
     returned:
       0.  seconds (0 - 61)

       1.  minutes (0 - 59)

       2.  hours since midnight

       3.  day of month

       4.  month (1 - 12).  Note difference from `gmtime' and
          `localtime'.

       5.  year (A.D.).  Note difference from `gmtime' and `localtime'.

       6.  day of week (0 - 6)

       7.  #t for daylight savings, #f otherwise

       8.  hours west of GMT (-24 - +24)

     Notice that the values returned by `decode-universal-time' do not
     match the arguments to `encode-universal-time'.

 -- Function: encode-universal-time second minute hour date month year
 -- Function: encode-universal-time second minute hour date month year
          time-zone
     Converts the arguments in Decoded Time format to Universal Time
     format.  If TIME-ZONE is not specified, the returned time is
     adjusted for daylight saving time.  Otherwise, no adjustment is
     performed.

     Notice that the values returned by `decode-universal-time' do not
     match the arguments to `encode-universal-time'.


File: slib-3b5.info,  Node: Time Infrastructure,  Prev: Common-Lisp Time,  Up: Time and Date
                                                                              |
4.13.4 Time Infrastructure
--------------------------

`(require 'time-core)'

 -- Function: time:gmtime tm
 -- Function: time:invert decoder target
 -- Function: time:split t tm_isdst tm_gmtoff tm_zone

  `(require 'tzfile)'

 -- Function: tzfile:read path


File: slib-3b5.info,  Node: NCBI-DNA,  Next: Schmooz,  Prev: Time and Date,  Up: Textual Conversion Packages
                                                                              |
4.14 NCBI-DNA
=============

`(require 'ncbi-dma)' 

 -- Function: ncbi:read-dna-sequence port
     Reads the NCBI-format DNA sequence following the word `ORIGIN'
     from PORT.

 -- Function: ncbi:read-file file
     Reads the NCBI-format DNA sequence following the word `ORIGIN'
     from FILE.

 -- Function: mrna<-cdna str
     Replaces `T' with `U' in STR

 -- Function: codons<-cdna cdna
     Returns a list of three-letter symbol codons comprising the protein
     sequence encoded by CDNA starting with its first occurence of
     `atg'.

 -- Function: protein<-cdna cdna
     Returns a list of three-letter symbols for the protein sequence
     encoded by CDNA starting with its first occurence of `atg'.

 -- Function: p<-cdna cdna
     Returns a string of one-letter amino acid codes for the protein
     sequence encoded by CDNA starting with its first occurence of
     `atg'.

  These cDNA count routines provide a means to check the nucleotide
sequence with the `BASE COUNT' line preceding the sequence from NCBI.

 -- Function: cdna:base-count cdna
     Returns a list of counts of `a', `c', `g', and `t' occurrencing in
     CDNA.

 -- Function: cdna:report-base-count cdna
     Prints the counts of `a', `c', `g', and `t' occurrencing in CDNA.


File: slib-3b5.info,  Node: Schmooz,  Prev: NCBI-DNA,  Up: Textual Conversion Packages
                                                                              |
4.15 Schmooz
============

"Schmooz" is a simple, lightweight markup language for interspersing
Texinfo documentation with Scheme source code.  Schmooz does not create
the top level Texinfo file; it creates `txi' files which can be
imported into the documentation using the Texinfo command `@include'.

  `(require 'schmooz)' defines the function `schmooz', which is used to
process files.  Files containing schmooz documentation should not
contain `(require 'schmooz)'.

 -- Procedure: schmooz filename.scm ...
     FILENAME.scm should be a string ending with `.scm' naming an
     existing file containing Scheme source code.  `schmooz' extracts
     top-level comments containing schmooz commands from FILENAME.scm
     and writes the converted Texinfo source to a file named
     FILENAME.txi.

 -- Procedure: schmooz filename.texi ...
 -- Procedure: schmooz filename.tex ...
 -- Procedure: schmooz filename.txi ...
     FILENAME should be a string naming an existing file containing
     Texinfo source code.  For every occurrence of the string `@include
     FILENAME.txi' within that file, `schmooz' calls itself with the
     argument `FILENAME.scm'.

  Schmooz comments are distinguished (from non-schmooz comments) by
their first line, which must start with an at-sign (@) preceded by one
or more semicolons (;).  A schmooz comment ends at the first subsequent
line which does _not_ start with a semicolon.  Currently schmooz
comments are recognized only at top level.

  Schmooz comments are copied to the Texinfo output file with the
leading contiguous semicolons removed.  Certain character sequences
starting with at-sign are treated specially.  Others are copied
unchanged.

  A schmooz comment starting with `@body' must be followed by a Scheme
definition.  All comments between the `@body' line and the definition
will be included in a Texinfo definition, either a `@defun' or a
`@defvar', depending on whether a procedure or a variable is being
defined.

  Within the text of that schmooz comment, at-sign followed by `0' will
be replaced by `@code{procedure-name}' if the following definition is
of a procedure; or `@var{variable}' if defining a variable.

  An at-sign followed by a non-zero digit will expand to the variable
citation of that numbered argument: `@var{argument-name}'.

  If more than one definition follows a `@body' comment line without an
intervening blank or comment line, then those definitions will be
included in the same Texinfo definition using `@defvarx' or `@defunx',
depending on whether the first definition is of a variable or of a
procedure.

  Schmooz can figure out whether a definition is of a procedure if it
is of the form:

  `(define (<identifier> <arg> ...) <expression>)'

or if the left hand side of the definition is some form ending in a
lambda expression.  Obviously, it can be fooled.  In order to force
recognition of a procedure definition, start the documentation with
`@args' instead of `@body'.  `@args' should be followed by the argument
list of the function being defined, which may be enclosed in
parentheses and delimited by whitespace, (as in Scheme), enclosed in
braces and separated by commas, (as in Texinfo), or consist of the
remainder of the line, separated by whitespace.

  For example:

     ;;@args arg1 args ...
     ;;@0 takes argument @1 and any number of @2
     (define myfun (some-function-returning-magic))

  Will result in:

     @defun myfun arg1 args @dots{}

     @code{myfun} takes argument @var{arg1} and any number of @var{args}
     @end defun

  `@args' may also be useful for indicating optional arguments by name.
If `@args' occurs inside a schmooz comment section, rather than at the
beginning, then it will generate a `@defunx' line with the arguments
supplied.

  If the first at-sign in a schmooz comment is immediately followed by
whitespace, then the comment will be expanded to whatever follows that
whitespace.  If the at-sign is followed by a non-whitespace character
then the at-sign will be included as the first character of the
expansion.  This feature is intended to make it easy to include Texinfo
directives in schmooz comments.


File: slib-3b5.info,  Node: Mathematical Packages,  Next: Database Packages,  Prev: Textual Conversion Packages,  Up: Top
                                                                              |
5 Mathematical Packages
***********************

* Menu:

* Bit-Twiddling::               'logical
* Modular Arithmetic::          'modular
* Irrational Integer Functions::
* Irrational Real Functions::
* Prime Numbers::               'factor
* Random Numbers::              'random
* Discrete Fourier Transform::  'dft
* Cyclic Checksum::             'crc
* Graphing::
* Solid Modeling::              VRML97
* Color::
* Root Finding::                'root
* Minimizing::                  'minimize
* The Limit::                   'limit
* Commutative Rings::           'commutative-ring
* Matrix Algebra::              'determinant


File: slib-3b5.info,  Node: Bit-Twiddling,  Next: Modular Arithmetic,  Prev: Mathematical Packages,  Up: Mathematical Packages
                                                                              |
5.1 Bit-Twiddling
=================

`(require 'logical)' or `(require 'srfi-60)' 

The bit-twiddling functions are made available through the use of the
`logical' package.  `logical' is loaded by inserting `(require
'logical)' before the code that uses these functions.  These functions
behave as though operating on integers in two's-complement
representation.

5.1.1 Bitwise Operations
------------------------

 -- Function: logand n1 ...
 -- Function: bitwise-and n1 ...
     Returns the integer which is the bit-wise AND of the integer
     arguments.

     Example:
          (number->string (logand #b1100 #b1010) 2)
             => "1000"

 -- Function: logior n1 ...
 -- Function: bitwise-ior n1 ...
     Returns the integer which is the bit-wise OR of the integer
     arguments.

     Example:
          (number->string (logior #b1100 #b1010) 2)
             => "1110"

 -- Function: logxor n1 ...
 -- Function: bitwise-xor n1 ...
     Returns the integer which is the bit-wise XOR of the integer
     arguments.

     Example:
          (number->string (logxor #b1100 #b1010) 2)
             => "110"

 -- Function: lognot n
 -- Function: bitwise-not n
     Returns the integer which is the one's-complement of the integer
     argument.

     Example:
          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

 -- Function: bitwise-if mask n0 n1
 -- Function: bitwise-merge mask n0 n1
     Returns an integer composed of some bits from integer N0 and some
     from integer N1.  A bit of the result is taken from N0 if the
     corresponding bit of integer MASK is 1 and from N1 if that bit of
     MASK is 0.

 -- Function: logtest j k
 -- Function: any-bits-set? j k
          (logtest j k) == (not (zero? (logand j k)))

          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

5.1.2 Integer Properties
------------------------

 -- Function: logcount n
     Returns the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If negative,
     the 0-bits in its two's-complement binary representation are
     counted.  If 0, 0 is returned.

     Example:
          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

On `discuss@r6rs.org' Ben Harris credits Simon Tatham with the idea to
have `bitwise-bit-count' return a negative count for negative inputs.
Alan Bawden came up with the succinct invariant.

 -- Function: bitwise-bit-count n
     If N is non-negative, this procedure returns the number of 1 bits
     in the two's-complement representation of N.  Otherwise it returns
     the result of the following computation:

          (bitwise-not (bitwise-bit-count (bitwise-not N)))

 -- Function: integer-length n
     Returns the number of bits neccessary to represent N.

     Example:
          (integer-length #b10101010)
             => 8
          (integer-length 0)
             => 0
          (integer-length #b1111)
             => 4

 -- Function: log2-binary-factors n
 -- Function: first-set-bit n
     Returns the number of factors of two of integer N.  This value is
     also the bit-index of the least-significant `1' bit in N.

          (require 'printf)
          (do ((idx 0 (+ 1 idx)))
                ((> idx 16))
              (printf "%s(%3d) ==> %-5d %s(%2d) ==> %-5d\n"
                      'log2-binary-factors
                      (- idx) (log2-binary-factors (- idx))
                      'log2-binary-factors
                      idx (log2-binary-factors idx)))
          -|
          log2-binary-factors(  0) ==> -1    log2-binary-factors( 0) ==> -1
          log2-binary-factors( -1) ==> 0     log2-binary-factors( 1) ==> 0
          log2-binary-factors( -2) ==> 1     log2-binary-factors( 2) ==> 1
          log2-binary-factors( -3) ==> 0     log2-binary-factors( 3) ==> 0
          log2-binary-factors( -4) ==> 2     log2-binary-factors( 4) ==> 2
          log2-binary-factors( -5) ==> 0     log2-binary-factors( 5) ==> 0
          log2-binary-factors( -6) ==> 1     log2-binary-factors( 6) ==> 1
          log2-binary-factors( -7) ==> 0     log2-binary-factors( 7) ==> 0
          log2-binary-factors( -8) ==> 3     log2-binary-factors( 8) ==> 3
          log2-binary-factors( -9) ==> 0     log2-binary-factors( 9) ==> 0
          log2-binary-factors(-10) ==> 1     log2-binary-factors(10) ==> 1
          log2-binary-factors(-11) ==> 0     log2-binary-factors(11) ==> 0
          log2-binary-factors(-12) ==> 2     log2-binary-factors(12) ==> 2
          log2-binary-factors(-13) ==> 0     log2-binary-factors(13) ==> 0
          log2-binary-factors(-14) ==> 1     log2-binary-factors(14) ==> 1
          log2-binary-factors(-15) ==> 0     log2-binary-factors(15) ==> 0
          log2-binary-factors(-16) ==> 4     log2-binary-factors(16) ==> 4

5.1.3 Bit Within Word
---------------------

 -- Function: logbit? index n
 -- Function: bit-set? index n
          (logbit? index n) == (logtest (expt 2 index) n)

          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

 -- Function: copy-bit index from bit
     Returns an integer the same as FROM except in the INDEXth bit,
     which is 1 if BIT is `#t' and 0 if BIT is `#f'.

     Example:
          (number->string (copy-bit 0 0 #t) 2)       => "1"
          (number->string (copy-bit 2 0 #t) 2)       => "100"
          (number->string (copy-bit 2 #b1111 #f) 2)  => "1011"

5.1.4 Field of Bits
-------------------

 -- Function: bit-field n start end
     Returns the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

     Example:
          (number->string (bit-field #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-field #b1101101010 4 9) 2)
             => "10110"

 -- Function: copy-bit-field to from start end
     Returns an integer the same as TO except possibly in the START
     (inclusive) through END (exclusive) bits, which are the same as
     those of FROM.  The 0-th bit of FROM becomes the STARTth bit of
     the result.

     Example:
          (number->string (copy-bit-field #b1101101010 0 0 4) 2)
                  => "1101100000"
          (number->string (copy-bit-field #b1101101010 -1 0 4) 2)
                  => "1101101111"
          (number->string (copy-bit-field #b110100100010000 -1 5 9) 2)
                  => "110100111110000"

 -- Function: ash n count
 -- Function: arithmetic-shift n count
     Returns an integer equivalent to `(inexact->exact (floor (* N
     (expt 2 COUNT))))'.

     Example:
          (number->string (ash #b1 3) 2)
             => "1000"
          (number->string (ash #b1010 -1) 2)
             => "101"

 -- Function: rotate-bit-field n count start end
     Returns N with the bit-field from START to END cyclically permuted
     by COUNT bits towards high-order.

     Example:
          (number->string (rotate-bit-field #b0100 3 0 4) 2)
              => "10"
          (number->string (rotate-bit-field #b0100 -1 0 4) 2)
              => "10"
          (number->string (rotate-bit-field #b110100100010000 -1 5 9) 2)
              => "110100010010000"
          (number->string (rotate-bit-field #b110100100010000 1 5 9) 2)
              => "110100000110000"

 -- Function: reverse-bit-field n start end
     Returns N with the order of bits START to END reversed.

          (number->string (reverse-bit-field #xa7 0 8) 16)
            => "e5"

5.1.5 Bits as Booleans
----------------------

 -- Function: integer->list k len
 -- Function: integer->list k
     `integer->list' returns a list of LEN booleans corresponding to
     each bit of the non-negative integer K.  #t is coded for each 1;         |
     #f for 0.  The LEN argument defaults to `(integer-length K)'.            |

 -- Function: list->integer list
     `list->integer' returns an integer formed from the booleans in the
     list LIST, which must be a list of booleans.  A 1 bit is coded for
     each #t; a 0 bit for #f.

          (list->integer (integer->list K))  =>  K                            |

 -- Function: booleans->integer bool1 ...
     Returns the integer coded by the BOOL1 ... arguments.


File: slib-3b5.info,  Node: Modular Arithmetic,  Next: Irrational Integer Functions,  Prev: Bit-Twiddling,  Up: Mathematical Packages
                                                                              |
5.2 Modular Arithmetic
======================

`(require 'modular)' 

 -- Function: extended-euclid n1 n2
     Returns a list of 3 integers `(d x y)' such that d = gcd(N1, N2) =
     N1 * x + N2 * y.

 -- Function: symmetric:modulus m
     For odd positive integer M, returns an object suitable for passing
     as the first argument to `modular:' procedures, directing them to
     return a symmetric modular number, ie. an N such that
          (<= (quotient M -2) N (quotient M 2)

 -- Function: modular:characteristic modulus
     Returns the non-negative integer characteristic of the ring formed
     when MODULUS is used with `modular:' procedures.

 -- Function: modular:normalize modulus n
     Returns the integer `(modulo N (modular:characteristic MODULUS))'
     in the representation specified by MODULUS.

The rest of these functions assume normalized arguments; That is, the
arguments are constrained by the following table:

For all of these functions, if the first argument (MODULUS) is:
`positive?'
     Integers mod MODULUS.  The result is between 0 and MODULUS.

`zero?'
     The arguments are treated as integers.  An integer is returned.

Otherwise, if MODULUS is a value returned by `(symmetric:modulus
RADIX)', then the arguments and result are treated as members of the
integers modulo RADIX, but with "symmetric" representation; i.e.  
     (<= (quotient RADIX 2) N (quotient (- -1 RADIX) 2)

If all the arguments are fixnums the computation will use only fixnums.

 -- Function: modular:invertable? modulus k
     Returns `#t' if there exists an integer n such that K * n == 1 mod
     MODULUS, and `#f' otherwise.

 -- Function: modular:invert modulus n2
     Returns an integer n such that 1 = (n * N2) mod MODULUS.  If N2
     has no inverse mod MODULUS an error is signaled.

 -- Function: modular:negate modulus n2
     Returns (-N2) mod MODULUS.

 -- Function: modular:+ modulus n2 n3
     Returns (N2 + N3) mod MODULUS.

 -- Function: modular:- modulus n2 n3
     Returns (N2 - N3) mod MODULUS.

 -- Function: modular:* modulus n2 n3
     Returns (N2 * N3) mod MODULUS.

     The Scheme code for `modular:*' with negative MODULUS is not
     completed for fixnum-only implementations.

 -- Function: modular:expt modulus n2 n3
     Returns (N2 ^ N3) mod MODULUS.


File: slib-3b5.info,  Node: Irrational Integer Functions,  Next: Irrational Real Functions,  Prev: Modular Arithmetic,  Up: Mathematical Packages
                                                                              |
5.3 Irrational Integer Functions
================================

`(require 'math-integer)' 

 -- Function: integer-expt n1 n2
     Returns N1 raised to the power N2 if that result is an exact
     integer; otherwise signals an error.

     `(integer-expt 0 N2)'

     returns 1 for N2 equal to 0; returns 0 for positive integer N2;
     signals an error otherwise.

 -- Function: integer-log base k
     Returns the largest exact integer whose power of BASE is less than
     or equal to K. If BASE or K is not a positive exact integer, then
     `integer-log' signals an error.

 -- Function: integer-sqrt k
     For non-negative integer K returns the largest integer whose square
     is less than or equal to K; otherwise signals an error.

 -- Function: quotient n1 n2                                                  |
 -- Function: remainder n1 n2                                                 |
 -- Function: modulo n1 n2                                                    |
     are redefined so that they accept only exact-integer arguments.

 -- Function: round-quotient n1 n2                                            |
     Returns the quotient of N1 and N2 rounded toward even.                   |
                                                                              |
          (quotient 3 2)        => 1                                          |
          (round-quotient 3 2)  => 2                                          |
                                                                              |

File: slib-3b5.info,  Node: Irrational Real Functions,  Next: Prime Numbers,  Prev: Irrational Integer Functions,  Up: Mathematical Packages
                                                                              |
5.4 Irrational Real Functions
=============================

`(require 'math-real)' 

  Although this package defines real and complex functions, it is safe
to load into an integer-only implementation; those functions will be
defined to #f.

 -- Function: real-exp x                                                      |
 -- Function: real-ln x                                                       |
 -- Function: real-log y x                                                    |
 -- Function: real-sin x                                                      |
 -- Function: real-cos x                                                      |
 -- Function: real-tan x                                                      |
 -- Function: real-asin x                                                     |
 -- Function: real-acos x                                                     |
 -- Function: real-atan x                                                     |
 -- Function: atan y x                                                        |
     These procedures are part of every implementation that supports
     general real numbers; they compute the usual transcendental
     functions.  `real-ln' computes the natural logarithm of X;
     `real-log' computes the logarithm of X base Y, which is `(/
     (real-ln x) (real-ln y))'.  If arguments X and Y are not both
     real; or if the correct result would not be real, then these
     procedures signal an error.


 -- Function: real-sqrt x                                                     |
     For non-negative real X the result will be its positive square
     root; otherwise an error will be signaled.


 -- Function: real-expt x1 x2
     Returns X1 raised to the power X2 if that result is a real number;
     otherwise signals an error.

     `(real-expt 0.0 X2)'

        * returns 1.0 for X2 equal to 0.0;

        * returns 0.0 for positive real X2;

        * signals an error otherwise.


 -- Function: quo x1 x2
 -- Function: rem x1 x2
 -- Function: mod x1 x2
     X2 should be non-zero.

              (quo X1 X2)                     ==> N_Q
              (rem X1 X2)                     ==> X_R
              (mod X1 X2)                     ==> X_M

     where N_Q is X1/X2 rounded towards zero, 0 < |X_R| < |X2|, 0 <
     |X_M| < |X2|, X_R and X_M differ from X1 by a multiple of X2, X_R
     has the same sign as X1, and X_M has the same sign as X2.

     From this we can conclude that for X2 not equal to 0,

               (= X1 (+ (* X2 (quo X1 X2))
                     (rem X1 X2)))
                                                 ==>  #t

     provided all numbers involved in that computation are exact.

              (quo 2/3 1/5)                         ==>  3
              (mod 2/3 1/5)                         ==>  1/15

              (quo .666 1/5)                        ==>  3.0
              (mod .666 1/5)                        ==>  65.99999999999995e-3

 -- Function: ln Z
     These procedures are part of every implementation that supports
     general real numbers.  `Ln' computes the natural logarithm of Z

     In general, the mathematical function ln is multiply defined.  The
     value of ln Z is defined to be the one whose imaginary part lies
     in the range from -pi (exclusive) to pi (inclusive).


 -- Function: abs x
     For real argument X, `Abs' returns the absolute value of X'
     otherwise it signals an error.

     (abs -7)                               ==>  7


 -- Function: make-rectangular x1 x2
 -- Function: make-polar x3 x4
     These procedures are part of every implementation that supports
     general complex numbers.  Suppose X1, X2, X3, and X4 are real
     numbers and Z is a complex number such that

                         Z = X1 + X2i = X3 . e^i X4

     Then

     (make-rectangular X1 X2)               ==> Z
     (make-polar X3 X4)                     ==> Z

     where -pi < x_angle <= pi with x_angle = X4 + 2pi n for some
     integer n.

     If an argument is not real, then these procedures signal an error.



File: slib-3b5.info,  Node: Prime Numbers,  Next: Random Numbers,  Prev: Irrational Real Functions,  Up: Mathematical Packages
                                                                              |
5.5 Prime Numbers
=================

`(require 'factor)' 

 -- Variable: prime:prngs
     PRIME:PRNGS is the random-state (*note Random Numbers::) used by
     these procedures.  If you call these procedures from more than one
     thread (or from interrupt), `random' may complain about reentrant
     calls.
  _Note:_ The prime test and generation procedures implement (or use)
the Solovay-Strassen primality test. See

   * Robert Solovay and Volker Strassen, `A Fast Monte-Carlo Test for
     Primality', SIAM Journal on Computing, 1977, pp 84-85.

 -- Function: jacobi-symbol p q
     Returns the value (+1, -1, or 0) of the Jacobi-Symbol of exact
     non-negative integer P and exact positive odd integer Q.

 -- Variable: prime:trials
     PRIME:TRIALS the maxinum number of iterations of Solovay-Strassen
     that will be done to test a number for primality.

 -- Function: prime? n
     Returns `#f' if N is composite; `#t' if N is prime.  There is a
     slight chance `(expt 2 (- prime:trials))' that a composite will
     return `#t'.

 -- Function: primes< start count
     Returns a list of the first COUNT prime numbers less than START.
     If there are fewer than COUNT prime numbers less than START, then
     the returned list will have fewer than START elements.

 -- Function: primes> start count
     Returns a list of the first COUNT prime numbers greater than START.

 -- Function: factor k
     Returns a list of the prime factors of K.  The order of the
     factors is unspecified.  In order to obtain a sorted list do
     `(sort! (factor K) <)'.


File: slib-3b5.info,  Node: Random Numbers,  Next: Discrete Fourier Transform,  Prev: Prime Numbers,  Up: Mathematical Packages
                                                                              |
5.6 Random Numbers
==================

A pseudo-random number generator is only as good as the tests it passes.
George Marsaglia of Florida State University developed a battery of
tests named "DIEHARD" (`http://stat.fsu.edu/~geo/diehard.html').
`diehard.c' has a bug which the patch
`http://groups.csail.mit.edu/mac/ftpdir/users/jaffer/diehard.c.pat'
corrects.

  SLIB's PRNG generates 8 bits at a time.  With the degenerate seed
`0', the numbers generated pass DIEHARD; but when bits are combined
from sequential bytes, tests fail.  With the seed
`http://swissnet.ai.mit.edu/~jaffer/SLIB.html', all of those tests pass.

* Menu:

* Exact Random Numbers::        'random
* Inexact Random Numbers::      'random-inexact


File: slib-3b5.info,  Node: Exact Random Numbers,  Next: Inexact Random Numbers,  Prev: Random Numbers,  Up: Random Numbers
                                                                              |
5.6.1 Exact Random Numbers
--------------------------

`(require 'random)' 

 -- Function: random n state
 -- Function: random n
     N must be an exact positive integer.  `random' returns an exact
     integer between zero (inclusive) and N (exclusive).  The values
     returned by `random' are uniformly distributed from 0 to N.

     The optional argument STATE must be of the type returned by
     `(seed->random-state)' or `(make-random-state)'.  It defaults to
     the value of the variable `*random-state*'.  This object is used
     to maintain the state of the pseudo-random-number generator and is
     altered as a side effect of calls to `random'.

 -- Variable: *random-state*
     Holds a data structure that encodes the internal state of the
     random-number generator that `random' uses by default.  The nature
     of this data structure is implementation-dependent.  It may be
     printed out and successfully read back in, but may or may not
     function correctly as a random-number state object in another
     implementation.

 -- Function: copy-random-state state
     Returns a new copy of argument STATE.


 -- Function: copy-random-state
     Returns a new copy of `*random-state*'.

 -- Function: seed->random-state seed
     Returns a new object of type suitable for use as the value of the
     variable `*random-state*' or as a second argument to `random'.
     The number or string SEED is used to initialize the state.  If
     `seed->random-state' is called twice with arguments which are
     `equal?', then the returned data structures will be `equal?'.
     Calling `seed->random-state' with unequal arguments will nearly
     always return unequal states.

 -- Function: make-random-state
 -- Function: make-random-state obj
     Returns a new object of type suitable for use as the value of the
     variable `*random-state*' or as a second argument to `random'.  If
     the optional argument OBJ is given, it should be a printable
     Scheme object; the first 50 characters of its printed
     representation will be used as the seed.  Otherwise the value of
     `*random-state*' is used as the seed.


File: slib-3b5.info,  Node: Inexact Random Numbers,  Prev: Exact Random Numbers,  Up: Random Numbers
                                                                              |
5.6.2 Inexact Random Numbers
----------------------------

`(require 'random-inexact)' 

 -- Function: random:uniform
 -- Function: random:uniform state
     Returns an uniformly distributed inexact real random number in the
     range between 0 and 1.

 -- Function: random:exp
 -- Function: random:exp state
     Returns an inexact real in an exponential distribution with mean
     1.  For an exponential distribution with mean U use
     `(* U (random:exp))'.

 -- Function: random:normal
 -- Function: random:normal state
     Returns an inexact real in a normal distribution with mean 0 and
     standard deviation 1.  For a normal distribution with mean M and
     standard deviation D use `(+ M (* D (random:normal)))'.

 -- Procedure: random:normal-vector! vect
 -- Procedure: random:normal-vector! vect state
     Fills VECT with inexact real random numbers which are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

 -- Procedure: random:hollow-sphere! vect
 -- Procedure: random:hollow-sphere! vect state
     Fills VECT with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of VECT as coordinates in space
     of dimension n = `(vector-length VECT)', the coordinates are
     uniformly distributed over the surface of the unit n-shere.

 -- Procedure: random:solid-sphere! vect
 -- Procedure: random:solid-sphere! vect state
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in
     space of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed within the unit N-shere.  The sum of the
     squares of the numbers is returned.


File: slib-3b5.info,  Node: Discrete Fourier Transform,  Next: Cyclic Checksum,  Prev: Random Numbers,  Up: Mathematical Packages
                                                                              |
5.7 Discrete Fourier Transform
==============================

`(require 'dft)' or `(require 'Fourier-transform)' 

  `fft' and `fft-1' compute the Fast-Fourier-Transforms (O(n*log(n)))
of arrays whose dimensions are all powers of 2.

  `sft' and `sft-1' compute the Discrete-Fourier-Transforms for all
combinations of dimensions (O(n^2)).

 -- Function: sft array prot
 -- Function: sft array
     ARRAY is an array of positive rank.  `sft' returns an array of
     type PROT (defaulting to ARRAY) of complex numbers comprising the
     "Discrete Fourier Transform" of ARRAY.  

 -- Function: sft-1 array prot
 -- Function: sft-1 array
     ARRAY is an array of positive rank.  `sft-1' returns an array of
     type PROT (defaulting to ARRAY) of complex numbers comprising the
     inverse Discrete Fourier Transform of ARRAY.

 -- Function: fft array prot
 -- Function: fft array
     ARRAY is an array of positive rank whose dimensions are all powers
     of 2.  `fft' returns an array of type PROT (defaulting to ARRAY)
     of complex numbers comprising the Discrete Fourier Transform of
     ARRAY.

 -- Function: fft-1 array prot
 -- Function: fft-1 array
     ARRAY is an array of positive rank whose dimensions are all powers
     of 2.  `fft-1' returns an array of type PROT (defaulting to ARRAY)
     of complex numbers comprising the inverse Discrete Fourier
     Transform of ARRAY.

  `dft' and `dft-1' compute the discrete Fourier transforms using the
best method for decimating each dimension.

 -- Function: dft array prot
 -- Function: dft array
     `dft' returns an array of type PROT (defaulting to ARRAY) of
     complex numbers comprising the Discrete Fourier Transform of ARRAY.

 -- Function: dft-1 array prot
 -- Function: dft-1 array
     `dft-1' returns an array of type PROT (defaulting to ARRAY) of
     complex numbers comprising the inverse Discrete Fourier Transform
     of ARRAY.

`(fft-1 (fft ARRAY))' will return an array of values close to ARRAY.

     (fft '#(1 0+i -1 0-i 1 0+i -1 0-i)) =>

     #(0.0 0.0 0.0+628.0783185208527e-18i 0.0
       0.0 0.0 8.0-628.0783185208527e-18i 0.0)

     (fft-1 '#(0 0 0 0 0 0 8 0)) =>

     #(1.0 -61.23031769111886e-18+1.0i -1.0 61.23031769111886e-18-1.0i
       1.0 -61.23031769111886e-18+1.0i -1.0 61.23031769111886e-18-1.0i)


File: slib-3b5.info,  Node: Cyclic Checksum,  Next: Graphing,  Prev: Discrete Fourier Transform,  Up: Mathematical Packages
                                                                              |
5.8 Cyclic Checksum
===================

`(require 'crc)' Cyclic Redundancy Checks using Galois field GF(2)
polynomial arithmetic are used for error detection in many data
transmission and storage applications.

The generator polynomials for various CRC protocols are availble from
many sources.  But the polynomial is just one of many parameters which
must match in order for a CRC implementation to interoperate with
existing systems:

   * the byte-order and bit-order of the data stream;

   * whether the CRC or its inverse is being calculated;

   * the initial CRC value; and

   * whether and where the CRC value is appended (inverted or
     non-inverted) to the data stream.


The performance of a particular CRC polynomial over packets of given
sizes varies widely.  In terms of the probability of undetected errors,
some uses of extant CRC polynomials are suboptimal by several orders of
magnitude.

If you are considering CRC for a new application, consult the following
article to find the optimum CRC polynomial for your range of data
lengths:

   * Philip Koopman and Tridib Chakravarty,
     "Cyclic Redundancy Code (CRC) Polynomial Selection For Embedded
     Networks",
     The International Conference on Dependable Systems and Networks,
     DSN-2004.

`http://www.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf'


There is even some controversy over the polynomials themselves.

 -- Constant: crc-32-polynomial
     For CRC-32, http://www2.sis.pitt.edu/~jkabara/tele-2100/lect08.html
     gives x^32+x^26+x^23+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+1.

     But
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://spinroot.com/spin/Doc/Book91_PDF/ch3.pdf,
     http://www.erg.abdn.ac.uk/users/gorry/course/dl-pages/crc.html,
     http://www.rad.com/networks/1994/err_con/crc_most.htm, and
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html,
     http://www.nobugconsulting.ro/crc.php give
     x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

     SLIB `crc-32-polynomial' uses the latter definition.

 -- Constant: crc-ccitt-polynomial
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www2.sis.pitt.edu/~jkabara/tele-2100/lect08.html, and
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html give CRC-CCITT:
     x^16+x^12+x^5+1.

 -- Constant: crc-16-polynomial
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html, and
     http://www.usb.org/developers/data/crcdes.pdf give CRC-16:
     x^16+x^15+x^2+1.

 -- Constant: crc-12-polynomial
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html, and
     http://spinroot.com/spin/Doc/Book91_PDF/ch3.pdf give CRC-12:
     x^12+x^11+x^3+x^2+1.

     But
     http://www.ffldusoe.edu/Faculty/Denenberg/Topics/Networks/Error_Detection_Correction/crc.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://www.eng.uwi.tt/depts/elec/staff/kimal/errorcc.html,
     http://www.ee.uwa.edu.au/~roberto/teach/itc314/java/CRC/,
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html, and
     http://www.efg2.com/Lab/Mathematics/CRC.htm give CRC-12:
     x^12+x^11+x^3+x^2+x+1.

     These differ in bit 1 and calculations using them return different
     values.  With citations near evenly split, it is hard to know
     which is correct.  Thanks to Philip Koopman for breaking the tie
     in favor of the latter (#xC07).

 -- Constant: crc-10-polynomial
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html
     gives CRC-10: x^10+x^9+x^5+x^4+1; but
     http://cell-relay.indiana.edu/cell-relay/publications/software/CRC/crc10.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html,
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html,
     http://www.techfest.com/networking/atm/atm.htm,
     http://www.protocols.com/pbook/atmcell2.htm, and
     http://www.nobugconsulting.ro/crc.php give CRC-10:
     x^10+x^9+x^5+x^4+x+1.

 -- Constant: crc-08-polynomial
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html, and
     http://www.nobugconsulting.ro/crc.php give CRC-8: x^8+x^2+x^1+1

 -- Constant: atm-hec-polynomial
     http://cell-relay.indiana.edu/cell-relay/publications/software/CRC/32bitCRC.tutorial.html
     and http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html give ATM HEC:
     x^8+x^2+x+1.

 -- Constant: dowcrc-polynomial
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html
     gives DOWCRC: x^8+x^5+x^4+1.

 -- Constant: usb-token-polynomial
     http://www.usb.org/developers/data/crcdes.pdf and
     http://www.nobugconsulting.ro/crc.php give USB-token: x^5+x^2+1.

Each of these polynomial constants is a string of `1's and `0's, the
exponent of each power of X in descending order.

 -- Function: crc:make-table poly
     POLY must be string of `1's and `0's beginning with `1' and having
     length greater than 8.  `crc:make-table' returns a vector of 256
     integers, such that:

          (set! CRC
                (logxor (ash (logand (+ -1 (ash 1 (- DEG 8))) CRC) 8)
                        (vector-ref CRC-TABLE
                                    (logxor (ash CRC (- 8 DEG)) BYTE))))

     will compute the CRC with the 8 additional bits in BYTE; where CRC
     is the previous accumulated CRC value, DEG is the degree of POLY,
     and CRC-TABLE is the vector returned by `crc:make-table'.

     If the implementation does not support DEG-bit integers, then
     `crc:make-table' returns #f.


 -- Function: cksum file
     Computes the P1003.2/D11.2 (POSIX.2) 32-bit checksum of FILE.

          (require 'crc)
          (cksum (in-vicinity (library-vicinity) "ratize.scm"))
          => 157103930

 -- Function: cksum port
     Computes the checksum of the bytes read from PORT until the
     end-of-file.


`cksum-string', which returns the P1003.2/D11.2 (POSIX.2) 32-bit
checksum of the bytes in STR, can be defined as follows:

     (require 'string-port)
     (define (cksum-string str) (call-with-input-string str cksum))

 -- Function: crc16 file
     Computes the USB data-packet (16-bit) CRC of FILE.

 -- Function: crc16 port
     Computes the USB data-packet (16-bit) CRC of the bytes read from
     PORT until the end-of-file.

     `crc16' calculates the same values as the crc16.pl program given
     in http://www.usb.org/developers/data/crcdes.pdf.


 -- Function: crc5 file
     Computes the USB token (5-bit) CRC of FILE.

 -- Function: crc5 port
     Computes the USB token (5-bit) CRC of the bytes read from PORT
     until the end-of-file.

     `crc5' calculates the same values as the crc5.pl program given in
     http://www.usb.org/developers/data/crcdes.pdf.



File: slib-3b5.info,  Node: Graphing,  Next: Solid Modeling,  Prev: Cyclic Checksum,  Up: Mathematical Packages
                                                                              |
5.9 Graphing
============

* Menu:

* Character Plotting::
* PostScript Graphing::


File: slib-3b5.info,  Node: Character Plotting,  Next: PostScript Graphing,  Prev: Graphing,  Up: Graphing
                                                                              |
5.9.1 Character Plotting
------------------------

`(require 'charplot)' 

 -- Variable: charplot:dimensions
     A list of the maximum height (number of lines) and maximum width
     (number of columns) for the graph, its scales, and labels.

     The default value for CHARPLOT:DIMENSIONS is the
     `output-port-height' and `output-port-width' of
     `current-output-port'.

 -- Procedure: plot coords x-label y-label
     COORDS is a list or vector of coordinates, lists of x and y
     coordinates.  X-LABEL and Y-LABEL are strings with which to label
     the x and y axes.

     Example:
          (require 'charplot)
          (set! charplot:dimensions '(20 55))

          (define (make-points n)
            (if (zero? n)
                '()
                (cons (list (/ n 6) (sin (/ n 6))) (make-points (1- n)))))

          (plot (make-points 40) "x" "Sin(x)")
          -|
            Sin(x)   _________________________________________
                   1|-       ****                             |
                    |      **    **                           |
                0.75|-    *        *                          |
                    |    *          *                         |
                 0.5|-  *            *                        |
                    |  *                                     *|
                0.25|-                *                     * |
                    | *                *                      |
                   0|-------------------*------------------*--|
                    |                                     *   |
               -0.25|-                   *               *    |
                    |                     *             *     |
                -0.5|-                     *                  |
                    |                       *          *      |
               -0.75|-                       *        *       |
                    |                         **    **        |
                  -1|-                          ****          |
                    |:_____._____:_____._____:_____._____:____|
               x                 2           4           6

 -- Procedure: plot func x1 x2
 -- Procedure: plot func x1 x2 npts
     Plots the function of one argument FUNC over the range X1 to X2.
     If the optional integer argument NPTS is supplied, it specifies
     the number of points to evaluate FUNC at.

          (plot sin 0 (* 2 pi))
          -|
                     _________________________________________
                   1|-:       ****                            |
                    | :     **    **                          |
                0.75|-:    *        *                         |
                    | :   *          *                        |
                 0.5|-:  **          **                       |
                    | : *             *                       |
                0.25|-:**              **                     |
                    | :*                *                     |
                   0|-*------------------*--------------------|
                    | :                  *                 *  |
               -0.25|-:                   **              **  |
                    | :                    *             *    |
                -0.5|-:                     *           **    |
                    | :                      *          *     |
               -0.75|-:                       *       **      |
                    | :                        **    **       |
                  -1|-:                          ****         |
                    |_:_____._____:_____._____:_____._____:___|
                      0           2           4           6

 -- Procedure: histograph data label
     Creates and displays a histogram of the numerical values contained
     in vector or list DATA

          (require 'random-inexact)
          (histograph (do ((idx 99 (+ -1 idx))
                           (lst '() (cons (* .02 (random:normal)) lst)))
                          ((negative? idx) lst))
                      "normal")
          -|
                     _________________________________________
                   8|-                :    I                  |
                    |                 :    I                  |
                   7|-           I  I :    I                  |
                    |            I  I :    I                  |
                   6|-          III I :I   I                  |
                    |           III I :I   I                  |
                   5|-          IIIIIIIIII I                  |
                    |           IIIIIIIIII I                  |
                   4|-          IIIIIIIIIIII                  |
                    |           IIIIIIIIIIII                  |
                   3|-I    I I  IIIIIIIIIIII  II     I        |
                    | I    I I  IIIIIIIIIIII  II     I        |
                   2|-I    I I IIIIIIIIIIIIIIIII     I        |
                    | I    I I IIIIIIIIIIIIIIIII     I        |
                   1|-II I I IIIIIIIIIIIIIIIIIIIII   I I I    |
                    | II I I IIIIIIIIIIIIIIIIIIIII   I I I    |
                   0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII----|
                    |__.____:____.____:____.____:____.____:___|
            normal        -0.025      0       0.025      0.05


File: slib-3b5.info,  Node: PostScript Graphing,  Prev: Character Plotting,  Up: Graphing
                                                                              |
5.9.2 PostScript Graphing
-------------------------

`(require 'eps-graph)'

This is a graphing package creating encapsulated-PostScript files.  Its
motivations and design choice are described in
`http://people.csail.mit.edu/jaffer/Docupage/grapheps'

A dataset to be plotted is taken from a 2-dimensional array.
Corresponding coordinates are in rows.  Coordinates from any pair of
columns can be plotted.

 -- Function: create-postscript-graph filename.eps size elt1 ...
     FILENAME.EPS should be a string naming an output file to be
     created.  SIZE should be an exact integer, a list of two exact
     integers, or #f.  ELT1, ... are values returned by graphing
     primitives described here.

     `create-postscript-graph' creates an "Encapsulated-PostScript"
     file named FILENAME.EPS containing graphs as directed by the ELT1,
     ... arguments.

     The size of the graph is determined by the SIZE argument.  If a
     list of two integers, they specify the width and height.  If one
     integer, then that integer is the width and the height is 3/4 of
     the width.  If #f, the graph will be 800 by 600.

These graphing procedures should be called as arguments to
`create-postscript-graph'.  The order of these arguments is
significant; PostScript graphics state is affected serially from the
first ELT argument to the last.

 -- Function: whole-page
     Pushes a rectangle for the whole encapsulated page onto the
     PostScript stack.  This pushed rectangle is an implicit argument to
     `partition-page' or `setup-plot'.

* Menu:

* Column Ranges::
* Drawing the Graph::
* Graphics Context::
* Rectangles::
* Legending::
* Legacy Plotting::
* Example Graph::


File: slib-3b5.info,  Node: Column Ranges,  Next: Drawing the Graph,  Prev: PostScript Graphing,  Up: PostScript Graphing
                                                                              |
5.9.2.1 Column Ranges
.....................

A "range" is a list of two numbers, the minimum and the maximum.  Ranges
can be given explicity or computed in PostScript by `column-range'.

 -- Function: column-range array k
     Returns the range of values in 2-dimensional ARRAY column K.

 -- Function: pad-range range p
     Expands RANGE by P/100 on each end.

 -- Function: snap-range range
     Expands RANGE to round number of ticks.

 -- Function: combine-ranges range1 range2 ...
     Returns the minimal range covering all RANGE1, RANGE2, ...

 -- Function: setup-plot x-range y-range pagerect
 -- Function: setup-plot x-range y-range
     X-RANGE and Y-RANGE should each be a list of two numbers or the
     value returned by `pad-range', `snap-range', or `combine-range'.
     PAGERECT is the rectangle bounding the graph to be drawn; if
     missing, the rectangle from the top of the PostScript stack is
     popped and used.

     Based on the given ranges, `setup-plot' sets up scaling and
     margins for making a graph.  The margins are sized proportional to
     the FONTHEIGHT value at the time of the call to setup-plot.
     `setup-plot' sets two variables:

    PLOTRECT
          The region where data points will be plotted.

    GRAPHRECT
          The PAGERECT argument to `setup-plot'.  Includes plotrect,
          legends, etc.


File: slib-3b5.info,  Node: Drawing the Graph,  Next: Graphics Context,  Prev: Column Ranges,  Up: PostScript Graphing
                                                                              |
5.9.2.2 Drawing the Graph
.........................

 -- Function: plot-column array x-column y-column proc3s
     Plots points with x coordinate in X-COLUMN of ARRAY and y
     coordinate Y-COLUMN of ARRAY.  The symbol PROC3S specifies the
     type of glyph or drawing style for presenting these coordinates.

The glyphs and drawing styles available are:

`line'
     Draws line connecting points in order.

`mountain'
     Fill area below line connecting points.

`cloud'
     Fill area above line connecting points.

`impulse'
     Draw line from x-axis to each point.

`bargraph'
     Draw rectangle from x-axis to each point.

`disc'
     Solid round dot.

`point'
     Minimal point - invisible if linewidth is 0.

`square'
     Square box.

`diamond'
     Square box at 45.o

`plus'
     Plus sign.

`cross'
     X sign.

`triup'
     Triangle pointing upward

`tridown'
     Triangle pointing downward

`pentagon'
     Five sided polygon

`circle'
     Hollow circle

 -- Function: plot-text-column array x-column y-column t-column proc3s        |
     Plots text in T-COLUMN of ARRAY at x coordinate in X-COLUMN of           |
     ARRAY and y coordinate Y-COLUMN of ARRAY.  The symbol PROC3S             |
     specifies the offset of the text from the specified coordinates.         |
                                                                              |
The offsets available are:                                                    |
                                                                              |
`above'                                                                       |
     Draws the text centered above at the point.                              |
                                                                              |
`center'                                                                      |
     Draws the text centered at the point.                                    |
                                                                              |
`below'                                                                       |
     Draws the text centered below the point.                                 |
                                                                              |
`left'                                                                        |
     Draws the text to the left of the point.                                 |
                                                                              |
`right'                                                                       |
     Draws the text to the right of the point.                                |
                                                                              |
  All the offsets other than `center' are calculated to keep the text         |
clear of a glyph drawn at the same coordinates.  If you need more or          |
less clearance, use `set-glyphsize'.                                          |
                                                                              |

File: slib-3b5.info,  Node: Graphics Context,  Next: Rectangles,  Prev: Drawing the Graph,  Up: PostScript Graphing
                                                                              |
5.9.2.3 Graphics Context
........................

 -- Function: in-graphic-context arg ...
     Saves the current graphics state, executes ARGS, then restores to
     saved graphics state.

 -- Function: set-color color
     COLOR should be a string naming a Resene color, a saturate color,
     or a number between 0 and 100.

     `set-color' sets the PostScript color to the color of the given
     string, or a grey value between black (0) and white (100).

 -- Function: set-font font height                                            |
 -- Function: set-font font encoding height                                   |
     FONT should be a (case-sensitive) string naming a PostScript font.       |
     HEIGHT should be a positive real number.  ENCODING should name a         |
     PostScript encoding such as `ISOLatin1Encoding'.                         |

     `set-font' Changes the current PostScript font to FONT with the          |
     ENCODING encoding, and height equal to HEIGHT.  The default font is      |
     `Helvetica' (12pt).  The default encoding is `StandardEncoding'.         |

The base set of PostScript fonts is:

Times          Times-Italic       Times-Bold         Times-BoldItalic
Helvetica      Helvetica-Oblique  Helvetica-Bold     Helvetica-BoldOblique
Courier        Courier-Oblique    Courier-Bold       Courier-BoldOblique
Symbol                                               

The base set of PostScript encodings is:                                      |
                                                                              |
StandardEncoding         ISOLatin1Encoding        ExpertEncoding              |
ExpertSubsetEncoding     SymbolEncoding                                       |
                                                                              |
Line parameters do no affect fonts; they do effect glyphs.

 -- Function: set-linewidth w
     The default linewidth is 1.  Setting it to 0 makes the lines drawn
     as skinny as possible.  Linewidth must be much smaller than
     glyphsize for readable glyphs.

 -- Function: set-linedash j k
     Lines are drawn J-on K-off.


 -- Function: set-linedash j
     Lines are drawn J-on J-off.


 -- Function: set-linedash
     Turns off dashing.

 -- Function: set-glyphsize w
     Sets the (PostScript) variable glyphsize to W.  The default
     glyphsize is 6.

The effects of `clip-to-rect' are also part of the graphic context.


File: slib-3b5.info,  Node: Rectangles,  Next: Legending,  Prev: Graphics Context,  Up: PostScript Graphing
                                                                              |
5.9.2.4 Rectangles
..................

A "rectangle" is a list of 4 numbers; the first two elements are the x
and y coordinates of lower left corner of the rectangle.  The other two
elements are the width and height of the rectangle.

 -- Function: whole-page
     Pushes a rectangle for the whole encapsulated page onto the
     PostScript stack.  This pushed rectangle is an implicit argument to
     `partition-page' or `setup-plot'.

 -- Function: partition-page xparts yparts
     Pops the rectangle currently on top of the stack and pushes XPARTS
     * YPARTS sub-rectangles onto the stack in decreasing y and
     increasing x order.  If you are drawing just one graph, then you
     don't need `partition-page'.

 -- Variable: plotrect
     The rectangle where data points should be plotted.  PLOTRECT is
     set by `setup-plot'.

 -- Variable: graphrect
     The PAGERECT argument of the most recent call to `setup-plot'.
     Includes plotrect, legends, etc.

 -- Function: fill-rect rect
     fills RECT with the current color.

 -- Function: outline-rect rect
     Draws the perimiter of RECT in the current color.

 -- Function: clip-to-rect rect
     Modifies the current graphics-state so that nothing will be drawn
     outside of the rectangle RECT.  Use `in-graphic-context' to limit
     the extent of `clip-to-rect'.


File: slib-3b5.info,  Node: Legending,  Next: Legacy Plotting,  Prev: Rectangles,  Up: PostScript Graphing
                                                                              |
5.9.2.5 Legending
.................

 -- Function: title-top title subtitle
 -- Function: title-top title
     Puts a TITLE line and an optional SUBTITLE line above the
     `graphrect'.

 -- Function: title-bottom title subtitle
 -- Function: title-bottom title
     Puts a TITLE line and an optional SUBTITLE line below the
     `graphrect'.

 -- Variable: topedge
 -- Variable: bottomedge
     These edge coordinates of `graphrect' are suitable for passing as
     the first argument to `rule-horizontal'.

 -- Variable: leftedge
 -- Variable: rightedge
     These edge coordinates of `graphrect' are suitable for passing as
     the first argument to `rule-vertical'.

 -- Function: set-margin-templates left right
     The margin-templates are strings whose displayed width is used to
     reserve space for the left and right side numerical legends.  The
     default values are "-.0123456789".

 -- Function: rule-vertical x-coord text tick-width
     Draws a vertical ruler with X coordinate X-COORD and labeled with
     string TEXT.  If TICK-WIDTH is positive, then the ticks are
     TICK-WIDTH long on the right side of X-COORD; and TEXT and numeric
     legends are on the left.  If TICK-WIDTH is negative, then the
     ticks are -TICK-WIDTH long on the left side of X-COORD; and TEXT
     and numeric legends are on the right.

 -- Function: rule-horizontal y-coord text tick-height
     Draws a horizontal ruler with Y coordinate Y-COORD and labeled with
     string TEXT.  If TICK-HEIGHT is positive, then the ticks are
     TICK-HEIGHT long on the top side of Y-COORD; and TEXT and numeric
     legends are on the bottom.  If TICK-HEIGHT is negative, then the
     ticks are -TICK-HEIGHT long on the bottom side of Y-COORD; and
     TEXT and numeric legends are on the top.

 -- Function: y-axis
     Draws the y-axis.

 -- Function: x-axis
     Draws the x-axis.

 -- Function: grid-verticals
     Draws vertical lines through `graphrect' at each tick on the
     vertical ruler.

 -- Function: grid-horizontals
     Draws horizontal lines through `graphrect' at each tick on the
     horizontal ruler.


File: slib-3b5.info,  Node: Legacy Plotting,  Next: Example Graph,  Prev: Legending,  Up: PostScript Graphing
                                                                              |
5.9.2.6 Legacy Plotting
.......................

 -- Variable: graph:dimensions
     A list of the width and height of the graph to be plotted using
     `plot'.

 -- Function: plot func x1 x2 npts
 -- Function: plot func x1 x2
     Creates and displays using `(system "gv tmp.eps")' an encapsulated
     PostScript graph of the function of one argument FUNC over the
     range X1 to X2.  If the optional integer argument NPTS is
     supplied, it specifies the number of points to evaluate FUNC at.

                                                                              |
 -- Function: plot x1 x2 npts func1 func2 ...                                 |
     Creates and displays an encapsulated PostScript graph of the
     one-argument functions FUNC1, FUNC2, ... over the range X1 to X2
     at NPTS points.


 -- Function: plot coords x-label y-label
     COORDS is a list or vector of coordinates, lists of x and y
     coordinates.  X-LABEL and Y-LABEL are strings with which to label
     the x and y axes.


File: slib-3b5.info,  Node: Example Graph,  Prev: Legacy Plotting,  Up: PostScript Graphing
                                                                              |
5.9.2.7 Example Graph
.....................

The file `am1.5.html', a table of solar irradiance, is fetched with
`wget' if it isn't already in the working directory.  The file is read
and stored into an array, IRRADIANCE.

  `create-postscript-graph' is then called to create an
encapsulated-PostScript file, `solarad.eps'.  The size of the page is
set to 600 by 300.  `whole-page' is called and leaves the rectangle on
the PostScript stack.  `setup-plot' is called with a literal range for
x and computes the range for column 1.

  Two calls to `top-title' are made so a different font can be used for
the lower half.  `in-graphic-context' is used to limit the scope of the
font change.  The graphing area is outlined and a rule drawn on the
left side.

  Because the X range was intentionally reduced, `in-graphic-context'
is called and `clip-to-rect' limits drawing to the plotting area.  A
black line is drawn from data column 1.  That line is then overlayed
with a mountain plot of the same column colored "Bright Sun".

  After returning from the `in-graphic-context', the bottom ruler is
drawn.  Had it been drawn earlier, all its ticks would have been
painted over by the mountain plot.

  The color is then changed to `seagreen' and the same graphrect is
setup again, this time with a different Y scale, 0 to 1000.  The
graphic context is again clipped to PLOTRECT, linedash is set, and
column 2 is plotted as a dashed line.  Finally the rightedge is ruled.
Having the line and its scale both in green helps disambiguate the
scales.

     (require 'eps-graph)
     (require 'line-i/o)
     (require 'string-port)

     (define irradiance
       (let ((url "http://www.pv.unsw.edu.au/am1.5.html")
             (file "am1.5.html"))
         (define (read->list line)
           (define elts '())
           (call-with-input-string line
             (lambda (iprt) (do ((elt (read iprt) (read iprt)))
                                ((eof-object? elt) elts)
                              (set! elts (cons elt elts))))))
         (if (not (file-exists? file))
             (system (string-append "wget -c -O" file " " url)))
         (call-with-input-file file
           (lambda (iprt)
             (define lines '())
             (do ((line (read-line iprt) (read-line iprt)))
                 ((eof-object? line)
                  (let ((nra (make-array (A:floR64b)
                                           (length lines)
                                           (length (car lines)))))
                    (do ((lns lines (cdr lns))
                         (idx (+ -1 (length lines)) (+ -1 idx)))
                        ((null? lns) nra)
                      (do ((kdx (+ -1 (length (car lines))) (+ -1 kdx))
                           (lst (car lns) (cdr lst)))
                          ((null? lst))
                        (array-set! nra (car lst) idx kdx)))))
               (if (and (positive? (string-length line))
                        (char-numeric? (string-ref line 0)))
                   (set! lines (cons (read->list line) lines))))))))

     (let ((xrange '(.25 2.5)))
       (create-postscript-graph
        "solarad.eps" '(600 300)
        (whole-page)
        (setup-plot xrange (column-range irradiance 1))
        (title-top
         "Solar Irradiance   http://www.pv.unsw.edu.au/am1.5.html")
        (in-graphic-context
         (set-font "Helvetica-Oblique" 12)
         (title-top
          ""
          "Key Centre for Photovoltaic Engineering UNSW - Air Mass 1.5 Global Spectrum"))
        (outline-rect plotrect)
        (rule-vertical leftedge "W/(m^2.um)" 10)
        (in-graphic-context (clip-to-rect plotrect)
                            (plot-column irradiance 0 1 'line)
                            (set-color "Bright Sun")
                            (plot-column irradiance 0 1 'mountain)
                            )
        (rule-horizontal bottomedge "Wavelength in .um" 5)
        (set-color 'seagreen)

        (setup-plot xrange '(0 1000) graphrect)
        (in-graphic-context (clip-to-rect plotrect)
                            (set-linedash 5 2)
                            (plot-column irradiance 0 2 'line))
        (rule-vertical rightedge "Integrated .W/(m^2)" -10)
        ))

     (system "gv solarad.eps")


File: slib-3b5.info,  Node: Solid Modeling,  Next: Color,  Prev: Graphing,  Up: Mathematical Packages
                                                                              |
5.10 Solid Modeling
===================

`(require 'solid)' 

`http://people.csail.mit.edu/jaffer/Solid/#Example' gives an example
use of this package.

 -- Function: vrml node ...
     Returns the VRML97 string (including header) of the concatenation
     of strings NODES, ....

 -- Function: vrml-append node1 node2 ...
     Returns the concatenation with interdigitated newlines of strings
     NODE1, NODE2, ....

 -- Function: vrml-to-file file node ...
     Writes to file named FILE the VRML97 string (including header) of
     the concatenation of strings NODES, ....

 -- Function: world:info title info ...
     Returns a VRML97 string setting the title of the file in which it
     appears to TITLE.  Additional strings INFO, ... are comments.

VRML97 strings passed to `vrml' and `vrml-to-file' as arguments will
appear in the resulting VRML code.  This string turns off the headlight
at the viewpoint:
     " NavigationInfo {headlight FALSE}"

 -- Function: scene:panorama front right back left top bottom
     Specifies the distant images on the inside faces of the cube
     enclosing the virtual world.

 -- Function: scene:sphere colors angles
     COLORS is a list of color objects.  Each may be of type *note
     color: Color Data-Type, a 24-bit sRGB integer, or a list of 3
     numbers between 0.0 and 1.0.

     ANGLES is a list of non-increasing angles the same length as
     COLORS.  Each angle is between 90 and -90 degrees.  If 90 or -90
     are not elements of ANGLES, then the color at the zenith and nadir
     are taken from the colors paired with the angles nearest them.

     `scene:sphere' fills horizontal bands with interpolated colors on
     the background sphere encasing the world.

 -- Function: scene:sky-and-dirt
     Returns a blue and brown background sphere encasing the world.

 -- Function: scene:sky-and-grass
     Returns a blue and green background sphere encasing the world.

 -- Function: scene:sun latitude julian-day hour turbidity strength
 -- Function: scene:sun latitude julian-day hour turbidity
     LATITUDE is the virtual place's latitude in degrees.  JULIAN-DAY
     is an integer from 0 to 366, the day of the year.  HOUR is a real
     number from 0 to 24 for the time of day; 12 is noon.  TURBIDITY is
     the degree of fogginess described in *Note turbidity: Daylight.

     `scene:sun' returns a bright yellow, distant sphere where the sun
     would be at HOUR on JULIAN-DAY at LATITUDE.  If STRENGTH is
     positive, included is a light source of STRENGTH (default 1).

 -- Function: scene:overcast latitude julian-day hour turbidity strength
 -- Function: scene:overcast latitude julian-day hour turbidity
     LATITUDE is the virtual place's latitude in degrees.  JULIAN-DAY
     is an integer from 0 to 366, the day of the year.  HOUR is a real
     number from 0 to 24 for the time of day; 12 is noon.  TURBIDITY is
     the degree of cloudiness described in *Note turbidity: Daylight.

     `scene:overcast' returns an overcast sky as it might look at HOUR
     on JULIAN-DAY at LATITUDE.  If STRENGTH is positive, included is
     an ambient light source of STRENGTH (default 1).

Viewpoints are objects in the virtual world, and can be transformed
individually or with solid objects.

 -- Function: scene:viewpoint name distance compass pitch
 -- Function: scene:viewpoint name distance compass
     Returns a viewpoint named NAME facing the origin and placed
     DISTANCE from it.  COMPASS is a number from 0 to 360 giving the
     compass heading.  PITCH is a number from -90 to 90, defaulting to
     0, specifying the angle from the horizontal.

 -- Function: scene:viewpoints proximity
     Returns 6 viewpoints, one at the center of each face of a cube
     with sides 2 * PROXIMITY, centered on the origin.

Light Sources
-------------

In VRML97, lights shine only on objects within the same children node
and descendants of that node.  Although it would have been convenient
to let light direction be rotated by `solid:rotation', this restricts a
rotated light's visibility to objects rotated with it.

To workaround this limitation, these directional light source
procedures accept either Cartesian or spherical coordinates for
direction.  A spherical coordinate is a list `(THETA AZIMUTH)'; where
THETA is the angle in degrees from the zenith, and AZIMUTH is the angle
in degrees due west of south.

It is sometimes useful for light sources to be brighter than `1'.  When
INTENSITY arguments are greater than 1, these functions gang multiple
sources to reach the desired strength.

 -- Function: light:ambient color intensity
 -- Function: light:ambient color
     Ambient light shines on all surfaces with which it is grouped.

     COLOR is a an object of type *note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.  INTENSITY is
     a real non-negative number defaulting to `1'.

     `light:ambient' returns a light source or sources of COLOR with
     total strength of INTENSITY (or 1 if omitted).

 -- Function: light:directional color direction intensity
 -- Function: light:directional color direction
 -- Function: light:directional color
     Directional light shines parallel rays with uniform intensity on
     all objects with which it is grouped.

     COLOR is a an object of type *note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.

     DIRECTION must be a list or vector of 2 or 3 numbers specifying
     the direction to this light.  If DIRECTION has 2 numbers, then
     these numbers are the angle from zenith and the azimuth in
     degrees; if DIRECTION has 3 numbers, then these are taken as a
     Cartesian vector specifying the direction to the light source.
     The default direction is upwards; thus its light will shine down.

     INTENSITY is a real non-negative number defaulting to `1'.

     `light:directional' returns a light source or sources of COLOR
     with total strength of INTENSITY, shining from DIRECTION.

 -- Function: light:beam attenuation radius aperture peak
 -- Function: light:beam attenuation radius aperture
 -- Function: light:beam attenuation radius
 -- Function: light:beam attenuation
     ATTENUATION is a list or vector of three nonnegative real numbers
     specifying the reduction of intensity, the reduction of intensity
     with distance, and the reduction of intensity as the square of
     distance.  RADIUS is the distance beyond which the light does not
     shine.  RADIUS defaults to `100'.

     APERTURE is a real number between 0 and 180, the angle centered on
     the light's axis through which it sheds some light.  PEAK is a
     real number between 0 and 90, the angle of greatest illumination.

 -- Function: light:point location color intensity beam
 -- Function: light:point location color intensity
 -- Function: light:point location color
 -- Function: light:point location
     Point light radiates from LOCATION, intensity decreasing with
     distance, towards all objects with which it is grouped.

     COLOR is a an object of type *note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.  INTENSITY is
     a real non-negative number defaulting to `1'.  BEAM is a structure
     returned by `light:beam' or #f.

     `light:point' returns a light source or sources at LOCATION of
     COLOR with total strength INTENSITY and BEAM properties.  Note
     that the pointlight itself is not visible.  To make it so, place
     an object with emissive appearance at LOCATION.

 -- Function: light:spot location direction color intensity beam
 -- Function: light:spot location direction color intensity
 -- Function: light:spot location direction color
 -- Function: light:spot location direction
 -- Function: light:spot location
     Spot light radiates from LOCATION towards DIRECTION, intensity
     decreasing with distance, illuminating objects with which it is
     grouped.

     DIRECTION must be a list or vector of 2 or 3 numbers specifying
     the direction to this light.  If DIRECTION has 2 numbers, then
     these numbers are the angle from zenith and the azimuth in
     degrees; if DIRECTION has 3 numbers, then these are taken as a
     Cartesian vector specifying the direction to the light source.
     The default direction is upwards; thus its light will shine down.

     COLOR is a an object of type *note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.

     INTENSITY is a real non-negative number defaulting to `1'.

     `light:spot' returns a light source or sources at LOCATION of
     DIRECTION with total strength COLOR.  Note that the spotlight
     itself is not visible.  To make it so, place an object with
     emissive appearance at LOCATION.

Object Primitives
-----------------

 -- Function: solid:box geometry appearance
 -- Function: solid:box geometry
     GEOMETRY must be a number or a list or vector of three numbers.
     If GEOMETRY is a number, the `solid:box' returns a cube with sides
     of length GEOMETRY centered on the origin.  Otherwise, `solid:box'
     returns a rectangular box with dimensions GEOMETRY centered on the
     origin.  APPEARANCE determines the surface properties of the
     returned object.

 -- Function: solid:lumber geometry appearance
     Returns a box of the specified GEOMETRY, but with the y-axis of a
     texture specified in APPEARANCE being applied along the longest
     dimension in GEOMETRY.

 -- Function: solid:cylinder radius height appearance
 -- Function: solid:cylinder radius height
     Returns a right cylinder with dimensions `(abs RADIUS)' and `(abs
     HEIGHT)' centered on the origin.  If HEIGHT is positive, then the
     cylinder ends will be capped.  If RADIUS is negative, then only
     the ends will appear.  APPEARANCE determines the surface
     properties of the returned object.

 -- Function: solid:disk radius thickness appearance
 -- Function: solid:disk radius thickness
     THICKNESS must be a positive real number.  `solid:disk' returns a
     circular disk with dimensions RADIUS and THICKNESS centered on the
     origin.  APPEARANCE determines the surface properties of the
     returned object.

 -- Function: solid:cone radius height appearance
 -- Function: solid:cone radius height
     Returns an isosceles cone with dimensions RADIUS and HEIGHT
     centered on the origin.  APPEARANCE determines the surface
     properties of the returned object.

 -- Function: solid:pyramid side height appearance
 -- Function: solid:pyramid side height
     Returns an isosceles pyramid with dimensions SIDE and HEIGHT
     centered on the origin.  APPEARANCE determines the surface
     properties of the returned object.

 -- Function: solid:sphere radius appearance
 -- Function: solid:sphere radius
     Returns a sphere of radius RADIUS centered on the origin.
     APPEARANCE determines the surface properties of the returned
     object.

 -- Function: solid:ellipsoid geometry appearance
 -- Function: solid:ellipsoid geometry
     GEOMETRY must be a number or a list or vector of three numbers.
     If GEOMETRY is a number, the `solid:ellipsoid' returns a sphere of
     diameter GEOMETRY centered on the origin.  Otherwise,
     `solid:ellipsoid' returns an ellipsoid with diameters GEOMETRY
     centered on the origin.  APPEARANCE determines the surface
     properties of the returned object.

 -- Function: solid:polyline coordinates appearance
 -- Function: solid:polyline coordinates
     COORDINATES must be a list or vector of coordinate lists or vectors
     specifying the x, y, and z coordinates of points.
     `solid:polyline' returns lines connecting successive pairs of
     points.  If called with one argument, then the polyline will be
     white.  If APPEARANCE is given, then the polyline will have its
     emissive color only; being black if APPEARANCE does not have an
     emissive color.

     The following code will return a red line between points at `(1 2
     3)' and `(4 5 6)':
          (solid:polyline '((1 2 3) (4 5 6)) (solid:color #f 0 #f 0 '(1 0 0)))

 -- Function: solid:prism xz-array y appearance
 -- Function: solid:prism xz-array y
     XZ-ARRAY must be an N-by-2 array holding a sequence of coordinates
     tracing a non-intersecting clockwise loop in the x-z plane.
     `solid:prism' will close the sequence if the first and last
     coordinates are not the same.

     `solid:prism' returns a capped prism Y long.

 -- Function: solid:basrelief width height depth colorray appearance
 -- Function: solid:basrelief width height depth appearance
 -- Function: solid:basrelief width height depth
     One of WIDTH, HEIGHT, or DEPTH must be a 2-dimensional array; the
     others must be real numbers giving the length of the basrelief in
     those dimensions.  The rest of this description assumes that
     HEIGHT is an array of heights.

     `solid:basrelief' returns a WIDTH by DEPTH basrelief solid with
     heights per array HEIGHT with the buttom surface centered on the
     origin.

     If present, APPEARANCE determines the surface properties of the
     returned object.  If present, COLORRAY must be an array of objects
     of type *note color: Color Data-Type, 24-bit sRGB integers or
     lists of 3 numbers between 0.0 and 1.0.

     If COLORRAY's dimensions match HEIGHT, then each element of
     COLORRAY paints its corresponding vertex of HEIGHT.  If COLORRAY
     has all dimensions one smaller than HEIGHT, then each element of
     COLORRAY paints the corresponding face of HEIGHT.  Other
     dimensions for COLORRAY are in error.

 -- Function: solid:text fontstyle str len appearance
 -- Function: solid:text fontstyle str len
     FONTSTYLE must be a value returned by `solid:font'.

     STR must be a string or list of strings.

     LEN must be #f, a nonnegative integer, or list of nonnegative
     integers.

     APPEARANCE, if given, determines the surface properties of the
     returned object.

     `solid:text' returns a two-sided, flat text object positioned in
     the Z=0 plane of the local coordinate system

Surface Attributes
------------------

 -- Function: solid:color diffuseColor ambientIntensity specularColor
          shininess emissiveColor transparency
 -- Function: solid:color diffuseColor ambientIntensity specularColor
          shininess emissiveColor
 -- Function: solid:color diffuseColor ambientIntensity specularColor
          shininess
 -- Function: solid:color diffuseColor ambientIntensity specularColor
 -- Function: solid:color diffuseColor ambientIntensity
 -- Function: solid:color diffuseColor
     Returns an "appearance", the optical properties of the objects with
     which it is associated.  AMBIENTINTENSITY, SHININESS, and
     TRANSPARENCY must be numbers between 0 and 1.  DIFFUSECOLOR,
     SPECULARCOLOR, and EMISSIVECOLOR are objects of type *note color:
     Color Data-Type, 24-bit sRGB integers or lists of 3 numbers
     between 0.0 and 1.0.  If a color argument is omitted or #f, then
     the default color will be used.

 -- Function: solid:texture image color scale rotation center
          translation
 -- Function: solid:texture image color scale rotation center
 -- Function: solid:texture image color scale rotation
 -- Function: solid:texture image color scale
 -- Function: solid:texture image color
 -- Function: solid:texture image
     Returns an "appearance", the optical properties of the objects with
     which it is associated.  IMAGE is a string naming a JPEG or PNG
     image resource.  COLOR is #f, a color, or the string returned by
     `solid:color'.  The rest of the optional arguments specify
     2-dimensional transforms applying to the IMAGE.

     SCALE must be #f, a number, or list or vector of 2 numbers
     specifying the scale to apply to IMAGE.  ROTATION must be #f or
     the number of degrees to rotate IMAGE.  CENTER must be #f or a
     list or vector of 2 numbers specifying the center of IMAGE
     relative to the IMAGE dimensions.  TRANSLATION must be #f or a
     list or vector of 2 numbers specifying the translation to apply to
     IMAGE.

 -- Function: solid:font family style justify size spacing language
          direction
     Returns a fontstyle object suitable for passing as an argument to
     `solid:text'.  Any of the arguments may be #f, in which case its
     default value, which is first in each list of allowed values, is
     used.

     FAMILY is a case-sensitive string naming a font; `SERIF', `SANS',
     and `TYPEWRITER' are supported at the minimum.

     STYLE is a case-sensitive string `PLAIN', `BOLD', `ITALIC', or
     `BOLDITALIC'.

     JUSTIFY is a case-sensitive string `FIRST', `BEGIN', `MIDDLE', or
     `END'; or a list of one or two case-sensitive strings (same
     choices).  The mechanics of JUSTIFY get complicated; it is
     explained by tables 6.2 to 6.7 of
     `http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-IS-VRML97WithAmendment1/part1/nodesRef.html#Table6.2'

     SIZE is the extent, in the non-advancing direction, of the text.
     SIZE defaults to 1.

     SPACING is the ratio of the line (or column) offset to SIZE.
     SPACING defaults to 1.

     LANGUAGE is the RFC-1766 language name.

     DIRECTION is a list of two numbers: `(X Y)'.  If
     `(> (abs X) (abs Y))', then the text will be arrayed horizontally;
     otherwise vertically.  The direction in which characters are
     arrayed is determined by the sign of the major axis: positive X
     being left-to-right; positive Y being top-to-bottom.

Aggregating Objects
-------------------

 -- Function: solid:center-row-of number solid spacing
     Returns a row of NUMBER SOLID objects spaced evenly SPACING apart.

 -- Function: solid:center-array-of number-a number-b solid spacing-a
          spacing-b
     Returns NUMBER-B rows, SPACING-B apart, of NUMBER-A SOLID objects
     SPACING-A apart.

 -- Function: solid:center-pile-of number-a number-b number-c solid
          spacing-a spacing-b spacing-c
     Returns NUMBER-C planes, SPACING-C apart, of NUMBER-B rows,
     SPACING-B apart, of NUMBER-A SOLID objects SPACING-A apart.

 -- Function: solid:arrow center
     CENTER must be a list or vector of three numbers.  Returns an
     upward pointing metallic arrow centered at CENTER.


 -- Function: solid:arrow
     Returns an upward pointing metallic arrow centered at the origin.

Spatial Transformations
-----------------------

 -- Function: solid:translation center solid ...
     CENTER must be a list or vector of three numbers.
     `solid:translation' Returns an aggregate of SOLIDS, ... with their
     origin moved to CENTER.

 -- Function: solid:scale scale solid ...
     SCALE must be a number or a list or vector of three numbers.
     `solid:scale' Returns an aggregate of SOLIDS, ... scaled per SCALE.

 -- Function: solid:rotation axis angle solid ...
     AXIS must be a list or vector of three numbers.  `solid:rotation'
     Returns an aggregate of SOLIDS, ... rotated ANGLE degrees around
     the axis AXIS.


File: slib-3b5.info,  Node: Color,  Next: Root Finding,  Prev: Solid Modeling,  Up: Mathematical Packages
                                                                              |
5.11 Color
==========

`http://people.csail.mit.edu/jaffer/Color'

The goals of this package are to provide methods to specify, compute,
and transform colors in a core set of additive color spaces.  The color
spaces supported should be sufficient for working with the color data
encountered in practice and the literature.

* Menu:

* Color Data-Type::             'color
* Color Spaces::                XYZ, L*a*b*, L*u*v*, L*C*h, RGB709, sRGB
* Spectra::                     Color Temperatures and CIEXYZ(1931)
* Color Difference Metrics::    Society of Dyers and Colorists
* Color Conversions::           Low-level
* Color Names::                 in relational databases
* Daylight::                    Sunlight and sky colors


File: slib-3b5.info,  Node: Color Data-Type,  Next: Color Spaces,  Prev: Color,  Up: Color
                                                                              |
5.11.1 Color Data-Type
----------------------

`(require 'color)'

 -- Function: color? obj
     Returns #t if OBJ is a color.

 -- Function: color? obj typ
     Returns #t if OBJ is a color of color-space TYP.  The symbol TYP
     must be one of:

        * CIEXYZ

        * RGB709

        * L*a*b*

        * L*u*v*

        * sRGB

        * e-sRGB

        * L*C*h

 -- Function: make-color space arg ...
     Returns a color of type SPACE.

        * For SPACE arguments `CIEXYZ', `RGB709', and `sRGB', the sole
          ARG is a list of three numbers.

        * For SPACE arguments `L*a*b*', `L*u*v*', and `L*C*h', ARG is a
          list of three numbers optionally followed by a whitepoint.

        * For `xRGB', ARG is an integer.

        * For `e-sRGB', the arguments are as for `e-sRGB->color'.

 -- Function: color-space color
     Returns the symbol for the color-space in which COLOR is embedded.

 -- Function: color-precision color
     For colors in digital color-spaces, `color-precision' returns the
     number of bits used for each of the R, G, and B channels of the
     encoding.  Otherwise, `color-precision' returns #f

 -- Function: color-white-point color
     Returns the white-point of COLOR in all color-spaces except CIEXYZ.

 -- Function: convert-color color space white-point
 -- Function: convert-color color space
 -- Function: convert-color color e-sRGB precision
     Converts COLOR into SPACE at optional WHITE-POINT.

5.11.1.1 External Representation
................................

Each color encoding has an external, case-insensitive representation.
To ensure portability, the white-point for all color strings is D65.
(1)

Color Space              External Representation
CIEXYZ                   CIEXYZ:<X>/<Y>/<Z>
RGB709                   RGBi:<R>/<G>/<B>
L*a*b*                   CIELAB:<L>/<a>/<b>
L*u*v*                   CIELuv:<L>/<u>/<v>
L*C*h                    CIELCh:<L>/<C>/<h>

The X, Y, Z, L, A, B, U, V, C, H, R, G, and B fields are (Scheme) real
numbers within the appropriate ranges.

Color Space              External Representation
sRGB                     sRGB:<R>/<G>/<B>
e-sRGB10                 e-sRGB10:<R>/<G>/<B>
e-sRGB12                 e-sRGB12:<R>/<G>/<B>
e-sRGB16                 e-sRGB16:<R>/<G>/<B>

The R, G, and B, fields are non-negative exact decimal integers within
the appropriate ranges.

Several additional syntaxes are supported by `string->color':

Color Space              External Representation
sRGB                     sRGB:<RRGGBB>
sRGB                     #<RRGGBB>
sRGB                     0x<RRGGBB>
sRGB                     #x<RRGGBB>

  Where RRGGBB is a non-negative six-digit hexadecimal number.

 -- Function: color->string color
     Returns a string representation of COLOR.

 -- Function: string->color string
     Returns the color represented by STRING.  If STRING is not a
     syntactically valid notation for a color, then `string->color'
     returns #f.

5.11.1.2 White
..............

We experience color relative to the illumination around us.  CIEXYZ
coordinates, although subject to uniform scaling, are objective.  Thus
other color spaces are specified relative to a "white point" in CIEXYZ
coordinates.  

The white point for digital color spaces is set to D65.  For the other
spaces a WHITE-POINT argument can be specified.  The default if none is
specified is the white-point with which the color was created or last
converted; and D65 if none has been specified.

 -- Constant: D65
     Is the color of 6500.K (blackbody) illumination.  D65 is close to
     the average color of daylight.

 -- Constant: D50
     Is the color of 5000.K (blackbody) illumination.  D50 is the color
     of indoor lighting by incandescent bulbs, whose filaments have
     temperatures around 5000.K.

  ---------- Footnotes ----------

  (1) Readers may recognize these color string formats from Xlib.
X11's color management system was doomed by its fiction that CRT
monitors' (and X11 default) color-spaces were linear RGBi.  Unable to
shed this legacy, the only practical way to view pictures on X is to
ignore its color management system and use an sRGB monitor.  In this
implementation the device-independent RGB709 and sRGB spaces replace the
device-dependent RGBi and RGB spaces of Xlib.


File: slib-3b5.info,  Node: Color Spaces,  Next: Spectra,  Prev: Color Data-Type,  Up: Color
                                                                              |
5.11.2 Color Spaces
-------------------

Measurement-based Color Spaces
..............................

The "tristimulus" color spaces are those whose component values are
proportional measurements of light intensity.  The CIEXYZ(1931) system
provides 3 sets of spectra to dot-product with a spectrum of interest.
The result of those dot-products is coordinates in CIEXYZ space.  All
tristimuls color spaces are related to CIEXYZ by linear transforms,
namely matrix multiplication.  Of the color spaces listed here, CIEXYZ
and RGB709 are tristimulus spaces.

 -- Color Space: CIEXYZ
     The CIEXYZ color space covers the full "gamut".  It is the basis
     for color-space conversions.

     CIEXYZ is a list of three inexact numbers between 0.0 and 1.1.
     '(0. 0. 0.) is black; '(1. 1. 1.) is white.

 -- Function: ciexyz->color xyz
     XYZ must be a list of 3 numbers.  If XYZ is valid CIEXYZ
     coordinates, then `ciexyz->color' returns the color specified by
     XYZ; otherwise returns #f.

 -- Function: color:ciexyz x y z
     Returns the CIEXYZ color composed of X, Y, Z.  If the coordinates
     do not encode a valid CIEXYZ color, then an error is signaled.

 -- Function: color->ciexyz color
     Returns the list of 3 numbers encoding COLOR in CIEXYZ.

 -- Color Space: RGB709
     BT.709-4 (03/00) `Parameter values for the HDTV standards for
     production and international programme exchange' specifies
     parameter values for chromaticity, sampling, signal format, frame
     rates, etc., of high definition television signals.

     An RGB709 color is represented by a list of three inexact numbers
     between 0.0 and 1.0.  '(0. 0. 0.) is black '(1. 1. 1.) is white.

 -- Function: rgb709->color rgb
     RGB must be a list of 3 numbers.  If RGB is valid RGB709
     coordinates, then `rgb709->color' returns the color specified by
     RGB; otherwise returns #f.

 -- Function: color:rgb709 r g b
     Returns the RGB709 color composed of R, G, B.  If the coordinates
     do not encode a valid RGB709 color, then an error is signaled.

 -- Function: color->rgb709 color
     Returns the list of 3 numbers encoding COLOR in RGB709.

Perceptual Uniformity
.....................

Although properly encoding the chromaticity, tristimulus spaces do not
match the logarithmic response of human visual systems to intensity.
Minimum detectable differences between colors correspond to a smaller
range of distances (6:1) in the L*a*b* and L*u*v* spaces than in
tristimulus spaces (80:1).  For this reason, color distances are
computed in L*a*b* (or L*C*h).

 -- Color Space: L*a*b*
     Is a CIE color space which better matches the human visual system's
     perception of color.  It is a list of three numbers:

        * 0 <= L* <= 100 (CIE "Lightness") 

        * -500 <= a* <= 500

        * -200 <= b* <= 200

 -- Function: l*a*b*->color L*a*b* white-point
     L*A*B* must be a list of 3 numbers.  If L*A*B* is valid L*a*b*
     coordinates, then `l*a*b*->color' returns the color specified by
     L*A*B*; otherwise returns #f.

 -- Function: color:l*a*b* L* a* b* white-point
     Returns the L*a*b* color composed of L*, A*, B* with WHITE-POINT.


 -- Function: color:l*a*b* L* a* b*
     Returns the L*a*b* color composed of L*, A*, B*.  If the
     coordinates do not encode a valid L*a*b* color, then an error is
     signaled.

 -- Function: color->l*a*b* color white-point
     Returns the list of 3 numbers encoding COLOR in L*a*b* with
     WHITE-POINT.


 -- Function: color->l*a*b* color
     Returns the list of 3 numbers encoding COLOR in L*a*b*.

 -- Color Space: L*u*v*
     Is another CIE encoding designed to better match the human visual
     system's perception of color.

 -- Function: l*u*v*->color L*u*v* white-point
     L*U*V* must be a list of 3 numbers.  If L*U*V* is valid L*u*v*
     coordinates, then `l*u*v*->color' returns the color specified by
     L*U*V*; otherwise returns #f.

 -- Function: color:l*u*v* L* u* v* white-point
     Returns the L*u*v* color composed of L*, U*, V* with WHITE-POINT.


 -- Function: color:l*u*v* L* u* v*
     Returns the L*u*v* color composed of L*, U*, V*.  If the
     coordinates do not encode a valid L*u*v* color, then an error is
     signaled.

 -- Function: color->l*u*v* color white-point
     Returns the list of 3 numbers encoding COLOR in L*u*v* with
     WHITE-POINT.


 -- Function: color->l*u*v* color
     Returns the list of 3 numbers encoding COLOR in L*u*v*.

Cylindrical Coordinates
.......................

HSL (Hue Saturation Lightness), HSV (Hue Saturation Value), HSI (Hue
Saturation Intensity) and HCI (Hue Chroma Intensity) are cylindrical
color spaces (with angle hue).  But these spaces are all defined in
terms device-dependent RGB spaces.

One might wonder if there is some fundamental reason why intuitive
specification of color must be device-dependent.  But take heart!  A
cylindrical system can be based on L*a*b* and is used for predicting how
close colors seem to observers.

 -- Color Space: L*C*h
     Expresses the *a and b* of L*a*b* in polar coordinates.  It is a
     list of three numbers:

        * 0 <= L* <= 100 (CIE "Lightness") 

        * C* (CIE "Chroma") is the distance from the neutral (gray)
          axis.  

        * 0 <= h <= 360 (CIE "Hue") is the angle.  

     The colors by quadrant of h are:

     0             red, orange, yellow                      90
     90            yellow, yellow-green, green              180
     180           green, cyan (blue-green), blue           270
     270           blue, purple, magenta                    360


 -- Function: l*c*h->color L*C*h white-point
     L*C*H must be a list of 3 numbers.  If L*C*H is valid L*C*h
     coordinates, then `l*c*h->color' returns the color specified by
     L*C*H; otherwise returns #f.

 -- Function: color:l*c*h L* C* h white-point
     Returns the L*C*h color composed of L*, C*, H with WHITE-POINT.


 -- Function: color:l*c*h L* C* h
     Returns the L*C*h color composed of L*, C*, H.  If the coordinates
     do not encode a valid L*C*h color, then an error is signaled.

 -- Function: color->l*c*h color white-point
     Returns the list of 3 numbers encoding COLOR in L*C*h with
     WHITE-POINT.


 -- Function: color->l*c*h color
     Returns the list of 3 numbers encoding COLOR in L*C*h.

Digital Color Spaces
....................

The color spaces discussed so far are impractical for image data because
of numerical precision and computational requirements.  In 1998 the IEC
adopted `A Standard Default Color Space for the Internet - sRGB'
(`http://www.w3.org/Graphics/Color/sRGB').  sRGB was cleverly designed
to employ the 24-bit (256x256x256) color encoding already in widespread
use; and the 2.2 gamma intrinsic to CRT monitors.

Conversion from CIEXYZ to digital (sRGB) color spaces is accomplished by
conversion first to a RGB709 tristimulus space with D65 white-point;
then each coordinate is individually subjected to the same non-linear
mapping.  Inverse operations in the reverse order create the inverse
transform.

 -- Color Space: sRGB
     Is "A Standard Default Color Space for the Internet".  Most display
     monitors will work fairly well with sRGB directly.  Systems using
     ICC profiles (1) should work very well with sRGB.


 -- Function: srgb->color rgb
     RGB must be a list of 3 numbers.  If RGB is valid sRGB coordinates,
     then `srgb->color' returns the color specified by RGB; otherwise
     returns #f.

 -- Function: color:srgb r g b
     Returns the sRGB color composed of R, G, B.  If the coordinates do
     not encode a valid sRGB color, then an error is signaled.

 -- Color Space: xRGB
     Represents the equivalent sRGB color with a single 24-bit integer.
     The most significant 8 bits encode red, the middle 8 bits blue,
     and the least significant 8 bits green.

 -- Function: color->srgb color
     Returns the list of 3 integers encoding COLOR in sRGB.

 -- Function: color->xrgb color
     Returns the 24-bit integer encoding COLOR in sRGB.

 -- Function: xrgb->color k
     Returns the sRGB color composed of the 24-bit integer K.

 -- Color Space: e-sRGB
     Is "Photography - Electronic still picture imaging - Extended sRGB
     color encoding" (PIMA 7667:2001).  It extends the gamut of sRGB;
     and its higher precision numbers provide a larger dynamic range.

     A triplet of integers represent e-sRGB colors.  Three precisions
     are supported:

    e-sRGB10
          0 to 1023

    e-sRGB12
          0 to 4095

    e-sRGB16
          0 to 65535

 -- Function: e-srgb->color precision rgb
     PRECISION must be the integer 10, 12, or 16.  RGB must be a list
     of 3 numbers.  If RGB is valid e-sRGB coordinates, then
     `e-srgb->color' returns the color specified by RGB; otherwise
     returns #f.

 -- Function: color:e-srgb 10 r g b
     Returns the e-sRGB10 color composed of integers R, G, B.


 -- Function: color:e-srgb 12 r g b
     Returns the e-sRGB12 color composed of integers R, G, B.


 -- Function: color:e-srgb 16 r g b
     Returns the e-sRGB16 color composed of integers R, G, B.  If the
     coordinates do not encode a valid e-sRGB color, then an error is
     signaled.

 -- Function: color->e-srgb precision color
     PRECISION must be the integer 10, 12, or 16.  `color->e-srgb'
     returns the list of 3 integers encoding COLOR in sRGB10, sRGB12,
     or sRGB16.

  ---------- Footnotes ----------

  (1) A comprehensive encoding of transforms between CIEXYZ and device
color spaces is the International Color Consortium profile format,
ICC.1:1998-09:

     The intent of this format is to provide a cross-platform device
     profile format.  Such device profiles can be used to translate
     color data created on one device into another device's native
     color space.


File: slib-3b5.info,  Node: Spectra,  Next: Color Difference Metrics,  Prev: Color Spaces,  Up: Color
                                                                              |
5.11.3 Spectra
--------------

The following functions compute colors from spectra, scale color
luminance, and extract chromaticity.  XYZ is used in the names of
procedures for unnormalized colors; the coordinates of CIEXYZ colors are
constrained as described in *note Color Spaces::.

  `(require 'color-space)'

A spectrum may be represented as:

   * A procedure of one argument accepting real numbers from 380e-9 to
     780e-9, the wavelength in meters; or

   * A vector of real numbers representing intensity samples evenly
     spaced over some range of wavelengths overlapping the range 380e-9
     to 780e-9.

CIEXYZ values are calculated as dot-product with the X, Y (Luminance),
and Z "Spectral Tristimulus Values".  The files `cie1931.xyz' and
`cie1964.xyz' in the distribution contain these CIE-defined values.  

 -- Feature: cie1964
     Loads the Spectral Tristimulus Values `CIE 1964 Supplementary
     Standard Colorimetric Observer', defining CIE:X-BAR, CIE:Y-BAR,
     and CIE:Z-BAR.

 -- Feature: cie1931
     Loads the Spectral Tristimulus Values `CIE 1931 Supplementary
     Standard Colorimetric Observer', defining CIE:X-BAR, CIE:Y-BAR,
     and CIE:Z-BAR.

 -- Feature: ciexyz
     Requires Spectral Tristimulus Values, defaulting to cie1931,
     defining CIE:X-BAR, CIE:Y-BAR, and CIE:Z-BAR.

`(require 'cie1964)' or `(require 'cie1931)' will `load-ciexyz'
specific values used by the following spectrum conversion procedures.
The spectrum conversion procedures `(require 'ciexyz)' to assure that a
set is loaded.

 -- Function: read-cie-illuminant path
     PATH must be a string naming a file consisting of 107 numbers for
     5.nm intervals from 300.nm to 830.nm.  `read-cie-illuminant' reads
     (using Scheme `read') these numbers and returns a length 107
     vector filled with them.

     (define CIE:SI-D65
       (read-CIE-illuminant (in-vicinity (library-vicinity) "ciesid65.dat")))
     (spectrum->XYZ CIE:SI-D65 300e-9 830e-9)
     => (25.108569422374994 26.418013465625001 28.764075683374993)

 -- Function: read-normalized-illuminant path
     PATH must be a string naming a file consisting of 107 numbers for
     5.nm intervals from 300.nm to 830.nm.
     `read-normalized-illuminant' reads (using Scheme `read') these
     numbers and returns a length 107 vector filled with them,
     normalized so that `spectrum->XYZ' of the illuminant returns its
     whitepoint.

  CIE Standard Illuminants A and D65 are included with SLIB:

     (define CIE:SI-A
       (read-normalized-illuminant (in-vicinity (library-vicinity) "ciesia.dat")))
     (define CIE:SI-D65
       (read-normalized-illuminant (in-vicinity (library-vicinity) "ciesid65.dat")))
     (spectrum->XYZ CIE:SI-A 300e-9 830e-9)
     => (1.098499460820401 999.9999999999998e-3 355.8173930654951e-3)
     (CIEXYZ->sRGB (spectrum->XYZ CIE:SI-A 300e-9 830e-9))
     => (255 234 133)
     (spectrum->XYZ CIE:SI-D65 300e-9 830e-9)
     => (950.4336673552745e-3 1.0000000000000002 1.0888053986649182)
     (CIEXYZ->sRGB (spectrum->XYZ CIE:SI-D65 300e-9 830e-9))
     => (255 255 255)

 -- Function: illuminant-map proc siv
     SIV must be a one-dimensional array or vector of 107 numbers.
     `illuminant-map' returns a vector of length 107 containing the
     result of applying PROC to each element of SIV.

 -- Function: illuminant-map->XYZ proc siv
     `(spectrum->XYZ (illuminant-map PROC SIV) 300e-9 830e-9)'

 -- Function: spectrum->XYZ proc
     PROC must be a function of one argument.  `spectrum->XYZ' computes
     the CIEXYZ(1931) values for the spectrum returned by PROC when
     called with arguments from 380e-9 to 780e-9, the wavelength in
     meters.

 -- Function: spectrum->XYZ spectrum x1 x2
     X1 and X2 must be positive real numbers specifying the wavelengths
     (in meters) corresponding to the zeroth and last elements of
     vector or list SPECTRUM.  `spectrum->XYZ' returns the CIEXYZ(1931)
     values for a light source with spectral values proportional to the
     elements of SPECTRUM at evenly spaced wavelengths between X1 and
     X2.

     Compute the colors of 6500.K and 5000.K blackbody radiation:

          (require 'color-space)
          (define xyz (spectrum->XYZ (blackbody-spectrum 6500)))
          (define y_n (cadr xyz))
          (map (lambda (x) (/ x y_n)) xyz)
              => (0.9687111145512467 1.0 1.1210875945303613)

          (define xyz (spectrum->XYZ (blackbody-spectrum 5000)))
          (map (lambda (x) (/ x y_n)) xyz)
              => (0.2933441826889158 0.2988931825387761 0.25783646831201573)

 -- Function: spectrum->chromaticity proc
 -- Function: spectrum->chromaticity spectrum x1 x2
     Computes the chromaticity for the given spectrum.

 -- Function: wavelength->XYZ w
     W must be a number between 380e-9 to 780e-9.  `wavelength->XYZ'
     returns (unnormalized) XYZ values for a monochromatic light source
     with wavelength W.

 -- Function: wavelength->chromaticity w
     W must be a number between 380e-9 to 780e-9.
     `wavelength->chromaticity' returns the chromaticity for a
     monochromatic light source with wavelength W.

 -- Function: blackbody-spectrum temp
 -- Function: blackbody-spectrum temp span
     Returns a procedure of one argument (wavelength in meters), which
     returns the radiance of a black body at TEMP.

     The optional argument SPAN is the wavelength analog of bandwidth.
     With the default SPAN of 1.nm (1e-9.m), the values returned by the
     procedure correspond to the power of the photons with wavelengths
     W to W+1e-9.

 -- Function: temperature->XYZ x
     The positive number X is a temperature in degrees kelvin.
     `temperature->XYZ' computes the unnormalized CIEXYZ(1931) values
     for the spectrum of a black body at temperature X.

     Compute the chromaticities of 6500.K and 5000.K blackbody
     radiation:

          (require 'color-space)
          (XYZ->chromaticity (temperature->XYZ 6500))
              => (0.3135191660557008 0.3236456786200268)

          (XYZ->chromaticity (temperature->XYZ 5000))
              => (0.34508082841161052 0.3516084965163377)

 -- Function: temperature->chromaticity x
     The positive number X is a temperature in degrees kelvin.
     `temperature->cromaticity' computes the chromaticity for the
     spectrum of a black body at temperature X.

     Compute the chromaticities of 6500.K and 5000.K blackbody
     radiation:

          (require 'color-space)
          (temperature->chromaticity 6500)
              => (0.3135191660557008 0.3236456786200268)

          (temperature->chromaticity 5000)
              => (0.34508082841161052 0.3516084965163377)

 -- Function: XYZ->chromaticity xyz
     Returns a two element list: the x and y components of XYZ
     normalized to 1 (= X + Y + Z).

 -- Function: chromaticity->CIEXYZ x y
     Returns the list of X, and Y, 1 - Y - X.

 -- Function: chromaticity->whitepoint x y
     Returns the CIEXYZ(1931) values having luminosity 1 and
     chromaticity X and Y.

Many color datasets are expressed in "xyY" format; chromaticity with
CIE luminance (Y).  But xyY is not a CIE standard like CIEXYZ, CIELAB,
and CIELUV.  Although chrominance is well defined, the luminance
component is sometimes scaled to 1, sometimes to 100, but usually has no
obvious range.  With no given whitepoint, the only reasonable course is
to ascertain the luminance range of a dataset and normalize the values
to lie from 0 to 1.

 -- Function: XYZ->xyY xyz
     Returns a three element list: the X and Y components of XYZ
     normalized to 1, and CIE luminance Y.

 -- Function: xyY->XYZ xyY

 -- Function: xyY:normalize-colors colors
     COLORS is a list of xyY triples.  `xyY:normalize-colors' scales
     each chromaticity so it sums to 1 or less; and divides the Y
     values by the maximum Y in the dataset, so all lie between 0 and 1.

 -- Function: xyY:normalize-colors colors n
     If N is positive real, then `xyY:normalize-colors' divides the Y
     values by N times the maximum Y in the dataset.

     If N is an exact non-positive integer, then `xyY:normalize-colors'
     divides the Y values by the maximum of the Ys in the dataset
     excepting the -N largest Y values.

     In all cases, returned Y values are limited to lie from 0 to 1.

Why would one want to normalize to other than 1?  If the sun or its
reflection is the brightest object in a scene, then normalizing to its
luminance will tend to make the rest of the scene very dark.  As with
photographs, limiting the specular highlights looks better than
darkening everything else.

The results of measurements being what they are, `xyY:normalize-colors'
is extremely tolerant.  Negative numbers are replaced with zero, and
chromaticities with sums greater than one are scaled to sum to one.


File: slib-3b5.info,  Node: Color Difference Metrics,  Next: Color Conversions,  Prev: Spectra,  Up: Color
                                                                              |
5.11.4 Color Difference Metrics
-------------------------------

`(require 'color-space)'

  The low-level metric functions operate on lists of 3 numbers, lab1,
lab2, lch1, or lch2.

  `(require 'color)'

  The wrapped functions operate on objects of type color, color1 and
color2 in the function entries.

 -- Function: L*a*b*:DE* lab1 lab2
     Returns the Euclidean distance between LAB1 and LAB2.

 -- Function: CIE:DE* color1 color2 white-point
 -- Function: CIE:DE* color1 color2
     Returns the Euclidean distance in L*a*b* space between COLOR1 and
     COLOR2.

 -- Function: L*a*b*:DE*94 lab1 lab2 parametric-factors                       |
 -- Function: L*a*b*:DE*94 lab1 lab2                                          |
 -- Function: CIE:DE*94 color1 color2 parametric-factors
 -- Function: CIE:DE*94 color1 color2
     Measures distance in the L*a*b* color-space.  The three axes are         |
     individually scaled in their contributions to the total distance.        |
                                                                              |
     `DE*94' is not symmetrical in its arguments.  LAB1 is the                |
     "reference" color and LAB2 is the "sample" color.                        |

     The CIE has defined reference conditions under which the metric
     with default parameters can be expected to perform well.  These
     are:

        * The specimens are homogeneous in colour.

        * The colour difference (CIELAB) is <= 5 units.

        * They are placed in direct edge contact.

        * Each specimen subtends an angle of >4 degrees to the
          assessor, whose colour vision is normal.

        * They are illuminated at 1000 lux, and viewed against a
          background of uniform grey, with L* of 50, under illumination
          simulating D65.

     The PARAMETRIC-FACTORS argument is a list of 3 quantities kL, kC
     and kH.  PARAMETRIC-FACTORS independently adjust each
     colour-difference term to account for any deviations from the
     reference viewing conditions.  Under the reference conditions
     explained above, the default is kL = kC = kH = 1.

The Color Measurement Committee of The Society of Dyers and Colorists in
Great Britain created a more sophisticated color-distance function for
use in judging the consistency of dye lots.  With CMC:DE* it is possible
to use a single value pass/fail tolerance for all shades.

 -- Function: CMC-DE lch1 lch2 parametric-factors
 -- Function: CMC-DE lch1 lch2 l c
 -- Function: CMC-DE lch1 lch2 l
 -- Function: CMC-DE lch1 lch2
 -- Function: CMC:DE* color1 color2 l c
 -- Function: CMC:DE* color1 color2
     `CMC:DE' is a L*C*h metric.  The PARAMETRIC-FACTORS argument is a
     list of 2 numbers L and C.  L and C parameterize this metric.  1
     and 1 are recommended for perceptibility; the default, 2 and 1,
     for acceptability.


File: slib-3b5.info,  Node: Color Conversions,  Next: Color Names,  Prev: Color Difference Metrics,  Up: Color
                                                                              |
5.11.5 Color Conversions
------------------------

This package contains the low-level color conversion and color metric
routines operating on lists of 3 numbers.  There is no type or range
checking.

  `(require 'color-space)'

 -- Constant: CIEXYZ:D65
     Is the color of 6500.K (blackbody) illumination.  D65 is close to
     the average color of daylight.

 -- Constant: CIEXYZ:D50
     Is the color of 5000.K (blackbody) illumination.  D50 is the color
     of indoor lighting by incandescent bulbs.

 -- Constant: CIEXYZ:A
 -- Constant: CIEXYZ:B
 -- Constant: CIEXYZ:C
 -- Constant: CIEXYZ:E
     CIE 1931 illuminants normalized to 1 = y.

 -- Function: color:linear-transform matrix row

 -- Function: CIEXYZ->RGB709 xyz
 -- Function: RGB709->CIEXYZ srgb

 -- Function: CIEXYZ->L*u*v* xyz white-point
 -- Function: CIEXYZ->L*u*v* xyz
 -- Function: L*u*v*->CIEXYZ L*u*v* white-point
 -- Function: L*u*v*->CIEXYZ L*u*v*
     The WHITE-POINT defaults to CIEXYZ:D65.

 -- Function: CIEXYZ->L*a*b* xyz white-point
 -- Function: CIEXYZ->L*a*b* xyz
 -- Function: L*a*b*->CIEXYZ L*a*b* white-point
 -- Function: L*a*b*->CIEXYZ L*a*b*
     The XYZ WHITE-POINT defaults to CIEXYZ:D65.

 -- Function: L*a*b*->L*C*h L*a*b*
 -- Function: L*C*h->L*a*b* L*C*h

 -- Function: CIEXYZ->sRGB xyz
 -- Function: sRGB->CIEXYZ srgb

 -- Function: CIEXYZ->xRGB xyz
 -- Function: xRGB->CIEXYZ srgb

 -- Function: sRGB->xRGB xyz
 -- Function: xRGB->sRGB srgb

 -- Function: CIEXYZ->e-sRGB n xyz
 -- Function: e-sRGB->CIEXYZ n srgb

 -- Function: sRGB->e-sRGB n srgb
 -- Function: e-sRGB->sRGB n srgb
     The integer N must be 10, 12, or 16.  Because sRGB and e-sRGB use
     the same RGB709 chromaticities, conversion between them is simpler
     than conversion through CIEXYZ.

Do not convert e-sRGB precision through `e-sRGB->sRGB' then
`sRGB->e-sRGB' - values would be truncated to 8-bits!

 -- Function: e-sRGB->e-sRGB n1 srgb n2
     The integers N1 and N2 must be 10, 12, or 16.  `e-sRGB->e-sRGB'
     converts SRGB to e-sRGB of precision N2.


File: slib-3b5.info,  Node: Color Names,  Next: Daylight,  Prev: Color Conversions,  Up: Color
                                                                              |
5.11.6 Color Names
------------------

`(require 'color-names)' 

Rather than ballast the color dictionaries with numbered grays,
`file->color-dictionary' discards them.  They are provided through the
`grey' procedure:

 -- Function: grey k
     Returns `(inexact->exact (round (* k 2.55)))', the X11 color
     grey<k>.

A color dictionary is a database table relating "canonical" color-names
to color-strings (*note External Representation: Color Data-Type.).

The column names in a color dictionary are unimportant; the first field
is the key, and the second is the color-string.

 -- Function: color-name:canonicalize name
     Returns a downcased copy of the string or symbol NAME with `_',
     `-', and whitespace removed.

 -- Function: color-name->color name table1 table2 ...
     TABLE1, TABLE2, ... must be color-dictionary tables.
     `color-name->color' searches for the canonical form of NAME in
     TABLE1, TABLE2, ... in order; returning the color-string of the
     first matching record; #f otherwise.

 -- Function: color-dictionaries->lookup table1 table2 ...
     TABLE1, TABLE2, ... must be color-dictionary tables.
     `color-dictionaries->lookup' returns a procedure which searches
     for the canonical form of its string argument in TABLE1, TABLE2,
     ...; returning the color-string of the first matching record; and
     #f otherwise.

 -- Function: color-dictionary name rdb base-table-type
     RDB must be a string naming a relational database file; and the
     symbol NAME a table therein.  The database will be opened as
     BASE-TABLE-TYPE.  `color-dictionary' returns the read-only table
     NAME in database NAME if it exists; #f otherwise.


 -- Function: color-dictionary name rdb
     RDB must be an open relational database or a string naming a
     relational database file; and the symbol NAME a table therein.
     `color-dictionary' returns the read-only table NAME in database
     NAME if it exists; #f otherwise.

 -- Function: load-color-dictionary name rdb base-table-type
 -- Function: load-color-dictionary name rdb
     RDB must be a string naming a relational database file; and the
     symbol NAME a table therein.  If the symbol BASE-TABLE-TYPE is
     provided, the database will be opened as BASE-TABLE-TYPE.
     `load-color-dictionary' creates a top-level definition of the
     symbol NAME to a lookup procedure for the color dictionary NAME in
     RDB.

     The value returned by `load-color-dictionary' is unspecified.

Dictionary Creation
...................

`(require 'color-database)' 

 -- Function: file->color-dictionary file table-name rdb base-table-type
 -- Function: file->color-dictionary file table-name rdb
     RDB must be an open relational database or a string naming a
     relational database file, TABLE-NAME a symbol, and the string FILE
     must name an existing file with colornames and their corresponding
     xRGB (6-digit hex) values.  `file->color-dictionary' creates a
     table TABLE-NAME in RDB and enters the associations found in FILE
     into it.

 -- Function: url->color-dictionary url table-name rdb base-table-type
 -- Function: url->color-dictionary url table-name rdb
     RDB must be an open relational database or a string naming a
     relational database file and TABLE-NAME a symbol.
     `url->color-dictionary' retrieves the resource named by the string
     URL using the "wget" program; then calls `file->color-dictionary'
     to enter its associations in TABLE-NAME in URL.

This section has detailed the procedures for creating and loading color
dictionaries.  So where are the dictionaries to load?

  `http://people.csail.mit.edu/jaffer/Color/Dictionaries.html'

Describes and evaluates several color-name dictionaries on the web.
The following procedure creates a database containing two of these
dictionaries.

 -- Function: make-slib-color-name-db
     Creates an alist-table relational database in library-vicinity
     containing the "Resene" and "saturate" color-name dictionaries.

     If the files `resenecolours.txt', `nbs-iscc.txt', and
     `saturate.txt' exist in the library-vicinity, then they used as
     the source of color-name data.  Otherwise,
     `make-slib-color-name-db' calls url->color-dictionary with the
     URLs of appropriate source files.

The Short List
..............

`(require 'saturate)' 

 -- Function: saturate name
     Looks for NAME among the 19 saturated colors from `Approximate
     Colors on CIE Chromaticity Diagram':

     reddish orange    orange            yellowish orange  yellow
     greenish yellow   yellow green      yellowish green   green
     bluish green      blue green        greenish blue     blue
     purplish blue     bluish purple     purple            reddish purple
     red purple        purplish red      red               

     (`http://people.csail.mit.edu/jaffer/Color/saturate.pdf').  If
     NAME is found, the corresponding color is returned.  Otherwise #f
     is returned.  Use saturate only for light source colors.

Resene Paints Limited, New Zealand's largest privately-owned and
operated paint manufacturing company, has generously made their `Resene
RGB Values List' available.

  `(require 'resene)' 

 -- Function: resene name
     Looks for NAME among the 1300 entries in the Resene color-name
     dictionary (`http://people.csail.mit.edu/jaffer/Color/resene.pdf').
     If NAME is found, the corresponding color is returned.  Otherwise
     #f is returned.  The `Resene RGB Values List' is an excellent
     source for surface colors.

If you include the "Resene RGB Values List" in binary form in a
program, then you must include its license with your program:

     Resene RGB Values List
     For further information refer to http://www.resene.co.nz
     Copyright Resene Paints Ltd 2001

     Permission to copy this dictionary, to modify it, to redistribute
     it, to distribute modified versions, and to use it for any purpose
     is granted, subject to the following restrictions and
     understandings.

       1. Any text copy made of this dictionary must include this
          copyright notice in full.

       2. Any redistribution in binary form must reproduce this
          copyright notice in the documentation or other materials
          provided with the distribution.

       3. Resene Paints Ltd makes no warranty or representation that
          this dictionary is error-free, and is under no obligation to
          provide any services, by way of maintenance, update, or
          otherwise.

       4. There shall be no use of the name of Resene or Resene Paints
          Ltd in any advertising, promotional, or sales literature
          without prior written consent in each case.

       5. These RGB colour formulations may not be used to the
          detriment of Resene Paints Ltd.


File: slib-3b5.info,  Node: Daylight,  Prev: Color Names,  Up: Color
                                                                              |
5.11.7 Daylight
---------------

`(require 'daylight)' 

This package calculates the colors of sky as detailed in:
`http://www.cs.utah.edu/vissim/papers/sunsky/sunsky.pdf'
`A Practical Analytic Model for Daylight'
A. J. Preetham, Peter Shirley, Brian Smits

 -- Function: solar-hour julian-day hour
     Returns the solar-time in hours given the integer JULIAN-DAY in
     the range 1 to 366, and the local time in hours.

     To be meticulous, subtract 4 minutes for each degree of longitude
     west of the standard meridian of your time zone.

 -- Function: solar-declination julian-day

 -- Function: solar-polar declination latitude solar-hour
     Returns a list of THETA_S, the solar angle from the zenith, and
     PHI_S, the solar azimuth.  0 <= THETA_S measured in degrees.
     PHI_S is measured in degrees from due south; west of south being
     positive.

In the following procedures, the number 0 <= THETA_S <= 90 is the solar
angle from the zenith in degrees.

Turbidity is a measure of the fraction of scattering due to haze as
opposed to molecules.  This is a convenient quantity because it can be
estimated based on visibility of distant objects.  This model fails for
turbidity values less than 1.3.

         _______________________________________________________________
     512|-:                                                             |
        | * pure-air                                                    |
     256|-:**                                                           |
        | : ** exceptionally-clear                                      |
     128|-:   *                                                         |
        | :    **                                                       |
      64|-:      *                                                      |
        | :       ** very-clear                                         |
      32|-:         **                                                  |
        | :           **                                                |
      16|-:             *** clear                                       |
        | :               ****                                          |
       8|-:                  ****                                       |
        | :                     **** light-haze                         |
       4|-:                         ****                                |
        | :                             ******                          |
       2|-:                                  ******** haze         thin-|
        | :                                          ***********    fog |
       1|-:----------------------------------------------------*******--|
        |_:____.____:____.____:____.____:____.____:____.____:____.____:_|
          1         2         4         8        16        32        64
                   Meterorological range (km) versus Turbidity

 -- Function: sunlight-spectrum turbidity theta_s
     Returns a vector of 41 values, the spectrum of sunlight from
     380.nm to 790.nm for a given TURBIDITY and THETA_S.

 -- Function: sunlight-chromaticity turbidity theta_s
     Given TURBIDITY and THETA_S, `sunlight-chromaticity' returns the
     CIEXYZ triple for color of sunlight scaled to be just inside the
     RGB709 gamut.

 -- Function: zenith-xyy turbidity theta_s
     Returns the xyY (chromaticity and luminance) at the zenith.  The
     Luminance has units kcd/m^2.

 -- Function: overcast-sky-color-xyy turbidity theta_s
     TURBIDITY is a positive real number expressing the amount of light
     scattering.  The real number THETA_S is the solar angle from the
     zenith in degrees.

     `overcast-sky-color-xyy' returns a function of one angle THETA,
     the angle from the zenith of the viewing direction (in degrees);
     and returning the xyY value for light coming from that elevation
     of the sky.

 -- Function: clear-sky-color-xyy turbidity theta_s phi_s
 -- Function: sky-color-xyy turbidity theta_s phi_s
     TURBIDITY is a positive real number expressing the amount of light
     scattering.  The real number THETA_S is the solar angle from the
     zenith in degrees.  The real number PHI_S is the solar angle from
     south.

     `clear-sky-color-xyy' returns a function of two angles, THETA and
     PHI which specify the angles from the zenith and south meridian of
     the viewing direction (in degrees); returning the xyY value for
     light coming from that direction of the sky.

     `sky-color-xyY' calls `overcast-sky-color-xyY' for TURBIDITY <=
     20; otherwise the `clear-sky-color-xyy' function.


File: slib-3b5.info,  Node: Root Finding,  Next: Minimizing,  Prev: Color,  Up: Mathematical Packages
                                                                              |
5.12 Root Finding
=================

`(require 'root)' 

  In the Newton method, divide the DF/DX argument by the multiplicity         |
of the desired root in order to preserve quadratic convergence.               |
                                                                              |
 -- Function: newton:find-integer-root f df/dx x0
     Given integer valued procedure F, its derivative (with respect to
     its argument) DF/DX, and initial integer value X0 for which
     DF/DX(X0) is non-zero, returns an integer X for which F(X) is
     closer to zero than either of the integers adjacent to X; or
     returns `#f' if such an integer can't be found.

     To find the closest integer to a given integer's square root:

          (define (integer-sqrt y)
            (newton:find-integer-root
             (lambda (x) (- (* x x) y))
             (lambda (x) (* 2 x))
             (ash 1 (quotient (integer-length y) 2))))

          (integer-sqrt 15) => 4

 -- Function: newton:find-root f df/dx x0 prec
     Given real valued procedures F, DF/DX of one (real) argument,
     initial real value X0 for which DF/DX(X0) is non-zero, and
     positive real number PREC, returns a real X for which `abs'(F(X))
     is less than PREC; or returns `#f' if such a real can't be found.

     If PREC is instead a negative integer, `newton:find-root' returns
     the result of -PREC iterations.

H. J. Orchard, `The Laguerre Method for Finding the Zeros of
Polynomials', IEEE Transactions on Circuits and Systems, Vol. 36, No.
11, November 1989, pp 1377-1381.

     There are 2 errors in Orchard's Table II.  Line k=2 for starting
     value of 1000+j0 should have Z_k of 1.0475 + j4.1036 and line k=2
     for starting value of 0+j1000 should have Z_k of 1.0988 + j4.0833.

 -- Function: laguerre:find-root f df/dz ddf/dz^2 z0 prec
     Given complex valued procedure F of one (complex) argument, its
     derivative (with respect to its argument) DF/DX, its second
     derivative DDF/DZ^2, initial complex value Z0, and positive real
     number PREC, returns a complex number Z for which
     `magnitude'(F(Z)) is less than PREC; or returns `#f' if such a
     number can't be found.

     If PREC is instead a negative integer, `laguerre:find-root'
     returns the result of -PREC iterations.

 -- Function: laguerre:find-polynomial-root deg f df/dz ddf/dz^2 z0 prec
     Given polynomial procedure F of integer degree DEG of one
     argument, its derivative (with respect to its argument) DF/DX, its
     second derivative DDF/DZ^2, initial complex value Z0, and positive
     real number PREC, returns a complex number Z for which
     `magnitude'(F(Z)) is less than PREC; or returns `#f' if such a
     number can't be found.

     If PREC is instead a negative integer,
     `laguerre:find-polynomial-root' returns the result of -PREC
     iterations.

 -- Function: secant:find-root f x0 x1 prec
 -- Function: secant:find-bracketed-root f x0 x1 prec
     Given a real valued procedure F and two real valued starting
     points X0 and X1, returns a real X for which `(abs (f x))' is less
     than PREC; or returns `#f' if such a real can't be found.

     If X0 and X1 are chosen such that they bracket a root, that is
          (or (< (f x0) 0 (f x1))
              (< (f x1) 0 (f x0)))
     then the root returned will be between X0 and X1, and F will not
     be passed an argument outside of that interval.

     `secant:find-bracketed-root' will return `#f' unless X0 and X1
     bracket a root.

     The secant method is used until a bracketing interval is found, at
     which point a modified regula falsi method is used.

     If PREC is instead a negative integer, `secant:find-root' returns
     the result of -PREC iterations.

     If PREC is a procedure it should accept 5 arguments: X0 F0 X1 F1
     and COUNT, where F0 will be `(f x0)', F1 `(f x1)', and COUNT the
     number of iterations performed so far.  PREC should return
     non-false if the iteration should be stopped.


File: slib-3b5.info,  Node: Minimizing,  Next: The Limit,  Prev: Root Finding,  Up: Mathematical Packages
                                                                              |
5.13 Minimizing
===============

`(require 'minimize)' 

The Golden Section Search (1) algorithm finds minima of functions which
are expensive to compute or for which derivatives are not available.
Although optimum for the general case, convergence is slow, requiring
nearly 100 iterations for the example (x^3-2x-5).

If the derivative is available, Newton-Raphson is probably a better
choice.  If the function is inexpensive to compute, consider
approximating the derivative.

 -- Function: golden-section-search f x0 x1 prec
     X_0 are X_1 real numbers.  The (single argument) procedure F is
     unimodal over the open interval (X_0, X_1).  That is, there is
     exactly one point in the interval for which the derivative of F is
     zero.

     `golden-section-search' returns a pair (X . F(X)) where F(X) is
     the minimum.  The PREC parameter is the stop criterion.  If PREC
     is a positive number, then the iteration continues until X is
     within PREC from the true value.  If PREC is a negative integer,
     then the procedure will iterate -PREC times or until convergence.
     If PREC is a procedure of seven arguments, X0, X1, A, B, FA, FB,
     and COUNT, then the iterations will stop when the procedure
     returns `#t'.

     Analytically, the minimum of x^3-2x-5 is 0.816497.
          (define func (lambda (x) (+ (* x (+ (* x x) -2)) -5)))
          (golden-section-search func 0 1 (/ 10000))
                ==> (816.4883855245578e-3 . -6.0886621077391165)
          (golden-section-search func 0 1 -5)
                ==> (819.6601125010515e-3 . -6.088637561916407)
          (golden-section-search func 0 1
                                 (lambda (a b c d e f g ) (= g 500)))
                ==> (816.4965933140557e-3 . -6.088662107903635)

  ---------- Footnotes ----------

  (1) David Kahaner, Cleve Moler, and Stephen Nash `Numerical Methods
and Software' Prentice-Hall, 1989, ISBN 0-13-627258-4


File: slib-3b5.info,  Node: The Limit,  Next: Commutative Rings,  Prev: Minimizing,  Up: Mathematical Packages
                                                                              |
5.14 The Limit
==============

 -- library procedure: limit proc x1 x2 k
 -- library procedure: limit proc x1 x2
     PROC must be a procedure taking a single inexact real argument.  K
     is the number of points on which PROC will be called; it defaults
     to 8.

     If X1 is finite, then PROC must be continuous on the half-open
     interval:

     ( X1 .. X1+X2 ]

     And X2 should be chosen small enough so that PROC is expected to
     be monotonic or constant on arguments between X1 and X1 + X2.

     `Limit' computes the limit of PROC as its argument approaches X1
     from X1 + X2.  `Limit' returns a real number or real infinity or
     `#f'.

     If X1 is not finite, then X2 must be a finite nonzero real with
     the same sign as X1; in which case `limit' returns:

     `(limit (lambda (x) (proc (/ x))) 0.0 (/ X2) K)'

     `Limit' examines the magnitudes of the differences between
     successive values returned by PROC called with a succession of
     numbers from X1+X2/K to X1.

     If the magnitudes of differences are monotonically decreasing, then
     then the limit is extrapolated from the degree n polynomial passing
     through the samples returned by PROC.

     If the magnitudes of differences are increasing as fast or faster
     than a hyperbola matching at X1+X2, then a real infinity with sign
     the same as the differences is returned.

     If the magnitudes of differences are increasing more slowly than
     the hyperbola matching at X1+X2, then the limit is extrapolated
     from the quadratic passing through the three samples closest to X1.

     If the magnitudes of differences are not monotonic or are not
     completely within one of the above categories, then #f is returned.

     ;; constant
     (limit (lambda (x) (/ x x)) 0 1.0e-9)           ==> 1.0
     (limit (lambda (x) (expt 0 x)) 0 1.0e-9)        ==> 0.0
     (limit (lambda (x) (expt 0 x)) 0 -1.0e-9)       ==> +inf.0
     ;; linear
     (limit + 0 976.5625e-6)                         ==> 0.0
     (limit - 0 976.5625e-6)                         ==> 0.0
     ;; vertical point of inflection
     (limit sqrt 0 1.0e-18)                          ==> 0.0
     (limit (lambda (x) (* x (log x))) 0 1.0e-9)     ==> -102.70578127633066e-12
     (limit (lambda (x) (/ x (log x))) 0 1.0e-9)     ==> 96.12123142321669e-15
     ;; limits tending to infinity
     (limit + +inf.0 1.0e9)                          ==> +inf.0
     (limit + -inf.0 -1.0e9)                         ==> -inf.0
     (limit / 0 1.0e-9)                              ==> +inf.0
     (limit / 0 -1.0e-9)                             ==> -inf.0
     (limit (lambda (x) (/ (log x) x)) 0 1.0e-9)     ==> -inf.0
     (limit (lambda (x) (/ (magnitude (log x)) x)) 0 -1.0e-9)
                                                     ==> -inf.0
     ;; limit doesn't exist
     (limit sin +inf.0 1.0e9)                        ==> #f
     (limit (lambda (x) (sin (/ x))) 0 1.0e-9)       ==> #f
     (limit (lambda (x) (sin (/ x))) 0 -1.0e-9)      ==> #f
     (limit (lambda (x) (/ (log x) x)) 0 -1.0e-9)    ==> #f
     ;; conditionally convergent - return #f
     (limit (lambda (x) (/ (sin x) x)) +inf.0 1.0e222)
                                                     ==> #f
     ;; asymptotes
     (limit / -inf.0 -1.0e222)                       ==> 0.0
     (limit / +inf.0 1.0e222)                        ==> 0.0
     (limit (lambda (x) (expt x x)) 0 1.0e-18)       ==> 1.0
     (limit (lambda (x) (sin (/ x))) +inf.0 1.0e222) ==> 0.0
     (limit (lambda (x) (/ (+ (exp (/ x)) 1))) 0 1.0e-9)
                                                     ==> 0.0
     (limit (lambda (x) (/ (+ (exp (/ x)) 1))) 0 -1.0e-9)
                                                     ==> 1.0
     (limit (lambda (x) (real-part (expt (tan x) (cos x)))) (/ pi 2) 1.0e-9)
                                                     ==> 1.0
     ;; This example from the 1979 Macsyma manual grows so rapidly
     ;;  that x2 must be less than 41.  It correctly returns e^2.
     (limit (lambda (x) (expt (+ x (exp x) (exp (* 2 x))) (/ x))) +inf.0 40)
                                                     ==> 7.3890560989306504
     ;; LIMIT can calculate the proper answer when evaluation
     ;; of the function at the limit point does not:
     (tan (atan +inf.0))                             ==> 16.331778728383844e15
     (limit tan (atan +inf.0) -1.0e-15)              ==> +inf.0
     (tan (atan +inf.0))                             ==> 16.331778728383844e15
     (limit tan (atan +inf.0) 1.0e-15)               ==> -inf.0
     ((lambda (x) (expt (exp (/ -1 x)) x)) 0)        ==> 1.0
     (limit (lambda (x) (expt (exp (/ -1 x)) x)) 0 1.0e-9)
                                                     ==> 0.0


File: slib-3b5.info,  Node: Commutative Rings,  Next: Matrix Algebra,  Prev: The Limit,  Up: Mathematical Packages
                                                                              |
5.15 Commutative Rings
======================

Scheme provides a consistent and capable set of numeric functions.
Inexacts implement a field; integers a commutative ring (and Euclidean
domain).  This package allows one to use basic Scheme numeric functions
with symbols and non-numeric elements of commutative rings.

  `(require 'commutative-ring)' 

  The "commutative-ring" package makes the procedures `+', `-', `*',
`/', and `^' "careful" in the sense that any non-numeric arguments they
do not reduce appear in the expression output.  In order to see what
working with this package is like, self-set all the single letter
identifiers (to their corresponding symbols).  

     (define a 'a)
     ...
     (define z 'z)

  Or just `(require 'self-set)'.  Now try some sample expressions: 

     (+ (+ a b) (- a b)) => (* a 2)
     (* (+ a b) (+ a b)) => (^ (+ a b) 2)
     (* (+ a b) (- a b)) => (* (+ a b) (- a b))
     (* (- a b) (- a b)) => (^ (- a b) 2)
     (* (- a b) (+ a b)) => (* (+ a b) (- a b))
     (/ (+ a b) (+ c d)) => (/ (+ a b) (+ c d))
     (^ (+ a b) 3) => (^ (+ a b) 3)
     (^ (+ a 2) 3) => (^ (+ 2 a) 3)

  Associative rules have been applied and repeated addition and
multiplication converted to multiplication and exponentiation.

  We can enable distributive rules, thus expanding to sum of products
form:
     (set! *ruleset* (combined-rulesets distribute* distribute/))

     (* (+ a b) (+ a b)) => (+ (* 2 a b) (^ a 2) (^ b 2))
     (* (+ a b) (- a b)) => (- (^ a 2) (^ b 2))
     (* (- a b) (- a b)) => (- (+ (^ a 2) (^ b 2)) (* 2 a b))
     (* (- a b) (+ a b)) => (- (^ a 2) (^ b 2))
     (/ (+ a b) (+ c d)) => (+ (/ a (+ c d)) (/ b (+ c d)))
     (/ (+ a b) (- c d)) => (+ (/ a (- c d)) (/ b (- c d)))
     (/ (- a b) (- c d)) => (- (/ a (- c d)) (/ b (- c d)))
     (/ (- a b) (+ c d)) => (- (/ a (+ c d)) (/ b (+ c d)))
     (^ (+ a b) 3) => (+ (* 3 a (^ b 2)) (* 3 b (^ a 2)) (^ a 3) (^ b 3))
     (^ (+ a 2) 3) => (+ 8 (* a 12) (* (^ a 2) 6) (^ a 3))

  Use of this package is not restricted to simple arithmetic
expressions:

     (require 'determinant)

     (determinant '((a b c) (d e f) (g h i))) =>
     (- (+ (* a e i) (* b f g) (* c d h)) (* a f h) (* b d i) (* c e g))

  Currently, only `+', `-', `*', `/', and `^' support non-numeric
elements.  Expressions with `-' are converted to equivalent expressions
without `-', so behavior for `-' is not defined separately.  `/'
expressions are handled similarly.

  This list might be extended to include `quotient', `modulo',
`remainder', `lcm', and `gcd'; but these work only for the more
restrictive Euclidean (Unique Factorization) Domain.  

5.16 Rules and Rulesets
=======================

The "commutative-ring" package allows control of ring properties
through the use of "rulesets".

 -- Variable: *ruleset*
     Contains the set of rules currently in effect.  Rules defined by
     `cring:define-rule' are stored within the value of *ruleset* at the
     time `cring:define-rule' is called.  If *RULESET* is `#f', then no
     rules apply.

 -- Function: make-ruleset rule1 ...
 -- Function: make-ruleset name rule1 ...
     Returns a new ruleset containing the rules formed by applying
     `cring:define-rule' to each 4-element list argument RULE.  If the
     first argument to `make-ruleset' is a symbol, then the database
     table created for the new ruleset will be named NAME.  Calling
     `make-ruleset' with no rule arguments creates an empty ruleset.

 -- Function: combined-rulesets ruleset1 ...
 -- Function: combined-rulesets name ruleset1 ...
     Returns a new ruleset containing the rules contained in each
     ruleset argument RULESET.  If the first argument to
     `combined-ruleset' is a symbol, then the database table created for
     the new ruleset will be named NAME.  Calling `combined-ruleset'
     with no ruleset arguments creates an empty ruleset.

  Two rulesets are defined by this package.

 -- Constant: distribute*
     Contains the ruleset to distribute multiplication over addition and
     subtraction.

 -- Constant: distribute/
     Contains the ruleset to distribute division over addition and
     subtraction.

     Take care when using both DISTRIBUTE* and DISTRIBUTE/
     simultaneously.  It is possible to put `/' into an infinite loop.

  You can specify how sum and product expressions containing non-numeric
elements simplify by specifying the rules for `+' or `*' for cases
where expressions involving objects reduce to numbers or to expressions
involving different non-numeric elements.

 -- Function: cring:define-rule op sub-op1 sub-op2 reduction
     Defines a rule for the case when the operation represented by
     symbol OP is applied to lists whose `car's are SUB-OP1 and
     SUB-OP2, respectively.  The argument REDUCTION is a procedure
     accepting 2 arguments which will be lists whose `car's are SUB-OP1
     and SUB-OP2.

 -- Function: cring:define-rule op sub-op1 'identity reduction
     Defines a rule for the case when the operation represented by
     symbol OP is applied to a list whose `car' is SUB-OP1, and some
     other argument.  REDUCTION will be called with the list whose
     `car' is SUB-OP1 and some other argument.

     If REDUCTION returns `#f', the reduction has failed and other
     reductions will be tried.  If REDUCTION returns a non-false value,
     that value will replace the two arguments in arithmetic (`+', `-',
     and `*') calculations involving non-numeric elements.

     The operations `+' and `*' are assumed commutative; hence both
     orders of arguments to REDUCTION will be tried if necessary.

     The following rule is the definition for distributing `*' over `+'.

          (cring:define-rule
           '* '+ 'identity
           (lambda (exp1 exp2)
             (apply + (map (lambda (trm) (* trm exp2)) (cdr exp1))))))

5.17 How to Create a Commutative Ring
=====================================

The first step in creating your commutative ring is to write procedures
to create elements of the ring.  A non-numeric element of the ring must
be represented as a list whose first element is a symbol or string.
This first element identifies the type of the object.  A convenient and
clear convention is to make the type-identifying element be the same
symbol whose top-level value is the procedure to create it.

     (define (n . list1)
       (cond ((and (= 2 (length list1))
                   (eq? (car list1) (cadr list1)))
              0)
             ((not (term< (first list1) (last1 list1)))
              (apply n (reverse list1)))
             (else (cons 'n list1))))

     (define (s x y) (n x y))

     (define (m . list1)
       (cond ((neq? (first list1) (term_min list1))
              (apply m (cyclicrotate list1)))
             ((term< (last1 list1) (cadr list1))
              (apply m (reverse (cyclicrotate list1))))
             (else (cons 'm list1))))

  Define a procedure to multiply 2 non-numeric elements of the ring.
Other multiplicatons are handled automatically.  Objects for which rules
have _not_ been defined are not changed.

     (define (n*n ni nj)
       (let ((list1 (cdr ni)) (list2 (cdr nj)))
         (cond ((null? (intersection list1 list2)) #f)
               ((and (eq? (last1 list1) (first list2))
                     (neq? (first list1) (last1 list2)))
                (apply n (splice list1 list2)))
               ((and (eq? (first list1) (first list2))
                     (neq? (last1 list1) (last1 list2)))
                (apply n (splice (reverse list1) list2)))
               ((and (eq? (last1 list1) (last1 list2))
                     (neq? (first list1) (first list2)))
                (apply n (splice list1 (reverse list2))))
               ((and (eq? (last1 list1) (first list2))
                     (eq? (first list1) (last1 list2)))
                (apply m (cyclicsplice list1 list2)))
               ((and (eq? (first list1) (first list2))
                     (eq? (last1 list1) (last1 list2)))
                (apply m (cyclicsplice (reverse list1) list2)))
               (else #f))))

  Test the procedures to see if they work.

     ;;; where cyclicrotate(list) is cyclic rotation of the list one step
     ;;; by putting the first element at the end
     (define (cyclicrotate list1)
       (append (rest list1) (list (first list1))))
     ;;; and where term_min(list) is the element of the list which is
     ;;; first in the term ordering.
     (define (term_min list1)
       (car (sort list1 term<)))
     (define (term< sym1 sym2)
       (string<? (symbol->string sym1) (symbol->string sym2)))
     (define first car)
     (define rest cdr)
     (define (last1 list1) (car (last-pair list1)))
     (define (neq? obj1 obj2) (not (eq? obj1 obj2)))
     ;;; where splice is the concatenation of list1 and list2 except that their
     ;;; common element is not repeated.
     (define (splice list1 list2)
       (cond ((eq? (last1 list1) (first list2))
              (append list1 (cdr list2)))
             (else (slib:error 'splice list1 list2))))
     ;;; where cyclicsplice is the result of leaving off the last element of
     ;;; splice(list1,list2).
     (define (cyclicsplice list1 list2)
       (cond ((and (eq? (last1 list1) (first list2))
                   (eq? (first list1) (last1 list2)))
              (butlast (splice list1 list2) 1))
             (else (slib:error 'cyclicsplice list1 list2))))

     (N*N (S a b) (S a b)) => (m a b)

  Then register the rule for multiplying type N objects by type N
objects.

     (cring:define-rule '* 'N 'N N*N))

  Now we are ready to compute!

     (define (t)
       (define detM
         (+ (* (S g b)
               (+ (* (S f d)
                     (- (* (S a f) (S d g)) (* (S a g) (S d f))))
                  (* (S f f)
                     (- (* (S a g) (S d d)) (* (S a d) (S d g))))
                  (* (S f g)
                     (- (* (S a d) (S d f)) (* (S a f) (S d d))))))
            (* (S g d)
               (+ (* (S f b)
                     (- (* (S a g) (S d f)) (* (S a f) (S d g))))
                  (* (S f f)
                     (- (* (S a b) (S d g)) (* (S a g) (S d b))))
                  (* (S f g)
                     (- (* (S a f) (S d b)) (* (S a b) (S d f))))))
            (* (S g f)
               (+ (* (S f b)
                     (- (* (S a d) (S d g)) (* (S a g) (S d d))))
                  (* (S f d)
                     (- (* (S a g) (S d b)) (* (S a b) (S d g))))
                  (* (S f g)
                     (- (* (S a b) (S d d)) (* (S a d) (S d b))))))
            (* (S g g)
               (+ (* (S f b)
                     (- (* (S a f) (S d d)) (* (S a d) (S d f))))
                  (* (S f d)
                     (- (* (S a b) (S d f)) (* (S a f) (S d b))))
                  (* (S f f)
                     (- (* (S a d) (S d b)) (* (S a b) (S d d))))))))
       (* (S b e) (S c a) (S e c)
          detM
          ))
     (pretty-print (t))
     -|
     (- (+ (m a c e b d f g)
           (m a c e b d g f)
           (m a c e b f d g)
           (m a c e b f g d)
           (m a c e b g d f)
           (m a c e b g f d))
        (* 2 (m a b e c) (m d f g))
        (* (m a c e b d) (m f g))
        (* (m a c e b f) (m d g))
        (* (m a c e b g) (m d f)))


File: slib-3b5.info,  Node: Matrix Algebra,  Prev: Commutative Rings,  Up: Mathematical Packages
                                                                              |
5.18 Matrix Algebra
===================

`(require 'determinant)' 

A Matrix can be either a list of lists (rows) or an array.  Unlike
linear-algebra texts, this package uses 0-based coordinates.

 -- Function: matrix->lists matrix
     Returns the list-of-lists form of MATRIX.

 -- Function: matrix->array matrix
     Returns the array form of MATRIX.

 -- Function: determinant matrix
     MATRIX must be a square matrix.  `determinant' returns the
     determinant of MATRIX.

          (require 'determinant)
          (determinant '((1 2) (3 4))) => -2
          (determinant '((1 2 3) (4 5 6) (7 8 9))) => 0

 -- Function: transpose matrix
     Returns a copy of MATRIX flipped over the diagonal containing the
     1,1 element.

 -- Function: matrix:sum m1 m2
     Returns the element-wise sum of matricies M1 and M2.

 -- Function: matrix:difference m1 m2
     Returns the element-wise difference of matricies M1 and M2.

 -- Function: matrix:product m1 m2
     Returns the product of matrices M1 and M2.


 -- Function: matrix:product m1 z
     Returns matrix M1 times scalar Z.


 -- Function: matrix:product z m1
     Returns matrix M1 times scalar Z.

 -- Function: matrix:inverse matrix
     MATRIX must be a square matrix.  If MATRIX is singular, then
     `matrix:inverse' returns #f; otherwise `matrix:inverse' returns the
     `matrix:product' inverse of MATRIX.


File: slib-3b5.info,  Node: Database Packages,  Next: Other Packages,  Prev: Mathematical Packages,  Up: Top
                                                                              |
6 Database Packages
*******************

* Menu:

* Relational Database::         'relational-database
* Relational Infrastructure::
* Weight-Balanced Trees::       'wt-tree


File: slib-3b5.info,  Node: Relational Database,  Next: Relational Infrastructure,  Prev: Database Packages,  Up: Database Packages
                                                                              |
6.1 Relational Database
=======================

`(require 'relational-database)' 

  This package implements a database system inspired by the Relational
Model (`E. F. Codd, A Relational Model of Data for Large Shared Data
Banks').  An SLIB relational database implementation can be created
from any *note Base Table:: implementation.

  Why relational database?  For motivations and design issues see
`http://people.csail.mit.edu/jaffer/DBManifesto.html'.

* Menu:

* Using Databases::             'databases
* Table Operations::
* Database Interpolation::      'database-interpolate
* Embedded Commands::           'database-commands
* Database Macros::             'within-database
* Database Browser::            'database-browse


File: slib-3b5.info,  Node: Using Databases,  Next: Table Operations,  Prev: Relational Database,  Up: Relational Database
                                                                              |
6.1.1 Using Databases
---------------------

`(require 'databases)' 

This enhancement wraps a utility layer on `relational-database' which
provides:

   * Identification of open databases by filename.

   * Automatic sharing of open (immutable) databases.

   * Automatic loading of base-table package when creating a database.

   * Detection and automatic loading of the appropriate base-table
     package when opening a database.

   * Table and data definition from Scheme lists.

Database Sharing
................

"Auto-sharing" refers to a call to the procedure `open-database'
returning an already open database (procedure), rather than opening the
database file a second time.

     _Note:_ Databases returned by `open-database' do not include
     wrappers applied by packages like *note Embedded Commands::.  But
     wrapped databases do work as arguments to these functions.

When a database is created, it is mutable by the creator and not
auto-sharable.  A database opened mutably is also not auto-sharable.
But any number of readers can (open) share a non-mutable database file.

This next set of procedures mirror the whole-database methods in *note
Database Operations::.  Except for `create-database', each procedure
will accept either a filename or database procedure for its first
argument.

 -- Function: create-database filename base-table-type
     FILENAME should be a string naming a file; or `#f'.
     BASE-TABLE-TYPE must be a symbol naming a feature which can be
     passed to `require'.  `create-database' returns a new, open
     relational database (with base-table type BASE-TABLE-TYPE)
     associated with FILENAME, or a new ephemeral database if FILENAME
     is `#f'.

     `create-database' is the only run-time use of require in SLIB
     which crosses module boundaries.  When BASE-TABLE-TYPE is
     `require'd by `create-database'; it adds an association of
     BASE-TABLE-TYPE with its "relational-system" procedure to
     MDBM:*DATABASES*.

     alist-table is the default base-table type:

          (require 'databases)
          (define my-rdb (create-database "my.db" 'alist-table))

Only `alist-table' and base-table modules which have been `require'd
will dispatch correctly from the `open-database' procedures.
Therefore, either pass two arguments to `open-database', or require the
base-table of your database file uses before calling `open-database'
with one argument.

 -- Procedure: open-database! rdb base-table-type
     Returns _mutable_ open relational database or #f.

 -- Function: open-database rdb base-table-type
     Returns an open relational database associated with RDB.  The
     database will be opened with base-table type BASE-TABLE-TYPE).


 -- Function: open-database rdb
     Returns an open relational database associated with RDB.
     `open-database' will attempt to deduce the correct base-table-type.

 -- Function: write-database rdb filename
     Writes the mutable relational-database RDB to FILENAME.

 -- Function: sync-database rdb
     Writes the mutable relational-database RDB to the filename it was
     opened with.

 -- Function: solidify-database rdb
     Syncs RDB and makes it immutable.

 -- Function: close-database rdb
     RDB will only be closed when the count of `open-database' -
     `close-database' calls for RDB (and its filename) is 0.
     `close-database' returns #t if successful; and #f otherwise.

 -- Function: mdbm:report
     Prints a table of open database files.  The columns are the
     base-table type, number of opens, `!' for mutable, the filename,
     and the lock certificate (if locked).

     (mdbm:report)
     -|
       alist-table 003   /usr/local/lib/slib/clrnamdb.scm
       alist-table 001 ! sdram.db jaffer@aubrey.jaffer.3166:1038628199

Opening Tables
..............

 -- Function: open-table rdb table-name
     RDB must be a relational database and TABLE-NAME a symbol.

     `open-table' returns a "methods" procedure for an existing
     relational table in RDB if it exists and can be opened for
     reading, otherwise returns `#f'.

 -- Procedure: open-table! rdb table-name
     RDB must be a relational database and TABLE-NAME a symbol.

     `open-table!' returns a "methods" procedure for an existing
     relational table in RDB if it exists and can be opened in mutable
     mode, otherwise returns `#f'.

Defining Tables
...............

 -- Function: define-domains rdb row5 ...
     Adds the domain rows ROW5 ... to the `*domains-data*' table in
     RDB.  The format of the row is given in *note Catalog
     Representation::.

          (define-domains rdb '(permittivity #f complex? c64 #f))

 -- Function: add-domain rdb row5
     Use `define-domains' instead.

 -- Function: define-tables rdb spec-0 ...
     Adds tables as specified in SPEC-0 ... to the open
     relational-database RDB.  Each SPEC has the form:

          (<name> <descriptor-name> <descriptor-name> <rows>)
     or
          (<name> <primary-key-fields> <other-fields> <rows>)

     where <name> is the table name, <descriptor-name> is the symbol
     name of a descriptor table, <primary-key-fields> and
     <other-fields> describe the primary keys and other fields
     respectively, and <rows> is a list of data rows to be added to the
     table.

     <primary-key-fields> and <other-fields> are lists of field
     descriptors of the form:

          (<column-name> <domain>)
     or
          (<column-name> <domain> <column-integrity-rule>)

     where <column-name> is the column name, <domain> is the domain of
     the column, and <column-integrity-rule> is an expression whose
     value is a procedure of one argument (which returns `#f' to signal
     an error).

     If <domain> is not a defined domain name and it matches the name of
     this table or an already defined (in one of SPEC-0 ...) single key
     field table, a foreign-key domain will be created for it.

Listing Tables
..............

 -- Function: list-table-definition rdb table-name
     If symbol TABLE-NAME exists in the open relational-database RDB,
     then returns a list of the table-name, its primary key names and
     domains, its other key names and domains, and the table's records
     (as lists).  Otherwise, returns #f.

     The list returned by `list-table-definition', when passed as an
     argument to `define-tables', will recreate the table.


File: slib-3b5.info,  Node: Table Operations,  Next: Database Interpolation,  Prev: Using Databases,  Up: Relational Database
                                                                              |
6.1.2 Table Operations
----------------------

These are the descriptions of the methods available from an open
relational table.  A method is retrieved from a table by calling the
table with the symbol name of the operation.  For example:

     ((plat 'get 'processor) 'djgpp) => i386

Some operations described below require primary key arguments.  Primary
keys arguments are denoted KEY1 KEY2 ....  It is an error to call an
operation for a table which takes primary key arguments with the wrong
number of primary keys for that table.

 -- Operation on relational-table: get column-name
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     value for the COLUMN-NAME column of the row associated with
     primary keys KEY1, KEY2 ... if that row exists in the table, or
     `#f' otherwise.

          ((plat 'get 'processor) 'djgpp) => i386
          ((plat 'get 'processor) 'be-os) => #f

* Menu:

* Single Row Operations::
* Match-Keys::
* Multi-Row Operations::
* Indexed Sequential Access Methods::
* Sequential Index Operations::
* Table Administration::


File: slib-3b5.info,  Node: Single Row Operations,  Next: Match-Keys,  Prev: Table Operations,  Up: Table Operations
                                                                              |
6.1.2.1 Single Row Operations
.............................

The term "row" used below refers to a Scheme list of values (one for
each column) in the order specified in the descriptor (table) for this
table.  Missing values appear as `#f'.  Primary keys must not be
missing.

 -- Operation on relational-table: row:insert
     Adds the row ROW to this table.  If a row for the primary key(s)
     specified by ROW already exists in this table an error is
     signaled.  The value returned is unspecified.

     (define telephone-table-desc
             ((my-database 'create-table) 'telephone-table-desc))
     (define ndrp (telephone-table-desc 'row:insert))
     (ndrp '(1 #t name #f string))
     (ndrp '(2 #f telephone
               (lambda (d)
                 (and (string? d) (> (string-length d) 2)
                      (every
                       (lambda (c)
                         (memv c '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
                                       #\+ #\( #\space #\) #\-)))
                       (string->list d))))
               string))

 -- Operation on relational-table: row:update
     Returns a procedure of one argument, ROW, which adds the row, ROW,
     to this table.  If a row for the primary key(s) specified by ROW
     already exists in this table, it will be overwritten.  The value
     returned is unspecified.

 -- Operation on relational-table: row:retrieve
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     row associated with primary keys KEY1, KEY2 ... if it exists, or
     `#f' otherwise.

     ((plat 'row:retrieve) 'linux) => (linux i386 linux gcc)
     ((plat 'row:retrieve) 'multics) => #f

 -- Operation on relational-table: row:remove
     Returns a procedure of arguments KEY1 KEY2 ... which removes and
     returns the row associated with primary keys KEY1, KEY2 ... if it
     exists, or `#f' otherwise.

 -- Operation on relational-table: row:delete
     Returns a procedure of arguments KEY1 KEY2 ... which deletes the
     row associated with primary keys KEY1, KEY2 ... if it exists.  The
     value returned is unspecified.


File: slib-3b5.info,  Node: Match-Keys,  Next: Multi-Row Operations,  Prev: Single Row Operations,  Up: Table Operations
                                                                              |
6.1.2.2 Match-Keys
..................

The (optional) MATCH-KEY1 ... arguments are used to restrict actions of
a whole-table operation to a subset of that table.  Those procedures
(returned by methods) which accept match-key arguments will accept any
number of match-key arguments between zero and the number of primary
keys in the table.  Any unspecified MATCH-KEY arguments default to `#f'.

The MATCH-KEY1 ... restrict the actions of the table command to those
records whose primary keys each satisfy the corresponding MATCH-KEY
argument.  The arguments and their actions are:

    `#f'
          The false value matches any key in the corresponding position.

    an object of type procedure
          This procedure must take a single argument, the key in the
          corresponding position.  Any key for which the procedure
          returns a non-false value is a match; Any key for which the
          procedure returns a `#f' is not.

    other values
          Any other value matches only those keys `equal?' to it.

 -- Operation on relational-table: get* column-name
     Returns a procedure of optional arguments MATCH-KEY1 ... which
     returns a list of the values for the specified column for all rows
     in this table.  The optional MATCH-KEY1 ... arguments restrict
     actions to a subset of the table.

          ((plat 'get* 'processor)) =>
          (i386 i8086 i386 i8086 i386 i386 i8086 m68000
           m68000 m68000 m68000 m68000 powerpc)

          ((plat 'get* 'processor) #f) =>
          (i386 i8086 i386 i8086 i386 i386 i8086 m68000
           m68000 m68000 m68000 m68000 powerpc)

          (define (a-key? key)
             (char=? #\a (string-ref (symbol->string key) 0)))

          ((plat 'get* 'processor) a-key?) =>
          (m68000 m68000 m68000 m68000 m68000 powerpc)

          ((plat 'get* 'name) a-key?) =>
          (atari-st-turbo-c atari-st-gcc amiga-sas/c-5.10
           amiga-aztec amiga-dice-c aix)


File: slib-3b5.info,  Node: Multi-Row Operations,  Next: Indexed Sequential Access Methods,  Prev: Match-Keys,  Up: Table Operations
                                                                              |
6.1.2.3 Multi-Row Operations
............................

 -- Operation on relational-table: row:retrieve*
     Returns a procedure of optional arguments MATCH-KEY1 ...  which
     returns a list of all rows in this table.  The optional MATCH-KEY1
     ... arguments restrict actions to a subset of the table.  For
     details see *Note Match-Keys::.

     ((plat 'row:retrieve*) a-key?) =>
     ((atari-st-turbo-c m68000 atari turbo-c)
      (atari-st-gcc m68000 atari gcc)
      (amiga-sas/c-5.10 m68000 amiga sas/c)
      (amiga-aztec m68000 amiga aztec)
      (amiga-dice-c m68000 amiga dice-c)
      (aix powerpc aix -))

 -- Operation on relational-table: row:remove*
     Returns a procedure of optional arguments MATCH-KEY1 ... which
     removes and returns a list of all rows in this table.  The optional
     MATCH-KEY1 ... arguments restrict actions to a subset of the table.

 -- Operation on relational-table: row:delete*
     Returns a procedure of optional arguments MATCH-KEY1 ...  which
     Deletes all rows from this table.  The optional MATCH-KEY1 ...
     arguments restrict deletions to a subset of the table.  The value
     returned is unspecified.  The descriptor table and catalog entry
     for this table are not affected.

 -- Operation on relational-table: for-each-row
     Returns a procedure of arguments PROC MATCH-KEY1 ...  which calls
     PROC with each ROW in this table.  The optional MATCH-KEY1 ...
     arguments restrict actions to a subset of the table.  For details
     see *Note Match-Keys::.

Note that `row:insert*' and `row:update*' do _not_ use match-keys.

 -- Operation on relational-table: row:insert*
     Returns a procedure of one argument, ROWS, which adds each row in
     the list of rows, ROWS, to this table.  If a row for the primary
     key specified by an element of ROWS already exists in this table,
     an error is signaled.  The value returned is unspecified.

 -- Operation on relational-table: row:update*
     Returns a procedure of one argument, ROWS, which adds each row in
     the list of rows, ROWS, to this table.  If a row for the primary
     key specified by an element of ROWS already exists in this table,
     it will be overwritten.  The value returned is unspecified.


File: slib-3b5.info,  Node: Indexed Sequential Access Methods,  Next: Sequential Index Operations,  Prev: Multi-Row Operations,  Up: Table Operations
                                                                              |
6.1.2.4 Indexed Sequential Access Methods
.........................................

"Indexed Sequential Access Methods" are a way of arranging database
information so that records can be accessed both by key and by key
sequence (ordering).  "ISAM" is not part of Codd's relational model.          |

Associative memory in B-Trees is an example of a database
implementation which can support a native key ordering.  SLIB's
`alist-table' implementation uses `sort' to implement
`for-each-row-in-order', but does not support `isam-next' and
`isam-prev'.

The multi-primary-key ordering employed by these operations is the
lexicographic collation of those primary-key fields in their given
order.  For example:

     (12 a 34) < (12 a 36) < (12 b 1) < (13 a 0)


File: slib-3b5.info,  Node: Sequential Index Operations,  Next: Table Administration,  Prev: Indexed Sequential Access Methods,  Up: Table Operations
                                                                              |
6.1.2.5 Sequential Index Operations
...................................

The following procedures are individually optional depending on the
base-table implememtation.  If an operation is _not_ supported, then
calling the table with that operation symbol will return false.

 -- Operation on relational-table: for-each-row-in-order
     Returns a procedure of arguments PROC MATCH-KEY1 ...  which calls
     PROC with each ROW in this table in the (implementation-dependent)
     natural, repeatable ordering for rows.  The optional MATCH-KEY1
     ... arguments restrict actions to a subset of the table.  For
     details see *Note Match-Keys::.

 -- Operation on relational-table: isam-next
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     key-list identifying the lowest record higher than KEY1 KEY2 ...
     which is stored in the relational-table; or false if no higher
     record is present.

 -- Operation on relational-table: isam-next column-name
     The symbol COLUMN-NAME names a key field.  In the list returned by
     `isam-next', that field, or a field to its left, will be changed.
     This allows one to skip over less significant key fields.

 -- Operation on relational-table: isam-prev
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     key-list identifying the highest record less than KEY1 KEY2 ...
     which is stored in the relational-table; or false if no lower
     record is present.

 -- Operation on relational-table: isam-prev column-name
     The symbol COLUMN-NAME names a key field.  In the list returned by
     `isam-next', that field, or a field to its left, will be changed.
     This allows one to skip over less significant key fields.

  For example, if a table has key fields:
     (col1 col2)
     (9 5)
     (9 6)
     (9 7)
     (9 8)
     (12 5)
     (12 6)
     (12 7)

  Then:
     ((table 'isam-next)       '(9 5))       => (9 6)
     ((table 'isam-next 'col2) '(9 5))       => (9 6)
     ((table 'isam-next 'col1) '(9 5))       => (12 5)
     ((table 'isam-prev)       '(12 7))      => (12 6)
     ((table 'isam-prev 'col2) '(12 7))      => (12 6)
     ((table 'isam-prev 'col1) '(12 7))      => (9 8)


File: slib-3b5.info,  Node: Table Administration,  Prev: Sequential Index Operations,  Up: Table Operations
                                                                              |
6.1.2.6 Table Administration
............................

 -- Operation on relational-table: column-names
 -- Operation on relational-table: column-foreigns
 -- Operation on relational-table: column-domains
 -- Operation on relational-table: column-types
     Return a list of the column names, foreign-key table names, domain
     names, or type names respectively for this table.  These 4 methods
     are different from the others in that the list is returned, rather
     than a procedure to obtain the list.

 -- Operation on relational-table: primary-limit
     Returns the number of primary keys fields in the relations in this
     table.

 -- Operation on relational-table: close-table
     Subsequent operations to this table will signal an error.


File: slib-3b5.info,  Node: Database Interpolation,  Next: Embedded Commands,  Prev: Table Operations,  Up: Relational Database
                                                                              |
6.1.3 Database Interpolation
----------------------------

`(require 'database-interpolate)'

Indexed sequential access methods allow finding the keys (having
associations) closest to a given value.  This facilitates the
interpolation of associations between those in the table.

 -- Function: interpolate-from-table table column
     TABLE should be a relational table with one numeric primary key
     field which supports the `isam-prev' and `isam-next' operations.
     COLUMN should be a symbol or exact positive integer designating a
     numerically valued column of TABLE.

     `interpolate-from-table' calculates and returns a value
     proportionally intermediate between its values in the next and
     previous key records contained in TABLE.  For keys larger than all
     the stored keys the value associated with the largest stored key
     is used.  For keys smaller than all the stored keys the value
     associated with the smallest stored key is used.


File: slib-3b5.info,  Node: Embedded Commands,  Next: Database Macros,  Prev: Database Interpolation,  Up: Relational Database
                                                                              |
6.1.4 Embedded Commands
-----------------------

`(require 'database-commands)'

This enhancement wraps a utility layer on `relational-database' which
provides:

   * Automatic execution of initialization commands stored in database.

   * Transparent execution of database commands stored in `*commands*'
     table in database.

  When an enhanced relational-database is called with a symbol which
matches a NAME in the `*commands*' table, the associated procedure
expression is evaluated and applied to the enhanced
relational-database.  A procedure should then be returned which the user
can invoke on (optional) arguments.

  The command `*initialize*' is special.  If present in the
`*commands*' table, `open-database' or `open-database!' will return the
value of the `*initialize*' command.  Notice that arbitrary code can be
run when the `*initialize*' procedure is automatically applied to the
enhanced relational-database.

  Note also that if you wish to shadow or hide from the user
relational-database methods described in *note Database Operations::,
this can be done by a dispatch in the closure returned by the
`*initialize*' expression rather than by entries in the `*commands*'
table if it is desired that the underlying methods remain accessible to
code in the `*commands*' table.

* Menu:

* Database Extension::
* Command Intrinsics::
* Define-tables Example::
* The *commands* Table::
* Command Service::
* Command Example::


File: slib-3b5.info,  Node: Database Extension,  Next: Command Intrinsics,  Prev: Embedded Commands,  Up: Embedded Commands
                                                                              |
6.1.4.1 Database Extension
..........................

 -- Function: wrap-command-interface rdb
     Returns relational database RDB wrapped with additional commands
     defined in its *commands* table.

 -- Function: add-command-tables rdb
     The relational database RDB must be mutable.  ADD-COMMAND-TABLES
     adds a *command* table to RDB; then returns
     `(wrap-command-interface RDB)'.

 -- Function: define-*commands* rdb spec-0 ...
     Adds commands to the `*commands*' table as specified in SPEC-0 ...
     to the open relational-database RDB.  Each SPEC has the form:

          ((<name> <rdb>) "comment" <expression1> <expression2> ...)
     or
          ((<name> <rdb>) <expression1> <expression2> ...)

     where <name> is the command name, <rdb> is a formal passed the
     calling relational database, "comment" describes the command, and
     <expression1>, <expression1>, ... are the body of the procedure.

     `define-*commands*' adds to the `*commands*' table a command
     <name>:

          (lambda (<name> <rdb>) <expression1> <expression2> ...)


 -- Function: open-command-database filename
 -- Function: open-command-database filename base-table-type
     Returns an open enhanced relational database associated with
     FILENAME.  The database will be opened with base-table type
     BASE-TABLE-TYPE) if supplied.  If BASE-TABLE-TYPE is not supplied,
     `open-command-database' will attempt to deduce the correct
     base-table-type.  If the database can not be opened or if it lacks
     the `*commands*' table, `#f' is returned.

 -- Function: open-command-database! filename
 -- Function: open-command-database! filename base-table-type
     Returns _mutable_ open enhanced relational database ...

 -- Function: open-command-database database
     Returns DATABASE if it is an immutable relational database; #f
     otherwise.

 -- Function: open-command-database! database
     Returns DATABASE if it is a mutable relational database; #f
     otherwise.


File: slib-3b5.info,  Node: Command Intrinsics,  Next: Define-tables Example,  Prev: Database Extension,  Up: Embedded Commands
                                                                              |
6.1.4.2 Command Intrinsics
..........................

Some commands are defined in all extended relational-databases.  The are
called just like *note Database Operations::.

 -- Operation on relational-database: add-domain domain-row
     Adds DOMAIN-ROW to the "domains" table if there is no row in the
     domains table associated with key `(car DOMAIN-ROW)' and returns
     `#t'.  Otherwise returns `#f'.

     For the fields and layout of the domain table, *Note Catalog
     Representation::.  Currently, these fields are
        * domain-name

        * foreign-table

        * domain-integrity-rule

        * type-id

        * type-param

     The following example adds 3 domains to the `build' database.
     `Optstring' is either a string or `#f'.  `filename' is a string
     and `build-whats' is a symbol.

          (for-each (build 'add-domain)
                    '((optstring #f
                                 (lambda (x) (or (not x) (string? x)))
                                 string
                                 #f)
                      (filename #f #f string #f)
                      (build-whats #f #f symbol #f)))

 -- Operation on relational-database: delete-domain domain-name
     Removes and returns the DOMAIN-NAME row from the "domains" table.

 -- Operation on relational-database: domain-checker domain
     Returns a procedure to check an argument for conformance to domain
     DOMAIN.


File: slib-3b5.info,  Node: Define-tables Example,  Next: The *commands* Table,  Prev: Command Intrinsics,  Up: Embedded Commands
                                                                              |
6.1.4.3 Define-tables Example
.............................

The following example shows a new database with the name of `foo.db'
being created with tables describing processor families and
processor/os/compiler combinations.  The database is then solidified;
saved and changed to immutable.

     (require 'databases)
     (define my-rdb (create-database "foo.db" 'alist-table))
     (define-tables my-rdb
       '(processor-family
         ((family    atom))
         ((also-ran  processor-family))
         ((m68000           #f)
          (m68030           m68000)
          (i386             i8086)
          (i8086            #f)
          (powerpc          #f)))

       '(platform
         ((name      symbol))
         ((processor processor-family)
          (os        symbol)
          (compiler  symbol))
         ((aix              powerpc aix     -)
          (amiga-dice-c     m68000  amiga   dice-c)
          (amiga-aztec      m68000  amiga   aztec)
          (amiga-sas/c-5.10 m68000  amiga   sas/c)
          (atari-st-gcc     m68000  atari   gcc)
          (atari-st-turbo-c m68000  atari   turbo-c)
          (borland-c-3.1    i8086   ms-dos  borland-c)
          (djgpp            i386    ms-dos  gcc)
          (linux            i386    linux   gcc)
          (microsoft-c      i8086   ms-dos  microsoft-c)
          (os/2-emx         i386    os/2    gcc)
          (turbo-c-2        i8086   ms-dos  turbo-c)
          (watcom-9.0       i386    ms-dos  watcom))))

     (solidify-database my-rdb)


File: slib-3b5.info,  Node: The *commands* Table,  Next: Command Service,  Prev: Define-tables Example,  Up: Embedded Commands
                                                                              |
6.1.4.4 The *commands* Table
............................

The table `*commands*' in an "enhanced" relational-database has the
fields (with domains):
     PRI name        symbol
         parameters  parameter-list
         procedure   expression
         documentation string

  The `parameters' field is a foreign key (domain `parameter-list') of
the `*catalog-data*' table and should have the value of a table
described by `*parameter-columns*'.  This `parameter-list' table
describes the arguments suitable for passing to the associated command.
The intent of this table is to be of a form such that different
user-interfaces (for instance, pull-down menus or plain-text queries)
can operate from the same table.  A `parameter-list' table has the
following fields:
     PRI index       ordinal
         name        symbol
         arity       parameter-arity
         domain      domain
         defaulter   expression
         expander    expression
         documentation string

  The `arity' field can take the values:

`single'
     Requires a single parameter of the specified domain.

`optional'
     A single parameter of the specified domain or zero parameters is
     acceptable.

`boolean'
     A single boolean parameter or zero parameters (in which case `#f'
     is substituted) is acceptable.

`nary'
     Any number of parameters of the specified domain are acceptable.
     The argument passed to the command function is always a list of the
     parameters.

`nary1'
     One or more of parameters of the specified domain are acceptable.
     The argument passed to the command function is always a list of the
     parameters.

  The `domain' field specifies the domain which a parameter or
parameters in the `index'th field must satisfy.

  The `defaulter' field is an expression whose value is either `#f' or
a procedure of one argument (the parameter-list) which returns a _list_
of the default value or values as appropriate.  Note that since the
`defaulter' procedure is called every time a default parameter is
needed for this column, "sticky" defaults can be implemented using
shared state with the domain-integrity-rule.


File: slib-3b5.info,  Node: Command Service,  Next: Command Example,  Prev: The *commands* Table,  Up: Embedded Commands
                                                                              |
6.1.4.5 Command Service
.......................

 -- Function: make-command-server rdb table-name
     Returns a procedure of 2 arguments, a (symbol) command and a
     call-back procedure.  When this returned procedure is called, it
     looks up COMMAND in table TABLE-NAME and calls the call-back
     procedure with arguments:
    COMMAND
          The COMMAND

    COMMAND-VALUE
          The result of evaluating the expression in the PROCEDURE
          field of TABLE-NAME and calling it with RDB.

    PARAMETER-NAME
          A list of the "official" name of each parameter.  Corresponds
          to the `name' field of the COMMAND's parameter-table.

    POSITIONS
          A list of the positive integer index of each parameter.
          Corresponds to the `index' field of the COMMAND's
          parameter-table.

    ARITIES
          A list of the arities of each parameter.  Corresponds to the
          `arity' field of the COMMAND's parameter-table.  For a
          description of `arity' see table above.

    TYPES
          A list of the type name of each parameter.  Correspnds to the
          `type-id' field of the contents of the `domain' of the
          COMMAND's parameter-table.

    DEFAULTERS
          A list of the defaulters for each parameter.  Corresponds to
          the `defaulters' field of the COMMAND's parameter-table.

    DOMAIN-INTEGRITY-RULES
          A list of procedures (one for each parameter) which tests
          whether a value for a parameter is acceptable for that
          parameter.  The procedure should be called with each datum in
          the list for `nary' arity parameters.

    ALIASES
          A list of lists of `(alias parameter-name)'.  There can be
          more than one alias per PARAMETER-NAME.

For information about parameters, *Note Parameter lists::.


File: slib-3b5.info,  Node: Command Example,  Prev: Command Service,  Up: Embedded Commands
                                                                              |
6.1.4.6 Command Example
.......................

Here is an example of setting up a command with arguments and parsing
those arguments from a `getopt' style argument list (*note Getopt::).

     (require 'database-commands)
     (require 'databases)
     (require 'getopt-parameters)
     (require 'parameters)
     (require 'getopt)
     (require 'fluid-let)
     (require 'printf)

     (define my-rdb (add-command-tables (create-database #f 'alist-table)))

     (define-tables my-rdb
       '(foo-params
         *parameter-columns*
         *parameter-columns*
         ((1 single-string single string
             (lambda (pl) '("str")) #f "single string")
          (2 nary-symbols nary symbol
             (lambda (pl) '()) #f "zero or more symbols")
          (3 nary1-symbols nary1 symbol
             (lambda (pl) '(symb)) #f "one or more symbols")
          (4 optional-number optional ordinal
             (lambda (pl) '()) #f "zero or one number")
          (5 flag boolean boolean
             (lambda (pl) '(#f)) #f "a boolean flag")))
       '(foo-pnames
         ((name string))
         ((parameter-index ordinal))
         (("s" 1)
          ("single-string" 1)
          ("n" 2)
          ("nary-symbols" 2)
          ("N" 3)
          ("nary1-symbols" 3)
          ("o" 4)
          ("optional-number" 4)
          ("f" 5)
          ("flag" 5)))
       '(my-commands
         ((name symbol))
         ((parameters parameter-list)
          (parameter-names parameter-name-translation)
          (procedure expression)
          (documentation string))
         ((foo
           foo-params
           foo-pnames
           (lambda (rdb) (lambda args (print args)))
           "test command arguments"))))

     (define (dbutil:serve-command-line rdb command-table command argv)
       (set! *argv* (if (vector? argv) (vector->list argv) argv))
       ((make-command-server rdb command-table)
        command
        (lambda (comname comval options positions
                         arities types defaulters dirs aliases)
          (apply comval (getopt->arglist options positions
                         arities types defaulters dirs aliases)))))

     (define (cmd . opts)
       (fluid-let ((*optind* 1))
         (printf "%-34s => "
                 (call-with-output-string
                  (lambda (pt) (write (cons 'cmd opts) pt))))
         (set! opts (cons "cmd" opts))
         (force-output)
         (dbutil:serve-command-line
          my-rdb 'my-commands 'foo (length opts) opts)))

     (cmd)                              => ("str" () (symb) () #f)
     (cmd "-f")                         => ("str" () (symb) () #t)
     (cmd "--flag")                     => ("str" () (symb) () #t)
     (cmd "-o177")                      => ("str" () (symb) (177) #f)
     (cmd "-o" "177")                   => ("str" () (symb) (177) #f)
     (cmd "--optional" "621")           => ("str" () (symb) (621) #f)
     (cmd "--optional=621")             => ("str" () (symb) (621) #f)
     (cmd "-s" "speciality")            => ("speciality" () (symb) () #f)
     (cmd "-sspeciality")               => ("speciality" () (symb) () #f)
     (cmd "--single" "serendipity")     => ("serendipity" () (symb) () #f)
     (cmd "--single=serendipity")       => ("serendipity" () (symb) () #f)
     (cmd "-n" "gravity" "piety")       => ("str" () (piety gravity) () #f)
     (cmd "-ngravity" "piety")          => ("str" () (piety gravity) () #f)
     (cmd "--nary" "chastity")          => ("str" () (chastity) () #f)
     (cmd "--nary=chastity" "")         => ("str" () ( chastity) () #f)
     (cmd "-N" "calamity")              => ("str" () (calamity) () #f)
     (cmd "-Ncalamity")                 => ("str" () (calamity) () #f)
     (cmd "--nary1" "surety")           => ("str" () (surety) () #f)
     (cmd "--nary1=surety")             => ("str" () (surety) () #f)
     (cmd "-N" "levity" "fealty")       => ("str" () (fealty levity) () #f)
     (cmd "-Nlevity" "fealty")          => ("str" () (fealty levity) () #f)
     (cmd "--nary1" "surety" "brevity") => ("str" () (brevity surety) () #f)
     (cmd "--nary1=surety" "brevity")   => ("str" () (brevity surety) () #f)
     (cmd "-?")
     -|
     Usage: cmd [OPTION ARGUMENT ...] ...

       -f, --flag
       -o, --optional[=]<number>
       -n, --nary[=]<symbols> ...
       -N, --nary1[=]<symbols> ...
       -s, --single[=]<string>

     ERROR: getopt->parameter-list "unrecognized option" "-?"


File: slib-3b5.info,  Node: Database Macros,  Next: Database Browser,  Prev: Embedded Commands,  Up: Relational Database
                                                                              |
6.1.5 Database Macros
---------------------

`(require 'within-database)'

  The object-oriented programming interface to SLIB relational databases
has failed to support clear, understandable, and modular code-writing
for database applications.

  This seems to be a failure of the object-oriented paradigm where the
type of an object is not manifest (or even traceable) in source code.

  `within-database', along with the `databases' package, reorganizes
high-level database functions toward a more declarative style.  Using
this package, one can tag database table and command declarations for
emacs:

     etags -lscheme -r'/ *(define-\(command\|table\) (\([^; \t]+\)/\2/' \
           source1.scm ...

* Menu:

* Within-database::
* Within-database Example::


File: slib-3b5.info,  Node: Within-database,  Next: Within-database Example,  Prev: Database Macros,  Up: Database Macros
                                                                              |
6.1.5.1 Within-database
.......................

 -- Function: within-database database statement-1 ...
     `within-database' creates a lexical scope in which the commands
     `define-table' and `define-command' create tables and
     `*commands*'-table entries respectively in open relational
     database DATABASE.  The expressions in `within-database' form are
     executed in order.

     `within-database' Returns DATABASE.

 -- Syntax: define-command (<name> <rdb>) "comment" <expression1>
          <expression2> ...
 -- Syntax: define-command (<name> <rdb>) <expression1> <expression2>
          ...
     Adds to the `*commands*' table a command <name>:

          (lambda (<name> <rdb>) <expression1> <expression2> ...)


 -- Syntax: define-table <name> <descriptor-name> <descriptor-name>
          <rows>
 -- Syntax: define-table <name> <primary-key-fields> <other-fields>
          <rows>
     where <name> is the table name, <descriptor-name> is the symbol
     name of a descriptor table, <primary-key-fields> and
     <other-fields> describe the primary keys and other fields
     respectively, and <rows> is a list of data rows to be added to the
     table.

     <primary-key-fields> and <other-fields> are lists of field
     descriptors of the form:

          (<column-name> <domain>)
     or
          (<column-name> <domain> <column-integrity-rule>)

     where <column-name> is the column name, <domain> is the domain of
     the column, and <column-integrity-rule> is an expression whose
     value is a procedure of one argument (which returns `#f' to signal
     an error).

     If <domain> is not a defined domain name and it matches the name of
     this table or an already defined (in one of SPEC-0 ...) single key
     field table, a foreign-key domain will be created for it.


 -- Function: add-macro-support database
     The relational database DATABASE must be mutable.
     `add-macro-support' adds a `*macros*' table and `define-macro'
     macro to DATABASE; then DATABASE is returned.

 -- Syntax: define-macro (<name> arg1 ...) "comment" <expression1>
          <expression2> ...
 -- Syntax: define-macro (<name> arg1 ...) <expression1> <expression2>
          ...
     Adds a macro <name> to the `*macros*'.

     _Note:_ `within-database' creates lexical scope where not only
     `define-command' and `define-table', but every command and macro
     are defined, ie.:

          (within-database my-rdb
            (define-command (message rdb)
              (lambda (msg)
                (display "message: ")
                (display msg)
                (newline)))
            (message "Defining FOO...")
            ;; ... defining FOO ...
            (message "Defining BAR...")
            ;; ... defining BAR ...
            )


File: slib-3b5.info,  Node: Within-database Example,  Prev: Within-database,  Up: Database Macros
                                                                              |
6.1.5.2 Within-database Example
...............................

Here is an example of `within-database' macros:

     (require 'within-database)

     (define my-rdb
       (add-command-tables
        (create-database "foo.db" 'alist-table)))

     (within-database my-rdb
       (define-command (*initialize* rdb)
         "Print Welcome"
         (display "Welcome")
         (newline)
         rdb)
       (define-command (without-documentation rdb)
         (display "without-documentation called")
         (newline))
       (define-table (processor-family
                      ((family   atom))
                      ((also-ran processor-family)))
         (m68000  #f)
         (m68030  m68000)
         (i386    i8086)
         (i8086   #f)
         (powerpc #f))
       (define-table (platform
                      ((name symbol))
                      ((processor processor-family)
                       (os        symbol)
                       (compiler  symbol)))
         (aix              powerpc aix     -)
         ;; ...
         (amiga-aztec      m68000  amiga   aztec)
         (amiga-sas/c-5.10 m68000  amiga   sas/c)
         (atari-st-gcc     m68000  atari   gcc)
         ;; ...
         (watcom-9.0       i386    ms-dos  watcom))
       (define-command (get-processor rdb)
         "Get processor for given platform."
         (((rdb 'open-table) 'platform #f) 'get 'processor)))

     (close-database my-rdb)

     (set! my-rdb (open-command-database! "foo.db"))
     -|
     Welcome

     (my-rdb 'without-documentation)
     -|
     without-documentation called

     ((my-rdb 'get-processor) 'amiga-sas/c-5.10)
     => m68000

     (close-database my-rdb)


File: slib-3b5.info,  Node: Database Browser,  Prev: Database Macros,  Up: Relational Database
                                                                              |
6.1.6 Database Browser
----------------------

(require 'database-browse)

 -- Procedure: browse database
     Prints the names of all the tables in DATABASE and sets browse's
     default to DATABASE.

 -- Procedure: browse
     Prints the names of all the tables in the default database.

 -- Procedure: browse table-name
     For each record of the table named by the symbol TABLE-NAME,
     prints a line composed of all the field values.

 -- Procedure: browse pathname
     Opens the database named by the string PATHNAME, prints the names
     of all its tables, and sets browse's default to the database.

 -- Procedure: browse database table-name
     Sets browse's default to DATABASE and prints the records of the
     table named by the symbol TABLE-NAME.

 -- Procedure: browse pathname table-name
     Opens the database named by the string PATHNAME and sets browse's
     default to it; `browse' prints the records of the table named by
     the symbol TABLE-NAME.


File: slib-3b5.info,  Node: Relational Infrastructure,  Next: Weight-Balanced Trees,  Prev: Relational Database,  Up: Database Packages
                                                                              |
6.2 Relational Infrastructure
=============================

* Menu:

* Base Table::
* Catalog Representation::
* Relational Database Objects::
* Database Operations::


File: slib-3b5.info,  Node: Base Table,  Next: Catalog Representation,  Prev: Relational Infrastructure,  Up: Relational Infrastructure
                                                                              |
6.2.1 Base Table
----------------

A "base-table" is the primitive database layer upon which SLIB
relational databases are built.  At the minimum, it must support the
types integer, symbol, string, and boolean.  The base-table may restrict
the size of integers, symbols, and strings it supports.

  A base table implementation is available as the value of the
identifier naming it (eg. ALIST-TABLE) after requiring the symbol of
that name.

 -- Feature: alist-table
     `(require 'alist-table)' 

     Association-list base tables support all Scheme types and are
     suitable for small databases.  In order to be retrieved after
     being written to a file, the data stored should include only
     objects which are readable and writeable in the Scheme
     implementation.

     The "alist-table" base-table implementation is included in the
     SLIB distribution.

  "WB" is a B-tree database package with SCM interfaces.  Being
disk-based, WB databases readily store and access hundreds of megabytes
of data.  WB comes with two base-table embeddings.

 -- Feature: wb-table
     `(require 'wb-table)' 

     `wb-table' supports scheme expressions for keys and values whose
     text representations are less than 255 characters in length.
     *Note wb-table: (wb)wb-table.

 -- Feature: rwb-isam
     `(require 'rwb-isam)' 

     "rwb-isam" is a sophisticated base-table implementation built on
     WB and SCM which uses binary numerical formats for key and non-key
     fields.  It supports IEEE floating-point and fixed-precision
     integer keys with the correct numerical collation order.

  This rest of this section documents the interface for a base table
implementation from which the *note Relational Database:: package
constructs a Relational system.  It will be of interest primarily to
those wishing to port or write new base-table implementations.

 -- Variable: *base-table-implementations*
     To support automatic dispatch for `open-database', each base-table
     module adds an association to *BASE-TABLE-IMPLEMENTATIONS* when
     loaded.  This association is the list of the base-table symbol and
     the value returned by `(make-relational-system BASE-TABLE)'.

* Menu:

* The Base::
* Base Tables::
* Base Field Types::
* Composite Keys::
* Base Record Operations::
* Match Keys::
* Aggregate Base Operations::
* Base ISAM Operations::


File: slib-3b5.info,  Node: The Base,  Next: Base Tables,  Prev: Base Table,  Up: Base Table
                                                                              |
6.2.1.1 The Base
................

All of these functions are accessed through a single procedure by
calling that procedure with the symbol name of the operation.  A
procedure will be returned if that operation is supported and `#f'
otherwise.  For example:

     (require 'alist-table)
     (define my-base (alist-table 'make-base))
     my-base         => *a procedure*
     (define foo (alist-table 'foo))
     foo             => #f

 -- Operation on base-table: make-base filename key-dimension
          column-types
     Returns a new, open, low-level database (collection of tables)
     associated with FILENAME.  This returned database has an empty
     table associated with CATALOG-ID.  The positive integer
     KEY-DIMENSION is the number of keys composed to make a PRIMARY-KEY
     for the catalog table.  The list of symbols COLUMN-TYPES describes
     the types of each column for that table.  If the database cannot
     be created as specified, `#f' is returned.

     Calling the `close-base' method on this database and possibly other
     operations will cause FILENAME to be written to.  If FILENAME is
     `#f' a temporary, non-disk based database will be created if such
     can be supported by the base table implelentation.

 -- Operation on base-table: open-base filename mutable
     Returns an open low-level database associated with FILENAME.  If
     MUTABLE is `#t', this database will have methods capable of
     effecting change to the database.  If MUTABLE is `#f', only
     methods for inquiring the database will be available.  If the
     database cannot be opened as specified `#f' is returned.

     Calling the `close-base' (and possibly other) method on a MUTABLE
     database will cause FILENAME to be written to.

 -- Operation on base-table: write-base lldb filename
     Causes the low-level database LLDB to be written to FILENAME.  If
     the write is successful, also causes LLDB to henceforth be
     associated with FILENAME.  Calling the `close-database' (and
     possibly other) method on LLDB may cause FILENAME to be written
     to.  If FILENAME is `#f' this database will be changed to a
     temporary, non-disk based database if such can be supported by the
     underlying base table implelentation.  If the operations completed
     successfully, `#t' is returned.  Otherwise, `#f' is returned.

 -- Operation on base-table: sync-base lldb
     Causes the file associated with the low-level database LLDB to be
     updated to reflect its current state.  If the associated filename
     is `#f', no action is taken and `#f' is returned.  If this
     operation completes successfully, `#t' is returned.  Otherwise,
     `#f' is returned.

 -- Operation on base-table: close-base lldb
     Causes the low-level database LLDB to be written to its associated
     file (if any).  If the write is successful, subsequent operations
     to LLDB will signal an error.  If the operations complete
     successfully, `#t' is returned.  Otherwise, `#f' is returned.


File: slib-3b5.info,  Node: Base Tables,  Next: Base Field Types,  Prev: The Base,  Up: Base Table
                                                                              |
6.2.1.2 Base Tables
...................

 -- Operation on base-table: make-table lldb key-dimension column-types
     Returns the ordinal BASE-ID for a new base table, otherwise
     returns `#f'.  The base table can then be opened using
     `(open-table LLDB BASE-ID)'.  The positive integer KEY-DIMENSION
     is the number of keys composed to make a PRIMARY-KEY for this
     table.  The list of symbols COLUMN-TYPES describes the types of
     each column.

 -- Operation on base-table: open-table lldb base-id key-dimension
          column-types
     Returns a HANDLE for an existing base table in the low-level
     database LLDB if that table exists and can be opened in the mode
     indicated by MUTABLE, otherwise returns `#f'.

     As with `make-table', the positive integer KEY-DIMENSION is the
     number of keys composed to make a PRIMARY-KEY for this table.  The
     list of symbols COLUMN-TYPES describes the types of each column.

 -- Operation on base-table: kill-table lldb base-id key-dimension
          column-types
     Returns `#t' if the base table associated with BASE-ID was removed
     from the low level database LLDB, and `#f' otherwise.

 -- Operation on base-table: catalog-id
     A constant BASE-ID ordinal suitable for passing as a parameter to
     `open-table'.  CATALOG-ID will be used as the base table for the
     system catalog.


File: slib-3b5.info,  Node: Base Field Types,  Next: Composite Keys,  Prev: Base Tables,  Up: Base Table
                                                                              |
6.2.1.3 Base Field Types
........................

 -- Operation on base-table: supported-type? symbol
     Returns `#t' if SYMBOL names a type allowed as a column value by
     the implementation, and `#f' otherwise.  At a minimum, an
     implementation must support the types `integer', `ordinal',
     `symbol', `string', and `boolean'.

 -- Operation on base-table: supported-key-type? symbol
     Returns `#t' if SYMBOL names a type allowed as a key value by the
     implementation, and `#f' otherwise.  At a minimum, an
     implementation must support the types `ordinal', and `symbol'.

An "ordinal" is an exact positive integer.  The other types are
standard Scheme.


File: slib-3b5.info,  Node: Composite Keys,  Next: Base Record Operations,  Prev: Base Field Types,  Up: Base Table
                                                                              |
6.2.1.4 Composite Keys
......................

 -- Operation on base-table: make-keyifier-1 type
     Returns a procedure which accepts a single argument which must be
     of type TYPE.  This returned procedure returns an object suitable
     for being a KEY argument in the functions whose descriptions
     follow.

     Any 2 arguments of the supported type passed to the returned
     function which are not `equal?' must result in returned values
     which are not `equal?'.

 -- Operation on base-table: make-list-keyifier key-dimension types
     The list of symbols TYPES must have at least KEY-DIMENSION
     elements.  Returns a procedure which accepts a list of length
     KEY-DIMENSION and whose types must corresopond to the types named
     by TYPES.  This returned procedure combines the elements of its
     list argument into an object suitable for being a KEY argument in
     the functions whose descriptions follow.

     Any 2 lists of supported types (which must at least include
     symbols and non-negative integers) passed to the returned function
     which are not `equal?' must result in returned values which are not
     `equal?'.

 -- Operation on base-table: make-key-extractor key-dimension types
          column-number
     Returns a procedure which accepts objects produced by application
     of the result of `(make-list-keyifier KEY-DIMENSION TYPES)'.  This
     procedure returns a KEY which is `equal?' to the COLUMN-NUMBERth
     element of the list which was passed to create COMPOSITE-KEY.  The
     list TYPES must have at least KEY-DIMENSION elements.

 -- Operation on base-table: make-key->list key-dimension types
     Returns a procedure which accepts objects produced by application
     of the result of `(make-list-keyifier KEY-DIMENSION TYPES)'.  This
     procedure returns a list of KEYs which are elementwise `equal?' to
     the list which was passed to create COMPOSITE-KEY.


File: slib-3b5.info,  Node: Base Record Operations,  Next: Match Keys,  Prev: Composite Keys,  Up: Base Table
                                                                              |
6.2.1.5 Base Record Operations
..............................

In the following functions, the KEY argument can always be assumed to
be the value returned by a call to a _keyify_ routine.

 -- Operation on base-table: present? handle key
     Returns a non-`#f' value if there is a row associated with KEY in
     the table opened in HANDLE and `#f' otherwise.

 -- Operation on base-table: make-getter key-dimension types
     Returns a procedure which takes arguments HANDLE and KEY.  This
     procedure returns a list of the non-primary values of the relation
     (in the base table opened in HANDLE) whose primary key is KEY if
     it exists, and `#f' otherwise.

`make-getter-1' is a new operation.  The relational-database module
works with older base-table implementations by using `make-getter'.

 -- Operation on base-table: make-getter-1 key-dimension types index
     Returns a procedure which takes arguments HANDLE and KEY.  This
     procedure returns the value of the INDEXth field (in the base
     table opened in HANDLE) whose primary key is KEY if it exists, and
     `#f' otherwise.

     INDEX must be larger than KEY-DIMENSION.

 -- Operation on base-table: make-putter key-dimension types
     Returns a procedure which takes arguments HANDLE and KEY and
     VALUE-LIST.  This procedure associates the primary key KEY with
     the values in VALUE-LIST (in the base table opened in HANDLE) and
     returns an unspecified value.

 -- Operation on base-table: delete handle key
     Removes the row associated with KEY from the table opened in
     HANDLE.  An unspecified value is returned.


File: slib-3b5.info,  Node: Match Keys,  Next: Aggregate Base Operations,  Prev: Base Record Operations,  Up: Base Table
                                                                              |
6.2.1.6 Match Keys
..................

A MATCH-KEYS argument is a list of length equal to the number of
primary keys.  The MATCH-KEYS restrict the actions of the table command
to those records whose primary keys all satisfy the corresponding
element of the MATCH-KEYS list.  The elements and their actions are:

    `#f'
          The false value matches any key in the corresponding position.

    an object of type procedure
          This procedure must take a single argument, the key in the
          corresponding position.  Any key for which the procedure
          returns a non-false value is a match; Any key for which the
          procedure returns a `#f' is not.

    other values
          Any other value matches only those keys `equal?' to it.


File: slib-3b5.info,  Node: Aggregate Base Operations,  Next: Base ISAM Operations,  Prev: Match Keys,  Up: Base Table
                                                                              |
6.2.1.7 Aggregate Base Operations
.................................

The KEY-DIMENSION and COLUMN-TYPES arguments are needed to decode the
composite-keys for matching with MATCH-KEYS.

 -- Operation on base-table: delete* handle key-dimension column-types
          match-keys
     Removes all rows which satisfy MATCH-KEYS from the table opened in
     HANDLE.  An unspecified value is returned.

 -- Operation on base-table: for-each-key handle procedure
          key-dimension column-types match-keys
     Calls PROCEDURE once with each KEY in the table opened in HANDLE
     which satisfy MATCH-KEYS in an unspecified order.  An unspecified
     value is returned.

 -- Operation on base-table: map-key handle procedure key-dimension
          column-types match-keys
     Returns a list of the values returned by calling PROCEDURE once
     with each KEY in the table opened in HANDLE which satisfy
     MATCH-KEYS in an unspecified order.


File: slib-3b5.info,  Node: Base ISAM Operations,  Prev: Aggregate Base Operations,  Up: Base Table
                                                                              |
6.2.1.8 Base ISAM Operations
............................

These operations are optional for a Base-Table implementation.

 -- Operation on base-table: ordered-for-each-key handle procedure
          key-dimension column-types match-keys
     Calls PROCEDURE once with each KEY in the table opened in HANDLE
     which satisfy MATCH-KEYS in the natural order for the types of the
     primary key fields of that table.  An unspecified value is
     returned.

 -- Operation on base-table: make-nexter handle key-dimension
          column-types index
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     key-list identifying the lowest record higher than KEY1 KEY2 ...
     which is stored in the base-table and which differs in column
     INDEX or a lower indexed key; or false if no higher record is
     present.

 -- Operation on base-table: make-prever handle key-dimension
          column-types index
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     key-list identifying the highest record less than KEY1 KEY2 ...
     which is stored in the base-table and which differs in column
     INDEX or a lower indexed key; or false if no higher record is
     present.


File: slib-3b5.info,  Node: Catalog Representation,  Next: Relational Database Objects,  Prev: Base Table,  Up: Relational Infrastructure
                                                                              |
6.2.2 Catalog Representation
----------------------------

Each database (in an implementation) has a "system catalog" which
describes all the user accessible tables in that database (including
itself).

The system catalog base table has the following fields.  `PRI'
indicates a primary key for that table.

     PRI table-name
         column-limit            the highest column number
         coltab-name             descriptor table name
         bastab-id               data base table identifier
         user-integrity-rule
         view-procedure          A scheme thunk which, when called,
                                 produces a handle for the view.  coltab
                                 and bastab are specified if and only if
                                 view-procedure is not.

Descriptors for base tables (not views) are tables (pointed to by
system catalog).  Descriptor (base) tables have the fields:

     PRI column-number           sequential integers from 1
         primary-key?            boolean TRUE for primary key components
         column-name
         column-integrity-rule
         domain-name

A "primary key" is any column marked as `primary-key?' in the
corresponding descriptor table.  All the `primary-key?' columns must
have lower column numbers than any non-`primary-key?' columns.  Every
table must have at least one primary key.  Primary keys must be
sufficient to distinguish all rows from each other in the table.  All of
the system defined tables have a single primary key.

A "domain" is a category describing the allowable values to occur in a
column.  It is described by a (base) table with the fields:

     PRI domain-name
         foreign-table
         domain-integrity-rule
         type-id
         type-param

The "type-id" field value is a symbol.  This symbol may be used by the
underlying base table implementation in storing that field.

If the `foreign-table' field is non-`#f' then that field names a table
from the catalog.  The values for that domain must match a primary key
of the table referenced by the TYPE-PARAM (or `#f', if allowed).  This
package currently does not support composite foreign-keys.

The types for which support is planned are:
         atom
         symbol
         string                  [<length>]
         number                  [<base>]
         money                   <currency>
         date-time
         boolean

         foreign-key             <table-name>
         expression
         virtual                 <expression>


File: slib-3b5.info,  Node: Relational Database Objects,  Next: Database Operations,  Prev: Catalog Representation,  Up: Relational Infrastructure
                                                                              |
6.2.3 Relational Database Objects
---------------------------------

This object-oriented interface is deprecated for typical database
applications; *note Using Databases:: provides an application programmer
interface which is easier to understand and use.

 -- Function: make-relational-system base-table-implementation
     Returns a procedure implementing a relational database using the
     BASE-TABLE-IMPLEMENTATION.

     All of the operations of a base table implementation are accessed
     through a procedure defined by `require'ing that implementation.
     Similarly, all of the operations of the relational database
     implementation are accessed through the procedure returned by
     `make-relational-system'.  For instance, a new relational database
     could be created from the procedure returned by
     `make-relational-system' by:

          (require 'alist-table)
          (define relational-alist-system
                  (make-relational-system alist-table))
          (define create-alist-database
                  (relational-alist-system 'create-database))
          (define my-database
                  (create-alist-database "mydata.db"))

What follows are the descriptions of the methods available from
relational system returned by a call to `make-relational-system'.

 -- Operation on relational-system: create-database filename
     Returns an open, nearly empty relational database associated with
     FILENAME.  The only tables defined are the system catalog and
     domain table.  Calling the `close-database' method on this database
     and possibly other operations will cause FILENAME to be written
     to.  If FILENAME is `#f' a temporary, non-disk based database will
     be created if such can be supported by the underlying base table
     implelentation.  If the database cannot be created as specified
     `#f' is returned.  For the fields and layout of descriptor tables,
     *note Catalog Representation::

 -- Operation on relational-system: open-database filename mutable?
     Returns an open relational database associated with FILENAME.  If
     MUTABLE? is `#t', this database will have methods capable of
     effecting change to the database.  If MUTABLE? is `#f', only
     methods for inquiring the database will be available.  Calling the
     `close-database' (and possibly other) method on a MUTABLE?
     database will cause FILENAME to be written to.  If the database
     cannot be opened as specified `#f' is returned.


File: slib-3b5.info,  Node: Database Operations,  Prev: Relational Database Objects,  Up: Relational Infrastructure
                                                                              |
6.2.4 Database Operations
-------------------------

This object-oriented interface is deprecated for typical database
applications; *note Using Databases:: provides an application programmer
interface which is easier to understand and use.

These are the descriptions of the methods available from an open
relational database.  A method is retrieved from a database by calling
the database with the symbol name of the operation.  For example:

     (define my-database
             (create-alist-database "mydata.db"))
     (define telephone-table-desc
             ((my-database 'create-table) 'telephone-table-desc))

 -- Operation on relational-database: close-database
     Causes the relational database to be written to its associated
     file (if any).  If the write is successful, subsequent operations
     to this database will signal an error.  If the operations completed
     successfully, `#t' is returned.  Otherwise, `#f' is returned.

 -- Operation on relational-database: write-database filename
     Causes the relational database to be written to FILENAME.  If the
     write is successful, also causes the database to henceforth be
     associated with FILENAME.  Calling the `close-database' (and
     possibly other) method on this database will cause FILENAME to be
     written to.  If FILENAME is `#f' this database will be changed to
     a temporary, non-disk based database if such can be supported by
     the underlying base table implelentation.  If the operations
     completed successfully, `#t' is returned.  Otherwise, `#f' is
     returned.

 -- Operation on relational-database: sync-database
     Causes any pending updates to the database file to be written out.
     If the operations completed successfully, `#t' is returned.
     Otherwise, `#f' is returned.

 -- Operation on relational-database: solidify-database
     Causes any pending updates to the database file to be written out.
     If the writes completed successfully, then the database is changed
     to be immutable and `#t' is returned.  Otherwise, `#f' is returned.

 -- Operation on relational-database: table-exists? table-name
     Returns `#t' if TABLE-NAME exists in the system catalog, otherwise
     returns `#f'.

 -- Operation on relational-database: open-table table-name mutable?
     Returns a "methods" procedure for an existing relational table in
     this database if it exists and can be opened in the mode indicated
     by MUTABLE?, otherwise returns `#f'.

These methods will be present only in mutable databases.

 -- Operation on relational-database: delete-table table-name
     Removes and returns the TABLE-NAME row from the system catalog if
     the table or view associated with TABLE-NAME gets removed from the
     database, and `#f' otherwise.

 -- Operation on relational-database: create-table table-desc-name
     Returns a methods procedure for a new (open) relational table for
     describing the columns of a new base table in this database,
     otherwise returns `#f'.  For the fields and layout of descriptor
     tables, *Note Catalog Representation::.

 -- Operation on relational-database: create-table table-name
          table-desc-name
     Returns a methods procedure for a new (open) relational table with
     columns as described by TABLE-DESC-NAME, otherwise returns `#f'.

 -- Operation on relational-database: create-view ??
 -- Operation on relational-database: project-table ??
 -- Operation on relational-database: restrict-table ??
 -- Operation on relational-database: cart-prod-tables ??
     Not yet implemented.


File: slib-3b5.info,  Node: Weight-Balanced Trees,  Prev: Relational Infrastructure,  Up: Database Packages
                                                                              |
6.3 Weight-Balanced Trees
=========================

`(require 'wt-tree)' 

  Balanced binary trees are a useful data structure for maintaining
large sets of ordered objects or sets of associations whose keys are
ordered.  MIT Scheme has an comprehensive implementation of
weight-balanced binary trees which has several advantages over the
other data structures for large aggregates:

   * In addition to the usual element-level operations like insertion,
     deletion and lookup, there is a full complement of collection-level
     operations, like set intersection, set union and subset test, all
     of which are implemented with good orders of growth in time and
     space.  This makes weight balanced trees ideal for rapid
     prototyping of functionally derived specifications.

   * An element in a tree may be indexed by its position under the
     ordering of the keys, and the ordinal position of an element may
     be determined, both with reasonable efficiency.

   * Operations to find and remove minimum element make weight balanced
     trees simple to use for priority queues.

   * The implementation is _functional_ rather than _imperative_.  This
     means that operations like `inserting' an association in a tree do
     not destroy the old tree, in much the same way that `(+ 1 x)'
     modifies neither the constant 1 nor the value bound to `x'.  The
     trees are referentially transparent thus the programmer need not
     worry about copying the trees.  Referential transparency allows
     space efficiency to be achieved by sharing subtrees.


  These features make weight-balanced trees suitable for a wide range of
applications, especially those that require large numbers of sets or
discrete maps.  Applications that have a few global databases and/or
concentrate on element-level operations like insertion and lookup are
probably better off using hash-tables or red-black trees.

  The _size_ of a tree is the number of associations that it contains.
Weight balanced binary trees are balanced to keep the sizes of the
subtrees of each node within a constant factor of each other.  This
ensures logarithmic times for single-path operations (like lookup and
insertion).  A weight balanced tree takes space that is proportional to
the number of associations in the tree.  For the current
implementation, the constant of proportionality is six words per
association.

  Weight balanced trees can be used as an implementation for either
discrete sets or discrete maps (associations).  Sets are implemented by
ignoring the datum that is associated with the key.  Under this scheme
if an associations exists in the tree this indicates that the key of the
association is a member of the set.  Typically a value such as `()',
`#t' or `#f' is associated with the key.

  Many operations can be viewed as computing a result that, depending on
whether the tree arguments are thought of as sets or maps, is known by
two different names.  An example is `wt-tree/member?', which, when
regarding the tree argument as a set, computes the set membership
operation, but, when regarding the tree as a discrete map,
`wt-tree/member?' is the predicate testing if the map is defined at an
element in its domain.  Most names in this package have been chosen
based on interpreting the trees as sets, hence the name
`wt-tree/member?' rather than `wt-tree/defined-at?'.

  The weight balanced tree implementation is a run-time-loadable option.
To use weight balanced trees, execute

     (load-option 'wt-tree)
  
once before calling any of the procedures defined here.

* Menu:

* Construction of Weight-Balanced Trees::
* Basic Operations on Weight-Balanced Trees::
* Advanced Operations on Weight-Balanced Trees::
* Indexing Operations on Weight-Balanced Trees::


File: slib-3b5.info,  Node: Construction of Weight-Balanced Trees,  Next: Basic Operations on Weight-Balanced Trees,  Prev: Weight-Balanced Trees,  Up: Weight-Balanced Trees
                                                                              |
6.3.1 Construction of Weight-Balanced Trees
-------------------------------------------

Binary trees require there to be a total order on the keys used to
arrange the elements in the tree.  Weight balanced trees are organized
by _types_, where the type is an object encapsulating the ordering
relation.  Creating a tree is a two-stage process.  First a tree type
must be created from the predicate which gives the ordering.  The tree
type is then used for making trees, either empty or singleton trees or
trees from other aggregate structures like association lists.  Once
created, a tree `knows' its type and the type is used to test
compatibility between trees in operations taking two trees.  Usually a
small number of tree types are created at the beginning of a program and
used many times throughout the program's execution.

 -- procedure+: make-wt-tree-type key<?
     This procedure creates and returns a new tree type based on the
     ordering predicate KEY<?.  KEY<? must be a total ordering, having
     the property that for all key values `a', `b' and `c':

          (key<? a a)                         => #f
          (and (key<? a b) (key<? b a))       => #f
          (if (and (key<? a b) (key<? b c))
              (key<? a c)
              #t)                             => #t

     Two key values are assumed to be equal if neither is less than the
     other by KEY<?.

     Each call to `make-wt-tree-type' returns a distinct value, and
     trees are only compatible if their tree types are `eq?'.  A
     consequence is that trees that are intended to be used in binary
     tree operations must all be created with a tree type originating
     from the same call to `make-wt-tree-type'.

 -- variable+: number-wt-type
     A standard tree type for trees with numeric keys.  `Number-wt-type'
     could have been defined by

          (define number-wt-type (make-wt-tree-type  <))

 -- variable+: string-wt-type
     A standard tree type for trees with string keys.  `String-wt-type'
     could have been defined by

          (define string-wt-type (make-wt-tree-type  string<?))

 -- procedure+: make-wt-tree wt-tree-type
     This procedure creates and returns a newly allocated weight
     balanced tree.  The tree is empty, i.e. it contains no
     associations.  WT-TREE-TYPE is a weight balanced tree type
     obtained by calling `make-wt-tree-type'; the returned tree has
     this type.

 -- procedure+: singleton-wt-tree wt-tree-type key datum
     This procedure creates and returns a newly allocated weight
     balanced tree.  The tree contains a single association, that of
     DATUM with KEY.  WT-TREE-TYPE is a weight balanced tree type
     obtained by calling `make-wt-tree-type'; the returned tree has
     this type.

 -- procedure+: alist->wt-tree tree-type alist
     Returns a newly allocated weight-balanced tree that contains the
     same associations as ALIST.  This procedure is equivalent to:

          (lambda (type alist)
            (let ((tree (make-wt-tree type)))
              (for-each (lambda (association)
                          (wt-tree/add! tree
                                        (car association)
                                        (cdr association)))
                        alist)
              tree))


File: slib-3b5.info,  Node: Basic Operations on Weight-Balanced Trees,  Next: Advanced Operations on Weight-Balanced Trees,  Prev: Construction of Weight-Balanced Trees,  Up: Weight-Balanced Trees
                                                                              |
6.3.2 Basic Operations on Weight-Balanced Trees
-----------------------------------------------

This section describes the basic tree operations on weight balanced
trees.  These operations are the usual tree operations for insertion,
deletion and lookup, some predicates and a procedure for determining the
number of associations in a tree.

 -- procedure+: wt-tree/empty? wt-tree
     Returns `#t' if WT-TREE contains no associations, otherwise
     returns `#f'.

 -- procedure+: wt-tree/size wt-tree
     Returns the number of associations in WT-TREE, an exact
     non-negative integer.  This operation takes constant time.

 -- procedure+: wt-tree/add wt-tree key datum
     Returns a new tree containing all the associations in WT-TREE and
     the association of DATUM with KEY.  If WT-TREE already had an
     association for KEY, the new association overrides the old.  The
     average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in
     WT-TREE.

 -- procedure+: wt-tree/add! wt-tree key datum
     Associates DATUM with KEY in WT-TREE and returns an unspecified
     value.  If WT-TREE already has an association for KEY, that
     association is replaced.  The average and worst-case times
     required by this operation are proportional to the logarithm of
     the number of associations in WT-TREE.

 -- procedure+: wt-tree/member? key wt-tree
     Returns `#t' if WT-TREE contains an association for KEY, otherwise
     returns `#f'.  The average and worst-case times required by this
     operation are proportional to the logarithm of the number of
     associations in WT-TREE.

 -- procedure+: wt-tree/lookup wt-tree key default
     Returns the datum associated with KEY in WT-TREE.  If WT-TREE
     doesn't contain an association for KEY, DEFAULT is returned.  The
     average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in
     WT-TREE.

 -- procedure+: wt-tree/delete wt-tree key
     Returns a new tree containing all the associations in WT-TREE,
     except that if WT-TREE contains an association for KEY, it is
     removed from the result.  The average and worst-case times required
     by this operation are proportional to the logarithm of the number
     of associations in WT-TREE.

 -- procedure+: wt-tree/delete! wt-tree key
     If WT-TREE contains an association for KEY the association is
     removed.  Returns an unspecified value.  The average and worst-case
     times required by this operation are proportional to the logarithm
     of the number of associations in WT-TREE.


File: slib-3b5.info,  Node: Advanced Operations on Weight-Balanced Trees,  Next: Indexing Operations on Weight-Balanced Trees,  Prev: Basic Operations on Weight-Balanced Trees,  Up: Weight-Balanced Trees
                                                                              |
6.3.3 Advanced Operations on Weight-Balanced Trees
--------------------------------------------------

In the following the _size_ of a tree is the number of associations
that the tree contains, and a _smaller_ tree contains fewer
associations.

 -- procedure+: wt-tree/split< wt-tree bound
     Returns a new tree containing all and only the associations in
     WT-TREE which have a key that is less than BOUND in the ordering
     relation of the tree type of WT-TREE.  The average and worst-case
     times required by this operation are proportional to the logarithm
     of the size of WT-TREE.

 -- procedure+: wt-tree/split> wt-tree bound
     Returns a new tree containing all and only the associations in
     WT-TREE which have a key that is greater than BOUND in the
     ordering relation of the tree type of WT-TREE.  The average and
     worst-case times required by this operation are proportional to the
     logarithm of size of WT-TREE.

 -- procedure+: wt-tree/union wt-tree-1 wt-tree-2
     Returns a new tree containing all the associations from both trees.
     This operation is asymmetric: when both trees have an association
     for the same key, the returned tree associates the datum from
     WT-TREE-2 with the key.  Thus if the trees are viewed as discrete
     maps then `wt-tree/union' computes the map override of WT-TREE-1 by
     WT-TREE-2.  If the trees are viewed as sets the result is the set
     union of the arguments.  The worst-case time required by this
     operation is proportional to the sum of the sizes of both trees.
     If the minimum key of one tree is greater than the maximum key of
     the other tree then the time required is at worst proportional to
     the logarithm of the size of the larger tree.

 -- procedure+: wt-tree/intersection wt-tree-1 wt-tree-2
     Returns a new tree containing all and only those associations from
     WT-TREE-1 which have keys appearing as the key of an association
     in WT-TREE-2.  Thus the associated data in the result are those
     from WT-TREE-1.  If the trees are being used as sets the result is
     the set intersection of the arguments.  As a discrete map
     operation, `wt-tree/intersection' computes the domain restriction
     of WT-TREE-1 to (the domain of) WT-TREE-2.  The time required by
     this operation is never worse that proportional to the sum of the
     sizes of the trees.

 -- procedure+: wt-tree/difference wt-tree-1 wt-tree-2
     Returns a new tree containing all and only those associations from
     WT-TREE-1 which have keys that _do not_ appear as the key of an
     association in WT-TREE-2.  If the trees are viewed as sets the
     result is the asymmetric set difference of the arguments.  As a
     discrete map operation, it computes the domain restriction of
     WT-TREE-1 to the complement of (the domain of) WT-TREE-2.  The
     time required by this operation is never worse that proportional to
     the sum of the sizes of the trees.

 -- procedure+: wt-tree/subset? wt-tree-1 wt-tree-2
     Returns `#t' iff the key of each association in WT-TREE-1 is the
     key of some association in WT-TREE-2, otherwise returns `#f'.
     Viewed as a set operation, `wt-tree/subset?' is the improper subset
     predicate.  A proper subset predicate can be constructed:

          (define (proper-subset? s1 s2)
            (and (wt-tree/subset? s1 s2)
                 (< (wt-tree/size s1) (wt-tree/size s2))))

     As a discrete map operation, `wt-tree/subset?' is the subset test
     on the domain(s) of the map(s).  In the worst-case the time
     required by this operation is proportional to the size of
     WT-TREE-1.

 -- procedure+: wt-tree/set-equal? wt-tree-1 wt-tree-2
     Returns `#t' iff for every association in WT-TREE-1 there is an
     association in WT-TREE-2 that has the same key, and _vice versa_.

     Viewing the arguments as sets `wt-tree/set-equal?' is the set
     equality predicate.  As a map operation it determines if two maps
     are defined on the same domain.

     This procedure is equivalent to

          (lambda (wt-tree-1 wt-tree-2)
            (and (wt-tree/subset? wt-tree-1 wt-tree-2
                 (wt-tree/subset? wt-tree-2 wt-tree-1)))

     In the worst-case the time required by this operation is
     proportional to the size of the smaller tree.

 -- procedure+: wt-tree/fold combiner initial wt-tree
     This procedure reduces WT-TREE by combining all the associations,
     using an reverse in-order traversal, so the associations are
     visited in reverse order.  COMBINER is a procedure of three
     arguments: a key, a datum and the accumulated result so far.
     Provided COMBINER takes time bounded by a constant, `wt-tree/fold'
     takes time proportional to the size of WT-TREE.

     A sorted association list can be derived simply:

          (wt-tree/fold  (lambda (key datum list)
                           (cons (cons key datum) list))
                         '()
                         WT-TREE))

     The data in the associations can be summed like this:

          (wt-tree/fold  (lambda (key datum sum) (+ sum datum))
                         0
                         WT-TREE)

 -- procedure+: wt-tree/for-each action wt-tree
     This procedure traverses the tree in-order, applying ACTION to
     each association.  The associations are processed in increasing
     order of their keys.  ACTION is a procedure of two arguments which
     take the key and datum respectively of the association.  Provided
     ACTION takes time bounded by a constant, `wt-tree/for-each' takes
     time proportional to in the size of WT-TREE.  The example prints
     the tree:

          (wt-tree/for-each (lambda (key value)
                              (display (list key value)))
                            WT-TREE))

 -- procedure+: wt-tree/union-merge wt-tree-1 wt-tree-2 merge                 |
     Returns a new tree containing all the associations from both             |
     trees.  If both trees have an association for the same key, the          |
     datum associated with that key in the result tree is computed by         |
     applying the procedure MERGE to the key, the value from WT-TREE-1        |
     and the value from WT-TREE-2.  MERGE is of the form                      |
                                                                              |
          (lambda (KEY DATUM-1 DATUM-2) ...)                                  |
                                                                              |
     If some key occurs only in one tree, that association will appear        |
     in the result tree without being processed by MERGE, so for this         |
     operation to make sense, either MERGE must have both a right and         |
     left identity that correspond to the association being absent in         |
     one of the trees, or some guarantee must be made, for example, all       |
     the keys in one tree are known to occur in the other.                    |
                                                                              |
     These are all reasonable procedures for MERGE                            |
                                                                              |
          (lambda (key val1 val2) (+ val1 val2))                              |
          (lambda (key val1 val2) (append val1 val2))                         |
          (lambda (key val1 val2) (wt-tree/union val1 val2))                  |
                                                                              |
     However, a procedure like                                                |
                                                                              |
          (lambda (key val1 val2) (- val1 val2))                              |
                                                                              |
     would result in a subtraction of the data for all associations           |
     with keys occuring in both trees but associations with keys              |
     occuring in only the second tree would be copied, not negated, as        |
     is presumably be intent.  The programmer might ensure that this          |
     never happens.                                                           |
                                                                              |
     This procedure has the same time behavior as `wt-tree/union' but         |
     with a slightly worse constant factor.  Indeed, `wt-tree/union'          |
     might have been defined like this:                                       |
                                                                              |
          (define (wt-tree/union tree1 tree2)                                 |
            (wt-tree/union-merge tree1 tree2                                  |
                                 (lambda (key val1 val2) val2)))              |
                                                                              |
  The MERGE procedure takes the KEY as a parameter in case the data are       |
not independent of the key.                                                   |
                                                                              |

File: slib-3b5.info,  Node: Indexing Operations on Weight-Balanced Trees,  Prev: Advanced Operations on Weight-Balanced Trees,  Up: Weight-Balanced Trees
                                                                              |
6.3.4 Indexing Operations on Weight-Balanced Trees
--------------------------------------------------

Weight balanced trees support operations that view the tree as sorted
sequence of associations.  Elements of the sequence can be accessed by
position, and the position of an element in the sequence can be
determined, both in logarthmic time.

 -- procedure+: wt-tree/index wt-tree index
 -- procedure+: wt-tree/index-datum wt-tree index
 -- procedure+: wt-tree/index-pair wt-tree index
     Returns the 0-based INDEXth association of WT-TREE in the sorted
     sequence under the tree's ordering relation on the keys.
     `wt-tree/index' returns the INDEXth key, `wt-tree/index-datum'
     returns the datum associated with the INDEXth key and
     `wt-tree/index-pair' returns a new pair `(KEY . DATUM)' which is
     the `cons' of the INDEXth key and its datum.  The average and
     worst-case times required by this operation are proportional to
     the logarithm of the number of associations in the tree.

     These operations signal an error if the tree is empty, if
     INDEX`<0', or if INDEX is greater than or equal to the number of
     associations in the tree.

     Indexing can be used to find the median and maximum keys in the
     tree as follows:

     median:  (wt-tree/index WT-TREE (quotient (wt-tree/size WT-TREE) 2))

     maximum: (wt-tree/index WT-TREE (-1+ (wt-tree/size WT-TREE)))

 -- procedure+: wt-tree/rank wt-tree key
     Determines the 0-based position of KEY in the sorted sequence of
     the keys under the tree's ordering relation, or `#f' if the tree
     has no association with for KEY.  This procedure returns either an
     exact non-negative integer or `#f'.  The average and worst-case
     times required by this operation are proportional to the logarithm
     of the number of associations in the tree.

 -- procedure+: wt-tree/min wt-tree
 -- procedure+: wt-tree/min-datum wt-tree
 -- procedure+: wt-tree/min-pair wt-tree
     Returns the association of WT-TREE that has the least key under
     the tree's ordering relation.  `wt-tree/min' returns the least key,
     `wt-tree/min-datum' returns the datum associated with the least key
     and `wt-tree/min-pair' returns a new pair `(key . datum)' which is
     the `cons' of the minimum key and its datum.  The average and
     worst-case times required by this operation are proportional to the
     logarithm of the number of associations in the tree.

     These operations signal an error if the tree is empty.  They could
     be written
          (define (wt-tree/min tree)        (wt-tree/index tree 0))
          (define (wt-tree/min-datum tree)  (wt-tree/index-datum tree 0))
          (define (wt-tree/min-pair tree)   (wt-tree/index-pair tree 0))

 -- procedure+: wt-tree/delete-min wt-tree
     Returns a new tree containing all of the associations in WT-TREE
     except the association with the least key under the WT-TREE's
     ordering relation.  An error is signalled if the tree is empty.
     The average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in the
     tree.  This operation is equivalent to

          (wt-tree/delete WT-TREE (wt-tree/min WT-TREE))

 -- procedure+: wt-tree/delete-min! wt-tree
     Removes the association with the least key under the WT-TREE's
     ordering relation.  An error is signalled if the tree is empty.
     The average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in the
     tree.  This operation is equivalent to

          (wt-tree/delete! WT-TREE (wt-tree/min WT-TREE))


File: slib-3b5.info,  Node: Other Packages,  Next: About SLIB,  Prev: Database Packages,  Up: Top
                                                                              |
7 Other Packages
****************

* Menu:

* Data Structures::             Various data structures.
* Sorting and Searching::
* Procedures::                  Miscellaneous utility procedures.
* Standards Support::           Support for Scheme Standards.
* Session Support::             REPL and Debugging.
* System Interface::            'system, 'getenv, and other programs.
* Extra-SLIB Packages::         Outside the envelope.


File: slib-3b5.info,  Node: Data Structures,  Next: Sorting and Searching,  Prev: Other Packages,  Up: Other Packages
                                                                              |
7.1 Data Structures
===================

* Menu:

* Arrays::                      'array
* Subarrays::                   'subarray
* Array Mapping::               'array-for-each
* Array Interpolation::         'array-interpolate
* Association Lists::           'alist
* Byte::                        'byte
* Byte/Number Conversions::     'byte-number
* MAT-File Format::             'matfile
* Portable Image Files::        'pnm
* Collections::                 'collect
* Dynamic Data Type::           'dynamic
* Hash Tables::                 'hash-table
* Object::                      'object
* Priority Queues::             'priority-queue
* Queues::                      'queue
* Records::                     'record


File: slib-3b5.info,  Node: Arrays,  Next: Subarrays,  Prev: Data Structures,  Up: Data Structures
                                                                              |
7.1.1 Arrays
------------

`(require 'array)' or `(require 'srfi-63)' 

 -- Function: array? obj
     Returns `#t' if the OBJ is an array, and `#f' if not.

_Note:_ Arrays are not disjoint from other Scheme types.  Vectors and
possibly strings also satisfy `array?'.  A disjoint array predicate can
be written:

     (define (strict-array? obj)
       (and (array? obj) (not (string? obj)) (not (vector? obj))))

 -- Function: equal? obj1 obj2
     Returns `#t' if OBJ1 and OBJ2 have the same rank and dimensions
     and the corresponding elements of OBJ1 and OBJ2 are `equal?'.

     `equal?' recursively compares the contents of pairs, vectors,
     strings, and _arrays_, applying `eqv?' on other objects such as
     numbers and symbols.  A rule of thumb is that objects are
     generally `equal?' if they print the same.  `equal?' may fail to
     terminate if its arguments are circular data structures.

          (equal? 'a 'a)                             =>  #t
          (equal? '(a) '(a))                         =>  #t
          (equal? '(a (b) c)
                  '(a (b) c))                        =>  #t
          (equal? "abc" "abc")                       =>  #t
          (equal? 2 2)                               =>  #t
          (equal? (make-vector 5 'a)
                  (make-vector 5 'a))                =>  #t
          (equal? (make-array (A:fixN32b 4) 5 3)
                  (make-array (A:fixN32b 4) 5 3))    =>  #t
          (equal? (make-array '#(foo) 3 3)
                  (make-array '#(foo) 3 3))          =>  #t
          (equal? (lambda (x) x)
                  (lambda (y) y))                    =>  _unspecified_

 -- Function: array-rank obj
     Returns the number of dimensions of OBJ.  If OBJ is not an array,
     0 is returned.

 -- Function: array-dimensions array
     Returns a list of dimensions.

          (array-dimensions (make-array '#() 3 5))
             => (3 5)

 -- Function: make-array prototype k1 ...
     Creates and returns an array of type PROTOTYPE with dimensions K1,
     ...  and filled with elements from PROTOTYPE.  PROTOTYPE must be
     an array, vector, or string.  The implementation-dependent type of
     the returned array will be the same as the type of PROTOTYPE;
     except if that would be a vector or string with rank not equal to
     one, in which case some variety of array will be returned.

     If the PROTOTYPE has no elements, then the initial contents of the
     returned array are unspecified.  Otherwise, the returned array
     will be filled with the element at the origin of PROTOTYPE.

 -- Function: create-array prototype k1 ...
     `create-array' is an alias for `make-array'.

 -- Function: make-shared-array array mapper k1 ...
     `make-shared-array' can be used to create shared subarrays of other
     arrays.  The MAPPER is a function that translates coordinates in
     the new array into coordinates in the old array.  A MAPPER must be
     linear, and its range must stay within the bounds of the old
     array, but it can be otherwise arbitrary.  A simple example:

          (define fred (make-array '#(#f) 8 8))
          (define freds-diagonal
            (make-shared-array fred (lambda (i) (list i i)) 8))
          (array-set! freds-diagonal 'foo 3)
          (array-ref fred 3 3)
             => FOO
          (define freds-center
            (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j)))
                               2 2))
          (array-ref freds-center 0 0)
             => FOO

 -- Function: list->array rank proto list
     LIST must be a rank-nested list consisting of all the elements, in
     row-major order, of the array to be created.

     `list->array' returns an array of rank RANK and type PROTO
     consisting of all the elements, in row-major order, of LIST.  When
     RANK is 0, LIST is the lone array element; not necessarily a list.

          (list->array 2 '#() '((1 2) (3 4)))
                          => #2A((1 2) (3 4))
          (list->array 0 '#() 3)
                          => #0A 3

 -- Function: array->list array
     Returns a rank-nested list consisting of all the elements, in
     row-major order, of ARRAY.  In the case of a rank-0 array,
     `array->list' returns the single element.

          (array->list #2A((ho ho ho) (ho oh oh)))
                          => ((ho ho ho) (ho oh oh))
          (array->list #0A ho)
                          => ho

 -- Function: vector->array vect proto dim1 ...
     VECT must be a vector of length equal to the product of exact
     nonnegative integers DIM1, ....

     `vector->array' returns an array of type PROTO consisting of all
     the elements, in row-major order, of VECT.  In the case of a
     rank-0 array, VECT has a single element.

          (vector->array #(1 2 3 4) #() 2 2)
                          => #2A((1 2) (3 4))
          (vector->array '#(3) '#())
                          => #0A 3

 -- Function: array->vector array
     Returns a new vector consisting of all the elements of ARRAY in
     row-major order.

          (array->vector #2A ((1 2)( 3 4)))
                          => #(1 2 3 4)
          (array->vector #0A ho)
                          => #(ho)

 -- Function: array-in-bounds? array index1 ...
     Returns `#t' if its arguments would be acceptable to `array-ref'.

 -- Function: array-ref array k1 ...
     Returns the (K1, ...) element of ARRAY.

 -- Procedure: array-set! array obj k1 ...
     Stores OBJ in the (K1, ...) element of ARRAY.  The value returned
     by `array-set!' is unspecified.

These functions return a prototypical uniform-array enclosing the
optional argument (which must be of the correct type).  If the
uniform-array type is supported by the implementation, then it is
returned; defaulting to the next larger precision type; resorting
finally to vector.

 -- Function: A:floC128b z
 -- Function: A:floC128b
     Returns an inexact 128.bit flonum complex uniform-array prototype.

 -- Function: A:floC64b z
 -- Function: A:floC64b
     Returns an inexact 64.bit flonum complex uniform-array prototype.

 -- Function: A:floC32b z
 -- Function: A:floC32b
     Returns an inexact 32.bit flonum complex uniform-array prototype.

 -- Function: A:floC16b z
 -- Function: A:floC16b
     Returns an inexact 16.bit flonum complex uniform-array prototype.

 -- Function: A:floR128b x
 -- Function: A:floR128b
     Returns an inexact 128.bit flonum real uniform-array prototype.

 -- Function: A:floR64b x
 -- Function: A:floR64b
     Returns an inexact 64.bit flonum real uniform-array prototype.

 -- Function: A:floR32b x
 -- Function: A:floR32b
     Returns an inexact 32.bit flonum real uniform-array prototype.

 -- Function: A:floR16b x
 -- Function: A:floR16b
     Returns an inexact 16.bit flonum real uniform-array prototype.

 -- Function: A:floR128d q
 -- Function: A:floR128d
     Returns an exact 128.bit decimal flonum rational uniform-array
     prototype.

 -- Function: A:floR64d q
 -- Function: A:floR64d
     Returns an exact 64.bit decimal flonum rational uniform-array
     prototype.

 -- Function: A:floR32d q
 -- Function: A:floR32d
     Returns an exact 32.bit decimal flonum rational uniform-array
     prototype.

 -- Function: A:fixZ64b n
 -- Function: A:fixZ64b
     Returns an exact binary fixnum uniform-array prototype with at
     least 64 bits of precision.

 -- Function: A:fixZ32b n
 -- Function: A:fixZ32b
     Returns an exact binary fixnum uniform-array prototype with at
     least 32 bits of precision.

 -- Function: A:fixZ16b n
 -- Function: A:fixZ16b
     Returns an exact binary fixnum uniform-array prototype with at
     least 16 bits of precision.

 -- Function: A:fixZ8b n
 -- Function: A:fixZ8b
     Returns an exact binary fixnum uniform-array prototype with at
     least 8 bits of precision.

 -- Function: A:fixN64b k
 -- Function: A:fixN64b
     Returns an exact non-negative binary fixnum uniform-array
     prototype with at least 64 bits of precision.

 -- Function: A:fixN32b k
 -- Function: A:fixN32b
     Returns an exact non-negative binary fixnum uniform-array
     prototype with at least 32 bits of precision.

 -- Function: A:fixN16b k
 -- Function: A:fixN16b
     Returns an exact non-negative binary fixnum uniform-array
     prototype with at least 16 bits of precision.

 -- Function: A:fixN8b k
 -- Function: A:fixN8b
     Returns an exact non-negative binary fixnum uniform-array
     prototype with at least 8 bits of precision.

 -- Function: A:bool bool
 -- Function: A:bool
     Returns a boolean uniform-array prototype.


File: slib-3b5.info,  Node: Subarrays,  Next: Array Mapping,  Prev: Arrays,  Up: Data Structures
                                                                              |
7.1.2 Subarrays
---------------

`(require 'subarray)' 

 -- Function: subarray array select ...
     selects a subset of an array.  For 0 <= j < n, SELECTj is either         |
     an integer, a list of two integers within the range for the jth
     index, or #f.

     When SELECTj is a list of two integers, then the jth index is            |
     restricted to that subrange in the returned array.

     When SELECTj is #f, then the full range of the jth index is              |
     accessible in the returned array.  An elided argument is
     equivalent to #f.

     When SELECTj is an integer, then the rank of the returned array is       |
     less than ARRAY, and only elements whose jth index equals SELECTj        |
     are shared.

          > (define ra '#2A((a b c) (d e f)))
          #<unspecified>
          > (subarray ra 0 #f)
          #1A(a b c)
          > (subarray ra 1 #f)
          #1A(d e f)
          > (subarray ra #f 1)
          #1A(b e)
          > (subarray ra '(0 1) #f)
          #2A((a b c) (d e f))
          > (subarray ra #f '(0 1))
          #2A((a b) (d e))
          > (subarray ra #f '(1 2))
          #2A((b c) (e f))
          > (subarray ra #f '(2 1))
          #2A((c b) (f e))

     Arrays can be reflected (reversed) using `subarray':

          > (subarray '#1A(a b c d e) '(4 0))
          #1A(e d c b a)

 -- Function: array-trim array trim ...
     Returns a subarray sharing contents with ARRAY except for slices
     removed from either side of each dimension.  Each of the TRIMS is
     an exact integer indicating how much to trim.  A positive S trims
     the data from the lower end and reduces the upper bound of the
     result; a negative S trims from the upper end and increases the
     lower bound.

     For example:
          (array-trim '#(0 1 2 3 4) 1)  => #1A(1 2 3 4)
          (array-trim '#(0 1 2 3 4) -1) => #1A(0 1 2 3)

          (require 'array-for-each)
          (define (centered-difference ra)
            (array-map ra - (array-trim ra 1) (array-trim ra -1)))

          (centered-difference '#(0 1 3 5 9 22))
            => #(1 2 2 4 13)


File: slib-3b5.info,  Node: Array Mapping,  Next: Array Interpolation,  Prev: Subarrays,  Up: Data Structures
                                                                              |
7.1.3 Array Mapping
-------------------

`(require 'array-for-each)' 

 -- Procedure: array-map! array0 proc array1 ...
     ARRAY1, ... must have the same number of dimensions as ARRAY0 and
     have a range for each index which includes the range for the
     corresponding index in ARRAY0.  PROC is applied to each tuple of
     elements of ARRAY1 ... and the result is stored as the
     corresponding element in ARRAY0.  The value returned is
     unspecified.  The order of application is unspecified.

 -- Function: array-map prototype proc array1 array2 ...
     ARRAY2, ... must have the same number of dimensions as ARRAY1 and
     have a range for each index which includes the range for the
     corresponding index in ARRAY1.  PROC is applied to each tuple of
     elements of ARRAY1, ARRAY2, ... and the result is stored as the
     corresponding element in a new array of type PROTOTYPE.  The new
     array is returned.  The order of application is unspecified.

 -- Function: array-for-each proc array0 ...
     PROC is applied to each tuple of elements of ARRAY0 ...  in
     row-major order.  The value returned is unspecified.

 -- Function: array-indexes array
     Returns an array of lists of indexes for ARRAY such that, if LI is
     a list of indexes for which ARRAY is defined, (equal?  LI (apply
     array-ref (array-indexes ARRAY) LI)).

 -- Function: array-index-for-each array proc
     applies PROC to the indices of each element of ARRAY in turn.  The
     value returned and the order of application are unspecified.

     One can implement ARRAY-INDEX-MAP! as
          (define (array-index-map! ra fun)
            (array-index-for-each
             ra
             (lambda is (apply array-set! ra (apply fun is) is))))

 -- Procedure: array-index-map! array proc
     applies PROC to the indices of each element of ARRAY in turn,
     storing the result in the corresponding element.  The value
     returned and the order of application are unspecified.

     One can implement ARRAY-INDEXES as
          (define (array-indexes array)
              (let ((ra (apply make-array '#() (array-dimensions array))))
                (array-index-map! ra (lambda x x))
                ra))
     Another example:
          (define (apl:index-generator n)
              (let ((v (make-vector n 1)))
                (array-index-map! v (lambda (i) i))
                v))

 -- Procedure: array:copy! destination source
     Copies every element from vector or array SOURCE to the
     corresponding element of DESTINATION.  DESTINATION must have the
     same rank as SOURCE, and be at least as large in each dimension.
     The order of copying is unspecified.


File: slib-3b5.info,  Node: Array Interpolation,  Next: Association Lists,  Prev: Array Mapping,  Up: Data Structures
                                                                              |
7.1.4 Array Interpolation
-------------------------

`(require 'array-interpolate)'

 -- Function: interpolate-array-ref ra x1 ... xj
     RA must be an array of rank j containing numbers.
     `interpolate-array-ref' returns a value interpolated from the
     nearest j-dimensional cube of elements of RA.

          (interpolate-array-ref '#2A:fixZ32b((1 2 3) (4 5 6)) 1 0.1)
                                        ==> 4.1
          (interpolate-array-ref '#2A:fixZ32b((1 2 3) (4 5 6)) 0.5 0.25)
                                        ==> 2.75

 -- Procedure: resample-array! ra1 ra2
     RA1 and RA2 must be numeric arrays of equal rank.
     `resample-array!' sets RA1 to values interpolated from RA2 such
     that the values of elements at the corners of RA1 and RA2 are
     equal.

          (define ra (make-array (A:fixZ32b) 2 2))
          (resample-array! ra '#2A:fixZ32b((1 2 3) (4 5 6)))
          ra              ==>  #2A:fixZ32b((1 3) (4 6))
          (define ra (make-array (A:floR64b) 3 2))
          (resample-array! ra '#2A:fixZ32b((1 2 3) (4 5 6)))
          ra              ==>  #2A:floR64b((1.0 3.0) (2.5 4.5) (4.0 6.0))


File: slib-3b5.info,  Node: Association Lists,  Next: Byte,  Prev: Array Interpolation,  Up: Data Structures
                                                                              |
7.1.5 Association Lists
-----------------------

`(require 'alist)' 

  Alist functions provide utilities for treating a list of key-value
pairs as an associative database.  These functions take an equality
predicate, PRED, as an argument.  This predicate should be repeatable,
symmetric, and transitive.

  Alist functions can be used with a secondary index method such as hash
tables for improved performance.

 -- Function: predicate->asso pred
     Returns an "association function" (like `assq', `assv', or `assoc')
     corresponding to PRED.  The returned function returns a key-value
     pair whose key is `pred'-equal to its first argument or `#f' if no
     key in the alist is PRED-equal to the first argument.

 -- Function: alist-inquirer pred
     Returns a procedure of 2 arguments, ALIST and KEY, which returns
     the value associated with KEY in ALIST or `#f' if KEY does not
     appear in ALIST.

 -- Function: alist-associator pred
     Returns a procedure of 3 arguments, ALIST, KEY, and VALUE, which
     returns an alist with KEY and VALUE associated.  Any previous
     value associated with KEY will be lost.  This returned procedure
     may or may not have side effects on its ALIST argument.  An
     example of correct usage is:

          (define put (alist-associator string-ci=?))
          (define alist '())
          (set! alist (put alist "Foo" 9))

 -- Function: alist-remover pred
     Returns a procedure of 2 arguments, ALIST and KEY, which returns
     an alist with an association whose KEY is key removed.  This
     returned procedure may or may not have side effects on its ALIST
     argument.  An example of correct usage is:

          (define rem (alist-remover string-ci=?))
          (set! alist (rem alist "foo"))

 -- Function: alist-map proc alist
     Returns a new association list formed by mapping PROC over the
     keys and values of ALIST.   PROC must be a function of 2 arguments
     which returns the new value part.

 -- Function: alist-for-each proc alist
     Applies PROC to each pair of keys and values of ALIST.  PROC must
     be a function of 2 arguments.  The returned value is unspecified.


File: slib-3b5.info,  Node: Byte,  Next: Byte/Number Conversions,  Prev: Association Lists,  Up: Data Structures
                                                                              |
7.1.6 Byte
----------

`(require 'byte)' 

Some algorithms are expressed in terms of arrays of small integers.
Using Scheme strings to implement these arrays is not portable vis-a-vis
the correspondence between integers and characters and non-ascii
character sets.  These functions abstract the notion of a "byte".  

 -- Function: byte-ref bytes k
     K must be a valid index of BYTES.  `byte-ref' returns byte K of
     BYTES using zero-origin indexing.

 -- Procedure: byte-set! bytes k byte
     K must be a valid index of BYTES, and BYTE must be a small
     nonnegative integer.  `byte-set!' stores BYTE in element K of
     BYTES and returns an unspecified value.

 -- Function: make-bytes k byte
 -- Function: make-bytes k
     `make-bytes' returns a newly allocated byte-array of length K.  If
     BYTE is given, then all elements of the byte-array are initialized
     to BYTE, otherwise the contents of the byte-array are unspecified.

 -- Function: bytes-length bytes
     `bytes-length' returns length of byte-array BYTES.

 -- Function: bytes byte ...
     Returns a newly allocated byte-array composed of the small
     nonnegative arguments.

 -- Function: list->bytes bytes
     `list->bytes' returns a newly allocated byte-array formed from the
     small nonnegative integers in the list BYTES.

 -- Function: bytes->list bytes
     `bytes->list' returns a newly allocated list of the bytes that
     make up the given byte-array.

`Bytes->list' and `list->bytes' are inverses so far as `equal?' is
concerned.  

 -- Function: bytes->string bytes
     Returns a new string formed from applying `integer->char' to each
     byte in `bytes->string'.  Note that this may signal an error for
     bytes having values between 128 and 255.

 -- Function: string->bytes string
     Returns a new byte-array formed from applying `char->integer' to
     each character in `string->bytes'.  Note that this may signal an
     error if an integer is larger than 255.

 -- Function: bytes-copy bytes
     Returns a newly allocated copy of the given BYTES.

 -- Function: subbytes bytes start end
     BYTES must be a bytes, and START and END must be exact integers
     satisfying

                 0 <= START <= END <= (bytes-length BYTES).

     `subbytes' returns a newly allocated bytes formed from the bytes of
     BYTES beginning with index START (inclusive) and ending with index
     END (exclusive).

 -- Procedure: bytes-reverse! bytes
     Reverses the order of byte-array BYTES.

 -- Function: bytes-reverse bytes
     Returns a newly allocated bytes-array consisting of the elements of
     BYTES in reverse order.

Input and output of bytes should be with ports opened in "binary" mode
(*note Input/Output::).  Calling `open-file' with 'rb or 'wb modes
argument will return a binary port if the Scheme implementation
supports it.

 -- Function: write-byte byte port
 -- Function: write-byte byte
     Writes the byte BYTE (not an external representation of the byte)
     to the given PORT and returns an unspecified value.  The PORT
     argument may be omitted, in which case it defaults to the value
     returned by `current-output-port'.  

 -- Function: read-byte port
 -- Function: read-byte
     Returns the next byte available from the input PORT, updating the
     PORT to point to the following byte.  If no more bytes are
     available, an end-of-file object is returned.  PORT may be
     omitted, in which case it defaults to the value returned by
     `current-input-port'.  

When reading and writing binary numbers with `read-bytes' and
`write-bytes', the sign of the length argument determines the
endianness (order) of bytes.  Positive treats them as big-endian, the
first byte input or output is highest order.  Negative treats them as
little-endian, the first byte input or output is the lowest order.

Once read in, SLIB treats byte sequences as big-endian.  The multi-byte
sequences produced and used by number conversion routines *note
Byte/Number Conversions:: are always big-endian.

 -- Function: read-bytes n port
 -- Function: read-bytes n
     `read-bytes' returns a newly allocated bytes-array filled with
     `(abs N)' bytes read from PORT.  If N is positive, then the first
     byte read is stored at index 0; otherwise the last byte read is
     stored at index 0.  Note that the length of the returned
     byte-array will be less than `(abs N)' if PORT reaches end-of-file.

     PORT may be omitted, in which case it defaults to the value
     returned by `current-input-port'.

 -- Function: write-bytes bytes n port
 -- Function: write-bytes bytes n
     `write-bytes' writes `(abs N)' bytes to output-port PORT.  If N is
     positive, then the first byte written is index 0 of BYTES;
     otherwise the last byte written is index 0 of BYTES.
     `write-bytes' returns an unspecified value.

     PORT may be omitted, in which case it defaults to the value
     returned by `current-output-port'.

`subbytes-read!' and `subbytes-write' provide lower-level procedures
for reading and writing blocks of bytes.  The relative size of START
and END determines the order of writing.

 -- Procedure: subbytes-read! bts start end port
 -- Procedure: subbytes-read! bts start end
     Fills BTS with up to `(abs (- START END))' bytes read from PORT.
     The first byte read is stored at index BTS.  `subbytes-read!'
     returns the number of bytes read.

     PORT may be omitted, in which case it defaults to the value
     returned by `current-input-port'.

 -- Function: subbytes-write bts start end port
 -- Function: subbytes-write bts start end
     `subbytes-write' writes `(abs (- START END))' bytes to output-port
     PORT.  The first byte written is index START of BTS.
     `subbytes-write' returns the number of bytes written.

     PORT may be omitted, in which case it defaults to the value
     returned by `current-output-port'.


File: slib-3b5.info,  Node: Byte/Number Conversions,  Next: MAT-File Format,  Prev: Byte,  Up: Data Structures
                                                                              |
7.1.7 Byte/Number Conversions
-----------------------------

`(require 'byte-number)' 

The multi-byte sequences produced and used by numeric conversion
routines are always big-endian.  Endianness can be changed during
reading and writing bytes using `read-bytes' and `write-bytes' *Note
read-bytes: Byte.

The sign of the length argument to bytes/integer conversion procedures
determines the signedness of the number.

 -- Function: bytes->integer bytes n
     Converts the first `(abs N)' bytes of big-endian BYTES array to an
     integer.  If N is negative then the integer coded by the bytes are
     treated as two's-complement (can be negative).

          (bytes->integer (bytes   0   0   0  15) -4)   =>          15
          (bytes->integer (bytes   0   0   0  15)  4)   =>          15
          (bytes->integer (bytes 255 255 255 255) -4)   =>          -1
          (bytes->integer (bytes 255 255 255 255)  4)   =>  4294967295
          (bytes->integer (bytes 128   0   0   0) -4)   => -2147483648
          (bytes->integer (bytes 128   0   0   0)  4)   =>  2147483648

 -- Function: integer->bytes n len
     Converts the integer N to a byte-array of `(abs N)' bytes.  If N
     and LEN are both negative, then the bytes in the returned array
     are coded two's-complement.

          (bytes->list (integer->bytes          15 -4))   => (0 0 0 15)
          (bytes->list (integer->bytes          15  4))   => (0 0 0 15)
          (bytes->list (integer->bytes          -1 -4))   => (255 255 255 255)
          (bytes->list (integer->bytes  4294967295  4))   => (255 255 255 255)
          (bytes->list (integer->bytes -2147483648 -4))   => (128 0 0 0)
          (bytes->list (integer->bytes  2147483648  4))   => (128 0 0 0)

 -- Function: bytes->ieee-float bytes
     BYTES must be a 4-element byte-array.  `bytes->ieee-float'
     calculates and returns the value of BYTES interpreted as a
     big-endian IEEE 4-byte (32-bit) number.

     (bytes->ieee-float (bytes    0    0 0 0))  =>  0.0
     (bytes->ieee-float (bytes #x80    0 0 0))  => -0.0
     (bytes->ieee-float (bytes #x40    0 0 0))  =>  2.0
     (bytes->ieee-float (bytes #x40 #xd0 0 0))  =>  6.5
     (bytes->ieee-float (bytes #xc0 #xd0 0 0))  => -6.5

     (bytes->ieee-float (bytes    0 #x80 0 0))  => 11.754943508222875e-39
     (bytes->ieee-float (bytes    0 #x40 0 0))  =>  5.877471754111437e-39
     (bytes->ieee-float (bytes    0    0 0 1))  =>  1.401298464324817e-45

     (bytes->ieee-float (bytes #xff #x80 0 0))  => -inf.0
     (bytes->ieee-float (bytes #x7f #x80 0 0))  => +inf.0
     (bytes->ieee-float (bytes #x7f #x80 0 1))  =>  0/0
     (bytes->ieee-float (bytes #x7f #xc0 0 0))  =>  0/0

 -- Function: bytes->ieee-double bytes
     BYTES must be a 8-element byte-array.  `bytes->ieee-double'
     calculates and returns the value of BYTES interpreted as a
     big-endian IEEE 8-byte (64-bit) number.

     (bytes->ieee-double (bytes    0    0 0 0 0 0 0 0))  =>  0.0
     (bytes->ieee-double (bytes #x80    0 0 0 0 0 0 0))  => -0.0
     (bytes->ieee-double (bytes #x40    0 0 0 0 0 0 0))  =>  2.0
     (bytes->ieee-double (bytes #x40 #x1A 0 0 0 0 0 0))  =>  6.5
     (bytes->ieee-double (bytes #xC0 #x1A 0 0 0 0 0 0))  => -6.5

     (bytes->ieee-double (bytes 0 8 0 0 0 0 0 0)) => 11.125369292536006e-309
     (bytes->ieee-double (bytes 0 4 0 0 0 0 0 0)) =>  5.562684646268003e-309
     (bytes->ieee-double (bytes 0 0 0 0 0 0 0 1)) =>  4.0e-324

     (bytes->ieee-double (list->bytes '(127 239 255 255 255 255 255 255))) 179.76931348623157e306
     (bytes->ieee-double (bytes #xFF #xF0 0 0 0 0 0 0))  => -inf.0
     (bytes->ieee-double (bytes #x7F #xF0 0 0 0 0 0 0))  => +inf.0
     (bytes->ieee-double (bytes #x7F #xF8 0 0 0 0 0 0))  =>  0/0

 -- Function: ieee-float->bytes x
     Returns a 4-element byte-array encoding the IEEE single-precision
     floating-point of X.

     (bytes->list (ieee-float->bytes  0.0))                    => (0     0 0 0)
     (bytes->list (ieee-float->bytes -0.0))                    => (128   0 0 0)
     (bytes->list (ieee-float->bytes  2.0))                    => (64    0 0 0)
     (bytes->list (ieee-float->bytes  6.5))                    => (64  208 0 0)
     (bytes->list (ieee-float->bytes -6.5))                    => (192 208 0 0)

     (bytes->list (ieee-float->bytes 11.754943508222875e-39))  => (  0 128 0 0)
     (bytes->list (ieee-float->bytes  5.877471754111438e-39))  => (  0  64 0 0)
     (bytes->list (ieee-float->bytes  1.401298464324817e-45))  => (  0   0 0 1)

     (bytes->list (ieee-float->bytes -inf.0))                  => (255 128 0 0)
     (bytes->list (ieee-float->bytes +inf.0))                  => (127 128 0 0)
     (bytes->list (ieee-float->bytes  0/0))                    => (127 192 0 0)

 -- Function: ieee-double->bytes x
     Returns a 8-element byte-array encoding the IEEE double-precision
     floating-point of X.

     (bytes->list (ieee-double->bytes  0.0)) => (0     0 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes -0.0)) => (128   0 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes  2.0)) => (64    0 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes  6.5)) => (64   26 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes -6.5)) => (192  26 0 0 0 0 0 0)

     (bytes->list (ieee-double->bytes 11.125369292536006e-309))
                                             => (  0   8 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes  5.562684646268003e-309))
                                             => (  0   4 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes  4.0e-324))
                                             => (  0   0 0 0 0 0 0 1)

     (bytes->list (ieee-double->bytes -inf.0)) => (255 240 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes +inf.0)) => (127 240 0 0 0 0 0 0)
     (bytes->list (ieee-double->bytes  0/0)) => (127 248 0 0 0 0 0 0)

Byte Collation Order
....................

The `string<?' ordering of big-endian byte-array representations of
fixed and IEEE floating-point numbers agrees with the numerical
ordering only when those numbers are non-negative.

Straighforward modification of these formats can extend the
byte-collating order to work for their entire ranges.  This agreement
enables the full range of numbers as keys in
"indexed-sequential-access-method" databases.  

 -- Procedure: integer-byte-collate! byte-vector
     Modifies sign bit of BYTE-VECTOR so that `string<?' ordering of
     two's-complement byte-vectors matches numerical order.
     `integer-byte-collate!' returns BYTE-VECTOR and is its own
     functional inverse.

 -- Function: integer-byte-collate byte-vector
     Returns copy of BYTE-VECTOR with sign bit modified so that
     `string<?' ordering of two's-complement byte-vectors matches
     numerical order.  `integer-byte-collate' is its own functional
     inverse.

 -- Procedure: ieee-byte-collate! byte-vector
     Modifies BYTE-VECTOR so that `string<?' ordering of IEEE
     floating-point byte-vectors matches numerical order.
     `ieee-byte-collate!' returns BYTE-VECTOR.

 -- Procedure: ieee-byte-decollate! byte-vector
     Given BYTE-VECTOR modified by `ieee-byte-collate!', reverses the
     BYTE-VECTOR modifications.

 -- Function: ieee-byte-collate byte-vector
     Returns copy of BYTE-VECTOR encoded so that `string<?' ordering of
     IEEE floating-point byte-vectors matches numerical order.

 -- Function: ieee-byte-decollate byte-vector
     Given BYTE-VECTOR returned by `ieee-byte-collate', reverses the
     BYTE-VECTOR modifications.


File: slib-3b5.info,  Node: MAT-File Format,  Next: Portable Image Files,  Prev: Byte/Number Conversions,  Up: Data Structures
                                                                              |
7.1.8 MAT-File Format
---------------------

`(require 'matfile)' 

`http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf'

This package reads MAT-File Format version 4 (MATLAB) binary data
files.  MAT-files written from big-endian or little-endian computers
having IEEE format numbers are currently supported.  Support for files
written from VAX or Cray machines could also be added.

The numeric and text matrix types handled; support for "sparse" matrices
awaits a sample file.

 -- Function: matfile:read filename
     FILENAME should be a string naming an existing file containing a
     MATLAB Version 4 MAT-File.  The `matfile:read' procedure reads
     matrices from the file and returns a list of the results; a list
     of the name string and array for each matrix.

 -- Function: matfile:load filename
     FILENAME should be a string naming an existing file containing a
     MATLAB Version 4 MAT-File.  The `matfile:load' procedure reads
     matrices from the file and defines the `string-ci->symbol' for
     each matrix to its corresponding array.  `matfile:load' returns a
     list of the symbols defined.


File: slib-3b5.info,  Node: Portable Image Files,  Next: Collections,  Prev: MAT-File Format,  Up: Data Structures
                                                                              |
7.1.9 Portable Image Files
--------------------------

`(require 'pnm)' 

 -- Function: pnm:type-dimensions path
     The string PATH must name a "portable bitmap graphics" file.  `pnm:type-dimensions'
     returns a list of 4 items:
       1. A symbol describing the type of the file named by PATH.

       2. The image width in pixels.

       3. The image height in pixels.

       4. The maximum value of pixels assume in the file.

     The current set of file-type symbols is:
    pbm
    pbm-raw
          Black-and-White image; pixel values are 0 or 1.

    pgm
    pgm-raw
          Gray (monochrome) image; pixel values are from 0 to MAXVAL
          specified in file header.

    ppm
    ppm-raw
          RGB (full color) image; red, green, and blue interleaved
          pixel values are from 0 to MAXVAL

 -- Function: pnm:image-file->array path array
     Reads the "portable bitmap graphics" file named by PATH into ARRAY.
     ARRAY must be the correct size and type for PATH.  ARRAY is
     returned.


 -- Function: pnm:image-file->array path
     `pnm:image-file->array' creates and returns an array with the
     "portable bitmap graphics" file named by PATH read into it.  

 -- Function: pnm:array-write type array maxval path comment ...
     Writes the contents of ARRAY to a TYPE image file named PATH.  The
     file will have pixel values between 0 and MAXVAL, which must be
     compatible with TYPE.  For `pbm' files, MAXVAL must be `1'.
     COMMENTs are included in the file header.


File: slib-3b5.info,  Node: Collections,  Next: Dynamic Data Type,  Prev: Portable Image Files,  Up: Data Structures
                                                                              |
7.1.10 Collections
------------------

`(require 'collect)' 

Routines for managing collections.  Collections are aggregate data
structures supporting iteration over their elements, similar to the
Dylan(TM) language, but with a different interface.  They have
"elements" indexed by corresponding "keys", although the keys may be
implicit (as with lists).

New types of collections may be defined as YASOS objects (*note
Yasos::).  They must support the following operations:

   * `(collection? SELF)' (always returns `#t');

   * `(size SELF)' returns the number of elements in the collection;

   * `(print SELF PORT)' is a specialized print operation for the
     collection which prints a suitable representation on the given
     PORT or returns it as a string if PORT is `#t';

   * `(gen-elts SELF)' returns a thunk which on successive invocations
     yields elements of SELF in order or gives an error if it is
     invoked more than `(size SELF)' times;

   * `(gen-keys SELF)' is like `gen-elts', but yields the collection's
     keys in order.

They might support specialized `for-each-key' and `for-each-elt'
operations.

 -- Function: collection? obj
     A predicate, true initially of lists, vectors and strings.  New
     sorts of collections must answer `#t' to `collection?'.

 -- Procedure: map-elts proc collection1 ...
 -- Procedure: do-elts proc collection1 ...
     PROC is a procedure taking as many arguments as there are
     COLLECTIONS (at least one).  The COLLECTIONS are iterated over in
     their natural order and PROC is applied to the elements yielded by
     each iteration in turn.  The order in which the arguments are
     supplied corresponds to te order in which the COLLECTIONS appear.
     `do-elts' is used when only side-effects of PROC are of interest
     and its return value is unspecified.  `map-elts' returns a
     collection (actually a vector) of the results of the applications
     of PROC.

     Example:
          (map-elts + (list 1 2 3) (vector 1 2 3))
             => #(2 4 6)

 -- Procedure: map-keys proc collection1 ...
 -- Procedure: do-keys proc collection1 ...
     These are analogous to `map-elts' and `do-elts', but each
     iteration is over the COLLECTIONS' _keys_ rather than their
     elements.

     Example:
          (map-keys + (list 1 2 3) (vector 1 2 3))
             => #(0 2 4)

 -- Procedure: for-each-key collection proc
 -- Procedure: for-each-elt collection proc
     These are like `do-keys' and `do-elts' but only for a single
     collection; they are potentially more efficient.

 -- Function: reduce proc seed collection1 ...
     A generalization of the list-based `reduce-init' (*note Lists as
     sequences::) to collections.

     Examples:
          (reduce + 0 (vector 1 2 3))
             => 6
          (reduce union '() '((a b c) (b c d) (d a)))
             => (c b d a).

     `Reduce' called with two arguments will work as does the procedure
     of the same name from *Note Common List Functions::.  

 -- Function: any? pred collection1 ...
     A generalization of the list-based `some' (*note Lists as
     sequences::) to collections.

     Example:
          (any? odd? (list 2 3 4 5))
             => #t

 -- Function: every? pred collection1 ...
     A generalization of the list-based `every' (*note Lists as
     sequences::) to collections.

     Example:
          (every? collection? '((1 2) #(1 2)))
             => #t

 -- Function: empty? collection
     Returns `#t' iff there are no elements in COLLECTION.

     `(empty? COLLECTION) == (zero? (size COLLECTION))'

 -- Function: size collection
     Returns the number of elements in COLLECTION.

 -- Function: Setter list-ref
     See *note Setters:: for a definition of "setter".  N.B.  `(setter
     list-ref)' doesn't work properly for element 0 of a list.

  Here is a sample collection: `simple-table' which is also a `table'.
     (define-predicate TABLE?)
     (define-operation (LOOKUP table key failure-object))
     (define-operation (ASSOCIATE! table key value)) ;; returns key
     (define-operation (REMOVE! table key))          ;; returns value

     (define (MAKE-SIMPLE-TABLE)
       (let ( (table (list)) )
         (object
          ;; table behaviors
          ((TABLE? self) #t)
          ((SIZE self) (size table))
          ((PRINT self port) (format port "#<SIMPLE-TABLE>"))
          ((LOOKUP self key failure-object)
           (cond
            ((assq key table) => cdr)
            (else failure-object)
            ))
          ((ASSOCIATE! self key value)
           (cond
            ((assq key table)
             => (lambda (bucket) (set-cdr! bucket value) key))
            (else
             (set! table (cons (cons key value) table))
             key)
            ))
          ((REMOVE! self key);; returns old value
           (cond
            ((null? table) (slib:error "TABLE:REMOVE! Key not found: " key))
            ((eq? key (caar table))
             (let ( (value (cdar table)) )
               (set! table (cdr table))
               value)
             )
            (else
             (let loop ( (last table) (this (cdr table)) )
               (cond
                ((null? this)
                 (slib:error "TABLE:REMOVE! Key not found: " key))
                ((eq? key (caar this))
                 (let ( (value (cdar this)) )
                   (set-cdr! last (cdr this))
                   value)
                 )
                (else
                 (loop (cdr last) (cdr this)))
                ) ) )
            ))
          ;; collection behaviors
          ((COLLECTION? self) #t)
          ((GEN-KEYS self) (collect:list-gen-elts (map car table)))
          ((GEN-ELTS self) (collect:list-gen-elts (map cdr table)))
          ((FOR-EACH-KEY self proc)
           (for-each (lambda (bucket) (proc (car bucket))) table)
           )
          ((FOR-EACH-ELT self proc)
           (for-each (lambda (bucket) (proc (cdr bucket))) table)
           ) ) ) )


File: slib-3b5.info,  Node: Dynamic Data Type,  Next: Hash Tables,  Prev: Collections,  Up: Data Structures
                                                                              |
7.1.11 Dynamic Data Type
------------------------

`(require 'dynamic)' 

 -- Function: make-dynamic obj
     Create and returns a new "dynamic" whose global value is OBJ.

 -- Function: dynamic? obj
     Returns true if and only if OBJ is a dynamic.  No object
     satisfying `dynamic?' satisfies any of the other standard type
     predicates.

 -- Function: dynamic-ref dyn
     Return the value of the given dynamic in the current dynamic
     environment.

 -- Procedure: dynamic-set! dyn obj
     Change the value of the given dynamic to OBJ in the current
     dynamic environment.  The returned value is unspecified.

 -- Function: call-with-dynamic-binding dyn obj thunk
     Invoke and return the value of the given thunk in a new, nested
     dynamic environment in which the given dynamic has been bound to a
     new location whose initial contents are the value OBJ.  This
     dynamic environment has precisely the same extent as the
     invocation of the thunk and is thus captured by continuations
     created within that invocation and re-established by those
     continuations when they are invoked.

  The `dynamic-bind' macro is not implemented.


File: slib-3b5.info,  Node: Hash Tables,  Next: Object,  Prev: Dynamic Data Type,  Up: Data Structures
                                                                              |
7.1.12 Hash Tables
------------------

`(require 'hash-table)' 

 -- Function: predicate->hash pred
     Returns a hash function (like `hashq', `hashv', or `hash')
     corresponding to the equality predicate PRED.  PRED should be
     `eq?', `eqv?', `equal?', `=', `char=?', `char-ci=?', `string=?', or
     `string-ci=?'.

A hash table is a vector of association lists.

 -- Function: make-hash-table k
     Returns a vector of K empty (association) lists.

Hash table functions provide utilities for an associative database.
These functions take an equality predicate, PRED, as an argument.  PRED
should be `eq?', `eqv?', `equal?', `=', `char=?', `char-ci=?',
`string=?', or `string-ci=?'.

 -- Function: predicate->hash-asso pred
     Returns a hash association function of 2 arguments, KEY and
     HASHTAB, corresponding to PRED.  The returned function returns a
     key-value pair whose key is PRED-equal to its first argument or
     `#f' if no key in HASHTAB is PRED-equal to the first argument.

 -- Function: hash-inquirer pred
     Returns a procedure of 2 arguments, HASHTAB and KEY, which returns
     the value associated with KEY in HASHTAB or `#f' if KEY does not
     appear in HASHTAB.

 -- Function: hash-associator pred
     Returns a procedure of 3 arguments, HASHTAB, KEY, and VALUE, which
     modifies HASHTAB so that KEY and VALUE associated.  Any previous
     value associated with KEY will be lost.

 -- Function: hash-remover pred
     Returns a procedure of 2 arguments, HASHTAB and KEY, which
     modifies HASHTAB so that the association whose key is KEY is
     removed.

 -- Function: hash-map proc hash-table
     Returns a new hash table formed by mapping PROC over the keys and
     values of HASH-TABLE.  PROC must be a function of 2 arguments
     which returns the new value part.

 -- Function: hash-for-each proc hash-table
     Applies PROC to each pair of keys and values of HASH-TABLE.  PROC
     must be a function of 2 arguments.  The returned value is
     unspecified.

 -- Function: hash-rehasher pred
     `hash-rehasher' accepts a hash table predicate and returns a
     function of two arguments HASHTAB and NEW-K which is specialized
     for that predicate.

     This function is used for nondestrutively resizing a hash table.
     HASHTAB should be an existing hash-table using PRED, NEW-K is the
     size of a new hash table to be returned.  The new hash table will
     have all of the associations of the old hash table.


File: slib-3b5.info,  Node: Object,  Next: Priority Queues,  Prev: Hash Tables,  Up: Data Structures
                                                                              |
7.1.13 Macroless Object System
------------------------------

`(require 'object)' 

  This is the Macroless Object System written by Wade Humeniuk
(whumeniu@datap.ca).  Conceptual Tributes: *note Yasos::, MacScheme's
%object, CLOS, Lack of R4RS macros.

7.1.14 Concepts
---------------

OBJECT
     An object is an ordered association-list (by `eq?') of methods
     (procedures).  Methods can be added (`make-method!'), deleted
     (`unmake-method!') and retrieved (`get-method').  Objects may
     inherit methods from other objects.  The object binds to the
     environment it was created in, allowing closures to be used to
     hide private procedures and data.

GENERIC-METHOD
     A generic-method associates (in terms of `eq?') object's method.
     This allows scheme function style to be used for objects.  The
     calling scheme for using a generic method is `(generic-method
     object param1 param2 ...)'.

METHOD
     A method is a procedure that exists in the object.  To use a method
     get-method must be called to look-up the method.  Generic methods
     implement the get-method functionality.  Methods may be added to an
     object associated with any scheme obj in terms of eq?

GENERIC-PREDICATE
     A generic method that returns a boolean value for any scheme obj.

PREDICATE
     A object's method asscociated with a generic-predicate. Returns
     `#t'.

7.1.15 Procedures
-----------------

 -- Function: make-object ancestor ...
     Returns an object.  Current object implementation is a tagged
     vector.  ANCESTORs are optional and must be objects in terms of
     object?.  ANCESTORs methods are included in the object.  Multiple
     ANCESTORs might associate the same generic-method with a method.
     In this case the method of the ANCESTOR first appearing in the
     list is the one returned by `get-method'.

 -- Function: object? obj
     Returns boolean value whether OBJ was created by make-object.

 -- Function: make-generic-method exception-procedure
     Returns a procedure which be associated with an object's methods.
     If EXCEPTION-PROCEDURE is specified then it is used to process
     non-objects.

 -- Function: make-generic-predicate
     Returns a boolean procedure for any scheme object.

 -- Function: make-method! object generic-method method
     Associates METHOD to the GENERIC-METHOD in the object.  The METHOD
     overrides any previous association with the GENERIC-METHOD within
     the object.  Using `unmake-method!' will restore the object's
     previous association with the GENERIC-METHOD.  METHOD must be a
     procedure.

 -- Function: make-predicate! object generic-preciate
     Makes a predicate method associated with the GENERIC-PREDICATE.

 -- Function: unmake-method! object generic-method
     Removes an object's association with a GENERIC-METHOD .

 -- Function: get-method object generic-method
     Returns the object's method associated (if any) with the
     GENERIC-METHOD.  If no associated method exists an error is
     flagged.

7.1.16 Examples
---------------

     (require 'object)
     
     (define instantiate (make-generic-method))

     (define (make-instance-object . ancestors)
       (define self (apply make-object
                           (map (lambda (obj) (instantiate obj)) ancestors)))
       (make-method! self instantiate (lambda (self) self))
       self)

     (define who (make-generic-method))
     (define imigrate! (make-generic-method))
     (define emigrate! (make-generic-method))
     (define describe (make-generic-method))
     (define name (make-generic-method))
     (define address (make-generic-method))
     (define members (make-generic-method))

     (define society
       (let ()
         (define self (make-instance-object))
         (define population '())
         (make-method! self imigrate!
                       (lambda (new-person)
                         (if (not (eq? new-person self))
                             (set! population (cons new-person population)))))
         (make-method! self emigrate!
                       (lambda (person)
                         (if (not (eq? person self))
                             (set! population
                                   (comlist:remove-if (lambda (member)
                                                        (eq? member person))
                                                      population)))))
         (make-method! self describe
                       (lambda (self)
                         (map (lambda (person) (describe person)) population)))
         (make-method! self who
                       (lambda (self) (map (lambda (person) (name person))
                                           population)))
         (make-method! self members (lambda (self) population))
         self))

     (define (make-person %name %address)
       (define self (make-instance-object society))
       (make-method! self name (lambda (self) %name))
       (make-method! self address (lambda (self) %address))
       (make-method! self who (lambda (self) (name self)))
       (make-method! self instantiate
                     (lambda (self)
                       (make-person (string-append (name self) "-son-of")
                                    %address)))
       (make-method! self describe
                     (lambda (self) (list (name self) (address self))))
       (imigrate! self)
       self)

7.1.16.1 Inverter Documentation
...............................

Inheritance:
             <inverter>::(<number> <description>)
  Generic-methods
             <inverter>::value      => <number>::value
             <inverter>::set-value! => <number>::set-value!
             <inverter>::describe   => <description>::describe
             <inverter>::help
             <inverter>::invert
             <inverter>::inverter?

7.1.16.2 Number Documention
...........................

Inheritance
             <number>::()
  Slots
             <number>::<x>
  Generic Methods
             <number>::value
             <number>::set-value!

7.1.16.3 Inverter code
......................

     (require 'object)
     
     (define value (make-generic-method (lambda (val) val)))
     (define set-value! (make-generic-method))
     (define invert (make-generic-method
                     (lambda (val)
                       (if (number? val)
                           (/ 1 val)
                           (error "Method not supported:" val)))))
     (define noop (make-generic-method))
     (define inverter? (make-generic-predicate))
     (define describe (make-generic-method))
     (define help (make-generic-method))

     (define (make-number x)
       (define self (make-object))
       (make-method! self value (lambda (this) x))
       (make-method! self set-value!
                     (lambda (this new-value) (set! x new-value)))
       self)

     (define (make-description str)
       (define self (make-object))
       (make-method! self describe (lambda (this) str))
       (make-method! self help (lambda (this) "Help not available"))
       self)

     (define (make-inverter)
       (let* ((self (make-object
                     (make-number 1)
                     (make-description "A number which can be inverted")))
              (<value> (get-method self value)))
         (make-method! self invert (lambda (self) (/ 1 (<value> self))))
         (make-predicate! self inverter?)
         (unmake-method! self help)
         (make-method! self help
                       (lambda (self)
                         (display "Inverter Methods:") (newline)
                         (display "  (value inverter) ==> n") (newline)))
         self))

     ;;;; Try it out

     (define invert! (make-generic-method))

     (define x (make-inverter))

     (make-method! x invert! (lambda (x) (set-value! x (/ 1 (value x)))))

     (value x)                       => 1
     (set-value! x 33)               => undefined
     (invert! x)                     => undefined
     (value x)                       => 1/33

     (unmake-method! x invert!)      => undefined

     (invert! x)                     error-->  ERROR: Method not supported: x


File: slib-3b5.info,  Node: Priority Queues,  Next: Queues,  Prev: Object,  Up: Data Structures
                                                                              |
7.1.17 Priority Queues
----------------------

`(require 'priority-queue)' 

This algorithm for priority queues is due to `Introduction to
Algorithms' by T. Cormen, C. Leiserson, R. Rivest.  1989 MIT Press.

 -- Function: make-heap pred<?
     Returns a binary heap suitable which can be used for priority queue
     operations.

 -- Function: heap-length heap
     Returns the number of elements in HEAP.

 -- Procedure: heap-insert! heap item
     Inserts ITEM into HEAP.  ITEM can be inserted multiple times.  The
     value returned is unspecified.

 -- Procedure: heap-extract-max! heap
     Returns the item which is larger than all others according to the
     PRED<? argument to `make-heap'.  If there are no items in HEAP, an
     error is signaled.


File: slib-3b5.info,  Node: Queues,  Next: Records,  Prev: Priority Queues,  Up: Data Structures
                                                                              |
7.1.18 Queues
-------------

`(require 'queue)' 

  A "queue" is a list where elements can be added to both the front and
rear, and removed from the front (i.e., they are what are often called
"dequeues").  A queue may also be used like a stack.  

 -- Function: make-queue
     Returns a new, empty queue.

 -- Function: queue? obj
     Returns `#t' if OBJ is a queue.

 -- Function: queue-empty? q
     Returns `#t' if the queue Q is empty.

 -- Procedure: queue-push! q datum
     Adds DATUM to the front of queue Q.

 -- Procedure: enqueue! q datum
     Adds DATUM to the rear of queue Q.

 -- Procedure: dequeue! q
 -- Procedure: queue-pop! q
     Both of these procedures remove and return the datum at the front
     of the queue.  `queue-pop!' is used to suggest that the queue is
     being used like a stack.

  All of the following functions raise an error if the queue Q is empty.

 -- Procedure: dequeue-all! q
     Removes and returns (the list) of all contents of queue Q.

 -- Function: queue-front q
     Returns the datum at the front of the queue Q.

 -- Function: queue-rear q
     Returns the datum at the rear of the queue Q.


File: slib-3b5.info,  Node: Records,  Prev: Queues,  Up: Data Structures
                                                                              |
7.1.19 Records
--------------

`(require 'record)' 

  The Record package provides a facility for user to define their own
record data types.

 -- Function: make-record-type type-name field-names
     Returns a "record-type descriptor", a value representing a new data
     type disjoint from all others.  The TYPE-NAME argument must be a
     string, but is only used for debugging purposes (such as the
     printed representation of a record of the new type).  The
     FIELD-NAMES argument is a list of symbols naming the "fields" of a
     record of the new type.  It is an error if the list contains any
     duplicates.  It is unspecified how record-type descriptors are
     represented.

 -- Function: record-constructor rtd [field-names]
     Returns a procedure for constructing new members of the type
     represented by RTD.  The returned procedure accepts exactly as
     many arguments as there are symbols in the given list,
     FIELD-NAMES; these are used, in order, as the initial values of
     those fields in a new record, which is returned by the constructor
     procedure.  The values of any fields not named in that list are
     unspecified.  The FIELD-NAMES argument defaults to the list of
     field names in the call to `make-record-type' that created the
     type represented by RTD; if the FIELD-NAMES argument is provided,
     it is an error if it contains any duplicates or any symbols not in
     the default list.

 -- Function: record-predicate rtd
     Returns a procedure for testing membership in the type represented
     by RTD.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 -- Function: record-accessor rtd field-name
     Returns a procedure for reading the value of a particular field of
     a member of the type represented by RTD.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol FIELD-NAME in that record.  The symbol FIELD-NAME
     must be a member of the list of field-names in the call to
     `make-record-type' that created the type represented by RTD.

 -- Function: record-modifier rtd field-name
     Returns a procedure for writing the value of a particular field of
     a member of the type represented by RTD.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol FIELD-NAME in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol FIELD-NAME must be a member of the list
     of field-names in the call to `make-record-type' that created the
     type represented by RTD.

  In May of 1996, as a product of discussion on the `rrrs-authors'
mailing list, I rewrote `record.scm' to portably implement type
disjointness for record data types.

  As long as an implementation's procedures are opaque and the `record'
code is loaded before other programs, this will give disjoint record
types which are unforgeable and incorruptible by R4RS procedures.

  As a consequence, the procedures `record?', `record-type-descriptor',
`record-type-name'.and `record-type-field-names' are no longer
supported.


File: slib-3b5.info,  Node: Sorting and Searching,  Next: Procedures,  Prev: Data Structures,  Up: Other Packages
                                                                              |
7.2 Sorting and Searching
=========================

* Menu:

* Common List Functions::       'common-list-functions
* Tree Operations::             'tree
* Chapter Ordering::            'chapter-order
* Sorting::                     'sort
* Topological Sort::            Keep your socks on.
* Hashing::                     'hash
* Space-Filling Curves::        'space-filling and 'sierpinski
* Soundex::                     Dimension Reduction of Last Names
* String Search::               Also Search from a Port.
* Sequence Comparison::         'diff and longest-common-subsequence


File: slib-3b5.info,  Node: Common List Functions,  Next: Tree Operations,  Prev: Sorting and Searching,  Up: Sorting and Searching
                                                                              |
7.2.1 Common List Functions
---------------------------

`(require 'common-list-functions)' 

  The procedures below follow the Common LISP equivalents apart from
optional arguments in some cases.

* Menu:

* List construction::
* Lists as sets::
* Lists as sequences::
* Destructive list operations::
* Non-List functions::


File: slib-3b5.info,  Node: List construction,  Next: Lists as sets,  Prev: Common List Functions,  Up: Common List Functions
                                                                              |
7.2.1.1 List construction
.........................

 -- Function: make-list k
 -- Function: make-list k init
     `make-list' creates and returns a list of K elements.  If INIT is
     included, all elements in the list are initialized to INIT.

     Example:
          (make-list 3)
             => (#<unspecified> #<unspecified> #<unspecified>)
          (make-list 5 'foo)
             => (foo foo foo foo foo)

 -- Function: list* obj1 obj2 ...
     Works like `list' except that the cdr of the last pair is the last
     argument unless there is only one argument, when the result is
     just that argument.  Sometimes called `cons*'.  E.g.:

          (list* 1)
             => 1
          (list* 1 2 3)
             => (1 2 . 3)
          (list* 1 2 '(3 4))
             => (1 2 3 4)
          (list* ARGS '())
             == (list ARGS)

 -- Function: copy-list lst
     `copy-list' makes a copy of LST using new pairs and returns it.
     Only the top level of the list is copied, i.e., pairs forming
     elements of the copied list remain `eq?' to the corresponding
     elements of the original; the copy is, however, not `eq?' to the
     original, but is `equal?' to it.

     Example:
          (copy-list '(foo foo foo))
             => (foo foo foo)
          (define q '(foo bar baz bang))
          (define p q)
          (eq? p q)
             => #t
          (define r (copy-list q))
          (eq? q r)
             => #f
          (equal? q r)
             => #t
          (define bar '(bar))
          (eq? bar (car (copy-list (list bar 'foo))))
          => #t


File: slib-3b5.info,  Node: Lists as sets,  Next: Lists as sequences,  Prev: List construction,  Up: Common List Functions
                                                                              |
7.2.1.2 Lists as sets
.....................

`eqv?' is used to test for membership by procedures which treat lists
as sets.

 -- Function: adjoin e l
     `adjoin' returns the adjoint of the element E and the list L.
     That is, if E is in L, `adjoin' returns L, otherwise, it returns
     `(cons E L)'.

     Example:
          (adjoin 'baz '(bar baz bang))
             => (bar baz bang)
          (adjoin 'foo '(bar baz bang))
             => (foo bar baz bang)

 -- Function: union l1 l2
     `union' returns a list of all elements that are in L1 or L2.
     Duplicates between L1 and L2 are culled.  Duplicates within L1 or
     within L2 may or may not be removed.

     Example:
          (union '(1 2 3 4) '(5 6 7 8))
             => (1 2 3 4 5 6 7 8)
          (union '(0 1 2 3 4) '(3 4 5 6))
             => (5 6 0 1 2 3 4)

 -- Function: intersection l1 l2
     `intersection' returns a list of all elements that are in both L1
     and L2.

     Example:
          (intersection '(1 2 3 4) '(3 4 5 6))
             => (3 4)
          (intersection '(1 2 3 4) '(5 6 7 8))
             => ()

 -- Function: set-difference l1 l2
     `set-difference' returns a list of all elements that are in L1 but
     not in L2.

     Example:
          (set-difference '(1 2 3 4) '(3 4 5 6))
             => (1 2)
          (set-difference '(1 2 3 4) '(1 2 3 4 5 6))
             => ()

 -- Function: subset? list1 list2
     Returns `#t' if every element of LIST1 is `eqv?' an element of
     LIST2; otherwise returns `#f'.

     Example:
          (subset? '(1 2 3 4) '(3 4 5 6))
             => #f
          (subset? '(1 2 3 4) '(6 5 4 3 2 1 0))
             => #t

 -- Function: member-if pred lst
     `member-if' returns the list headed by the first element of LST to
     satisfy `(PRED ELEMENT)'.  `Member-if' returns `#f' if PRED
     returns `#f' for every ELEMENT in LST.

     Example:
          (member-if vector? '(a 2 b 4))
             => #f
          (member-if number? '(a 2 b 4))
             => (2 b 4)

 -- Function: some pred lst1 lst2 ...
     PRED is a boolean function of as many arguments as there are list
     arguments to `some' i.e., LST plus any optional arguments.  PRED
     is applied to successive elements of the list arguments in order.
     `some' returns `#t' as soon as one of these applications returns
     `#t', and is `#f' if none returns `#t'.  All the lists should have
     the same length.

     Example:
          (some odd? '(1 2 3 4))
             => #t

          (some odd? '(2 4 6 8))
             => #f

          (some > '(1 3) '(2 4))
             => #f

 -- Function: every pred lst1 lst2 ...
     `every' is analogous to `some' except it returns `#t' if every
     application of PRED is `#t' and `#f' otherwise.

     Example:
          (every even? '(1 2 3 4))
             => #f

          (every even? '(2 4 6 8))
             => #t

          (every > '(2 3) '(1 4))
             => #f

 -- Function: notany pred lst1 ...
     `notany' is analogous to `some' but returns `#t' if no application
     of PRED returns `#t' or `#f' as soon as any one does.

 -- Function: notevery pred lst1 ...
     `notevery' is analogous to `some' but returns `#t' as soon as an
     application of PRED returns `#f', and `#f' otherwise.

     Example:
          (notevery even? '(1 2 3 4))
             => #t

          (notevery even? '(2 4 6 8))
             => #f

 -- Function: list-of?? predicate
     Returns a predicate which returns true if its argument is a list
     every element of which satisfies PREDICATE.

 -- Function: list-of?? predicate low-bound high-bound
     LOW-BOUND and HIGH-BOUND are non-negative integers.  `list-of??'
     returns a predicate which returns true if its argument is a list
     of length between LOW-BOUND and HIGH-BOUND (inclusive); every
     element of which satisfies PREDICATE.

 -- Function: list-of?? predicate bound
     BOUND is an integer.  If BOUND is negative, `list-of??' returns a
     predicate which returns true if its argument is a list of length
     greater than `(- BOUND)'; every element of which satisfies
     PREDICATE.  Otherwise, `list-of??'  returns a predicate which
     returns true if its argument is a list of length less than or
     equal to BOUND; every element of which satisfies PREDICATE.

 -- Function: find-if pred lst
     `find-if' searches for the first ELEMENT in LST such that `(PRED
     ELEMENT)' returns `#t'.  If it finds any such ELEMENT in LST,
     ELEMENT is returned.  Otherwise, `#f' is returned.

     Example:
          (find-if number? '(foo 1 bar 2))
             => 1

          (find-if number? '(foo bar baz bang))
             => #f

          (find-if symbol? '(1 2 foo bar))
             => foo

 -- Function: remove elt lst
     `remove' removes all occurrences of ELT from LST using `eqv?' to
     test for equality and returns everything that's left.  N.B.: other
     implementations (Chez, Scheme->C and T, at least) use `equal?' as
     the equality test.

     Example:
          (remove 1 '(1 2 1 3 1 4 1 5))
             => (2 3 4 5)

          (remove 'foo '(bar baz bang))
             => (bar baz bang)

 -- Function: remove-if pred lst
     `remove-if' removes all ELEMENTs from LST where `(PRED ELEMENT)'
     is `#t' and returns everything that's left.

     Example:
          (remove-if number? '(1 2 3 4))
             => ()

          (remove-if even? '(1 2 3 4 5 6 7 8))
             => (1 3 5 7)

 -- Function: remove-if-not pred lst
     `remove-if-not' removes all ELEMENTs from LST for which `(PRED
     ELEMENT)' is `#f' and returns everything that's left.

     Example:
          (remove-if-not number? '(foo bar baz))
             => ()
          (remove-if-not odd? '(1 2 3 4 5 6 7 8))
             => (1 3 5 7)

 -- Function: has-duplicates? lst
     returns `#t' if 2 members of LST are `equal?', `#f' otherwise.

     Example:
          (has-duplicates? '(1 2 3 4))
             => #f

          (has-duplicates? '(2 4 3 4))
             => #t

  The procedure `remove-duplicates' uses `member' (rather than `memv').

 -- Function: remove-duplicates lst
     returns a copy of LST with its duplicate members removed.
     Elements are considered duplicate if they are `equal?'.

     Example:
          (remove-duplicates '(1 2 3 4))
             => (1 2 3 4)

          (remove-duplicates '(2 4 3 4))
             => (2 4 3)


File: slib-3b5.info,  Node: Lists as sequences,  Next: Destructive list operations,  Prev: Lists as sets,  Up: Common List Functions
                                                                              |
7.2.1.3 Lists as sequences
..........................

 -- Function: position obj lst
     `position' returns the 0-based position of OBJ in LST, or `#f' if
     OBJ does not occur in LST.

     Example:
          (position 'foo '(foo bar baz bang))
             => 0
          (position 'baz '(foo bar baz bang))
             => 2
          (position 'oops '(foo bar baz bang))
             => #f

 -- Function: reduce p lst
     `reduce' combines all the elements of a sequence using a binary
     operation (the combination is left-associative).  For example,
     using `+', one can add up all the elements.  `reduce' allows you to
     apply a function which accepts only two arguments to more than 2
     objects.  Functional programmers usually refer to this as "foldl".
     `collect:reduce' (*note Collections::) provides a version of
     `collect' generalized to collections.

     Example:
          (reduce + '(1 2 3 4))
             => 10
          (define (bad-sum . l) (reduce + l))
          (bad-sum 1 2 3 4)
             == (reduce + (1 2 3 4))
             == (+ (+ (+ 1 2) 3) 4)
          => 10
          (bad-sum)
             == (reduce + ())
             => ()
          (reduce string-append '("hello" "cruel" "world"))
             == (string-append (string-append "hello" "cruel") "world")
             => "hellocruelworld"
          (reduce anything '())
             => ()
          (reduce anything '(x))
             => x

     What follows is a rather non-standard implementation of `reverse'
     in terms of `reduce' and a combinator elsewhere called "C".

          ;;; Contributed by Jussi Piitulainen (jpiitula @ ling.helsinki.fi)

          (define commute
            (lambda (f)
              (lambda (x y)
                (f y x))))

          (define reverse
            (lambda (args)
              (reduce-init (commute cons) '() args)))

 -- Function: reduce-init p init lst
     `reduce-init' is the same as reduce, except that it implicitly
     inserts INIT at the start of the list.  `reduce-init' is preferred
     if you want to handle the null list, the one-element, and lists
     with two or more elements consistently.  It is common to use the
     operator's idempotent as the initializer.  Functional programmers
     usually call this "foldl".

     Example:
          (define (sum . l) (reduce-init + 0 l))
          (sum 1 2 3 4)
             == (reduce-init + 0 (1 2 3 4))
             == (+ (+ (+ (+ 0 1) 2) 3) 4)
             => 10
          (sum)
             == (reduce-init + 0 '())
             => 0

          (reduce-init string-append "@" '("hello" "cruel" "world"))
          ==
          (string-append (string-append (string-append "@" "hello")
                                         "cruel")
                         "world")
          => "@hellocruelworld"

     Given a differentiation of 2 arguments, `diff', the following will
     differentiate by any number of variables.
          (define (diff* exp . vars)
            (reduce-init diff exp vars))

     Example:
          ;;; Real-world example:  Insertion sort using reduce-init.

          (define (insert l item)
            (if (null? l)
                (list item)
                (if (< (car l) item)
                    (cons (car l) (insert (cdr l) item))
                    (cons item l))))
          (define (insertion-sort l) (reduce-init insert '() l))

          (insertion-sort '(3 1 4 1 5)
             == (reduce-init insert () (3 1 4 1 5))
             == (insert (insert (insert (insert (insert () 3) 1) 4) 1) 5)
             == (insert (insert (insert (insert (3)) 1) 4) 1) 5)
             == (insert (insert (insert (1 3) 4) 1) 5)
             == (insert (insert (1 3 4) 1) 5)
             == (insert (1 1 3 4) 5)
             => (1 1 3 4 5)

 -- Function: last lst n
     `last' returns the last N elements of LST.  N must be a
     non-negative integer.

     Example:
          (last '(foo bar baz bang) 2)
             => (baz bang)
          (last '(1 2 3) 0)
             => ()                                                            |

 -- Function: butlast lst n
     `butlast' returns all but the last N elements of LST.

     Example:
          (butlast '(a b c d) 3)
             => (a)
          (butlast '(a b c d) 4)
             => ()

`last' and `butlast' split a list into two parts when given identical
arguments.
     (last '(a b c d e) 2)
        => (d e)
     (butlast '(a b c d e) 2)
        => (a b c)

 -- Function: nthcdr n lst
     `nthcdr' takes N `cdr's of LST and returns the result.  Thus
     `(nthcdr 3 LST)' == `(cdddr LST)'

     Example:
          (nthcdr 2 '(a b c d))
             => (c d)
          (nthcdr 0 '(a b c d))
             => (a b c d)

 -- Function: butnthcdr n lst
     `butnthcdr' returns all but the nthcdr N elements of LST.

     Example:
          (butnthcdr 3 '(a b c d))
             => (a b c)
          (butnthcdr 4 '(a b c d))
             => (a b c d)

`nthcdr' and `butnthcdr' split a list into two parts when given
identical arguments.
     (nthcdr 2 '(a b c d e))
        => (c d e)
     (butnthcdr 2 '(a b c d e))
        => (a b)


File: slib-3b5.info,  Node: Destructive list operations,  Next: Non-List functions,  Prev: Lists as sequences,  Up: Common List Functions
                                                                              |
7.2.1.4 Destructive list operations
...................................

These procedures may mutate the list they operate on, but any such
mutation is undefined.

 -- Procedure: nconc args
     `nconc' destructively concatenates its arguments.  (Compare this
     with `append', which copies arguments rather than destroying them.)
     Sometimes called `append!' (*note Rev2 Procedures::).

     Example:  You want to find the subsets of a set.  Here's the
     obvious way:

          (define (subsets set)
            (if (null? set)
                '(())
                (append (map (lambda (sub) (cons (car set) sub))
                             (subsets (cdr set)))
                        (subsets (cdr set)))))
     But that does way more consing than you need.  Instead, you could
     replace the `append' with `nconc', since you don't have any need
     for all the intermediate results.

     Example:
          (define x '(a b c))
          (define y '(d e f))
          (nconc x y)
             => (a b c d e f)
          x
             => (a b c d e f)

     `nconc' is the same as `append!' in `sc2.scm'.

 -- Procedure: nreverse lst
     `nreverse' reverses the order of elements in LST by mutating
     `cdr's of the list.  Sometimes called `reverse!'.

     Example:
          (define foo '(a b c))
          (nreverse foo)
             => (c b a)
          foo
             => (a)

     Some people have been confused about how to use `nreverse',
     thinking that it doesn't return a value.  It needs to be pointed
     out that

          (set! lst (nreverse lst))
     is the proper usage, not
          (nreverse lst)
     The example should suffice to show why this is the case.

 -- Procedure: delete elt lst
 -- Procedure: delete-if pred lst
 -- Procedure: delete-if-not pred lst
     Destructive versions of `remove' `remove-if', and `remove-if-not'.

     Example:
          (define lst (list 'foo 'bar 'baz 'bang))
          (delete 'foo lst)
             => (bar baz bang)
          lst
             => (foo bar baz bang)

          (define lst (list 1 2 3 4 5 6 7 8 9))
          (delete-if odd? lst)
             => (2 4 6 8)
          lst
             => (1 2 4 6 8)

     Some people have been confused about how to use `delete',
     `delete-if', and `delete-if', thinking that they don't return a
     value.  It needs to be pointed out that

          (set! lst (delete el lst))
     is the proper usage, not
          (delete el lst)
     The examples should suffice to show why this is the case.


File: slib-3b5.info,  Node: Non-List functions,  Prev: Destructive list operations,  Up: Common List Functions
                                                                              |
7.2.1.5 Non-List functions
..........................

 -- Function: and? arg1 ...
     `and?' checks to see if all its arguments are true.  If they are,
     `and?' returns `#t', otherwise, `#f'.  (In contrast to `and', this
     is a function, so all arguments are always evaluated and in an
     unspecified order.)

     Example:
          (and? 1 2 3)
             => #t
          (and #f 1 2)
             => #f

 -- Function: or? arg1 ...
     `or?' checks to see if any of its arguments are true.  If any is
     true, `or?' returns `#t', and `#f' otherwise.  (To `or' as `and?'
     is to `and'.)

     Example:
          (or? 1 2 #f)
             => #t
          (or? #f #f #f)
             => #f

 -- Function: atom? object
     Returns `#t' if OBJECT is not a pair and `#f' if it is pair.
     (Called `atom' in Common LISP.)
          (atom? 1)
             => #t
          (atom? '(1 2))
             => #f
          (atom? #(1 2))   ; dubious!
             => #t


File: slib-3b5.info,  Node: Tree Operations,  Next: Chapter Ordering,  Prev: Common List Functions,  Up: Sorting and Searching
                                                                              |
7.2.2 Tree operations
---------------------

`(require 'tree)' 

  These are operations that treat lists a representations of trees.

 -- Function: subst new old tree
 -- Function: substq new old tree
 -- Function: substv new old tree
 -- Function: subst new old tree equ?
     `subst' makes a copy of TREE, substituting NEW for every subtree
     or leaf of TREE which is `equal?' to OLD and returns a modified
     tree.  The original TREE is unchanged, but may share parts with
     the result.

     `substq' and `substv' are similar, but test against OLD using
     `eq?' and `eqv?' respectively.  If `subst' is called with a fourth
     argument, EQU? is the equality predicate.

     Examples:
          (substq 'tempest 'hurricane '(shakespeare wrote (the hurricane)))
             => (shakespeare wrote (the tempest))
          (substq 'foo '() '(shakespeare wrote (twelfth night)))
             => (shakespeare wrote (twelfth night . foo) . foo)
          (subst '(a . cons) '(old . pair)
                 '((old . spice) ((old . shoes) old . pair) (old . pair)))
             => ((old . spice) ((old . shoes) a . cons) (a . cons))

 -- Function: copy-tree tree
     Makes a copy of the nested list structure TREE using new pairs and
     returns it.  All levels are copied, so that none of the pairs in
     the tree are `eq?' to the original ones - only the leaves are.

     Example:
          (define bar '(bar))
          (copy-tree (list bar 'foo))
             => ((bar) foo)
          (eq? bar (car (copy-tree (list bar 'foo))))
             => #f


File: slib-3b5.info,  Node: Chapter Ordering,  Next: Sorting,  Prev: Tree Operations,  Up: Sorting and Searching
                                                                              |
7.2.3 Chapter Ordering
----------------------

`(require 'chapter-order)' 

  The `chap:' functions deal with strings which are ordered like
chapter numbers (or letters) in a book.  Each section of the string
consists of consecutive numeric or consecutive aphabetic characters of
like case.

 -- Function: chap:string<? string1 string2
     Returns #t if the first non-matching run of alphabetic upper-case
     or the first non-matching run of alphabetic lower-case or the first
     non-matching run of numeric characters of STRING1 is `string<?'
     than the corresponding non-matching run of characters of STRING2.

          (chap:string<? "a.9" "a.10")                    => #t
          (chap:string<? "4c" "4aa")                      => #t
          (chap:string<? "Revised^{3.99}" "Revised^{4}")  => #t

 -- Function: chap:string>? string1 string2
 -- Function: chap:string<=? string1 string2
 -- Function: chap:string>=? string1 string2
     Implement the corresponding chapter-order predicates.

 -- Function: chap:next-string string
     Returns the next string in the _chapter order_.  If STRING has no
     alphabetic or numeric characters, `(string-append STRING "0")' is
     returnd.  The argument to chap:next-string will always be
     `chap:string<?' than the result.

          (chap:next-string "a.9")                => "a.10"
          (chap:next-string "4c")                 => "4d"
          (chap:next-string "4z")                 => "4aa"
          (chap:next-string "Revised^{4}")        => "Revised^{5}"


File: slib-3b5.info,  Node: Sorting,  Next: Topological Sort,  Prev: Chapter Ordering,  Up: Sorting and Searching
                                                                              |
7.2.4 Sorting
-------------

`(require 'sort)' or `(require 'srfi-95)' 

  [by Richard A. O'Keefe, 1991]

  I am providing this source code with no restrictions at all on its use
(but please retain D.H.D.Warren's credit for the original idea).

  The code of `merge' and `merge!' could have been quite a bit simpler,
but they have been coded to reduce the amount of work done per
iteration.  (For example, we only have one `null?' test per iteration.)

  I gave serious consideration to producing Common-LISP-compatible
functions.  However, Common LISP's `sort' is our `sort!' (well, in fact
Common LISP's `stable-sort' is our `sort!'; merge sort is _fast_ as
well as stable!) so adapting CL code to Scheme takes a bit of work
anyway.  I did, however, appeal to CL to determine the _order_ of the
arguments.

  The standard functions `<', `>', `char<?', `char>?', `char-ci<?',
`char-ci>?', `string<?', `string>?', `string-ci<?', and `string-ci>?'
are suitable for use as comparison functions.  Think of `(less? x y)'
as saying when `x' must _not_ precede `y'.

  [Addendum by Aubrey Jaffer, 2006]

  These procedures are stable when called with predicates which return
`#f' when applied to identical arguments.

  The `sorted?', `merge', and `merge!' procedures consume asymptotic
time and space no larger than O(N), where N is the sum of the lengths
of the sequence arguments.  The `sort' and `sort!' procedures consume
asymptotic time and space no larger than O(N*log(N)), where N is the
length of the sequence argument.

  All five functions take an optional KEY argument corresponding to a
CL-style `&key' argument.  A LESS?  predicate with a KEY argument
behaves like:

     (lambda (x y) (LESS? (KEY x) (KEY y)))

  All five functions will call the KEY argument at most once per
element.

  The `!' variants sort in place; `sort!' returns its SEQUENCE argument.

 -- Function: sorted? sequence less?
 -- Function: sorted? sequence less? key
     Returns `#t' when the sequence argument is in non-decreasing order
     according to LESS? (that is, there is no adjacent pair `... x y
     ...' for which `(less? y x)').

     Returns `#f' when the sequence contains at least one out-of-order
     pair.  It is an error if the sequence is not a list or array
     (including vectors and strings).

 -- Function: merge list1 list2 less?
 -- Function: merge list1 list2 less? key
     Merges two sorted lists, returning a freshly allocated list as its
     result.

 -- Function: merge! list1 list2 less?
 -- Function: merge! list1 list2 less? key
     Merges two sorted lists, re-using the pairs of LIST1 and LIST2 to
     build the result.  The result will be either LIST1 or LIST2.

 -- Function: sort sequence less?
 -- Function: sort sequence less? key
     Accepts a list or array (including vectors and strings) for
     SEQUENCE; and returns a completely new sequence which is sorted
     according to LESS?.  The returned sequence is the same type as the
     argument SEQUENCE.  Given valid arguments, it is always the case
     that:

          (sorted? (sort SEQUENCE LESS?) LESS?) => #t

 -- Function: sort! sequence less?
 -- Function: sort! sequence less? key
     Returns list, array, vector, or string SEQUENCE which has been
     mutated to order its elements according to LESS?.  Given valid
     arguments, it is always the case that:

          (sorted? (sort! SEQUENCE LESS?) LESS?) => #t


File: slib-3b5.info,  Node: Topological Sort,  Next: Hashing,  Prev: Sorting,  Up: Sorting and Searching
                                                                              |
7.2.5 Topological Sort
----------------------

`(require 'topological-sort)' or `(require 'tsort)' 

The algorithm is inspired by Cormen, Leiserson and Rivest (1990)
`Introduction to Algorithms', chapter 23.

 -- Function: tsort dag pred
 -- Function: topological-sort dag pred
     where
    DAG
          is a list of sublists.  The car of each sublist is a vertex.
          The cdr is the adjacency list of that vertex, i.e. a list of
          all vertices to which there exists an edge from the car
          vertex.

    PRED
          is one of `eq?', `eqv?', `equal?', `=', `char=?',
          `char-ci=?', `string=?', or `string-ci=?'.

     Sort the directed acyclic graph DAG so that for every edge from
     vertex U to V, U will come before V in the resulting list of
     vertices.

     Time complexity: O (|V| + |E|)

     Example (from Cormen):

          Prof. Bumstead topologically sorts his clothing when getting
          dressed.  The first argument to `tsort' describes which
          garments he needs to put on before others.  (For example,
          Prof Bumstead needs to put on his shirt before he puts on his
          tie or his belt.)  `tsort' gives the correct order of
          dressing:

          (require 'tsort)
          (tsort '((shirt tie belt)
                   (tie jacket)
                   (belt jacket)
                   (watch)
                   (pants shoes belt)
                   (undershorts pants shoes)
                   (socks shoes))
                 eq?)
          =>
          (socks undershorts pants shoes watch shirt belt tie jacket)


File: slib-3b5.info,  Node: Hashing,  Next: Space-Filling Curves,  Prev: Topological Sort,  Up: Sorting and Searching
                                                                              |
7.2.6 Hashing
-------------

`(require 'hash)' 

  These hashing functions are for use in quickly classifying objects.
Hash tables use these functions.

 -- Function: hashq obj k
 -- Function: hashv obj k
 -- Function: hash obj k
     Returns an exact non-negative integer less than K.  For each
     non-negative integer less than K there are arguments OBJ for which
     the hashing functions applied to OBJ and K returns that integer.

     For `hashq', `(eq? obj1 obj2)' implies `(= (hashq obj1 k) (hashq
     obj2))'.

     For `hashv', `(eqv? obj1 obj2)' implies `(= (hashv obj1 k) (hashv
     obj2))'.

     For `hash', `(equal? obj1 obj2)' implies `(= (hash obj1 k) (hash
     obj2))'.

     `hash', `hashv', and `hashq' return in time bounded by a constant.
     Notice that items having the same `hash' implies the items have
     the same `hashv' implies the items have the same `hashq'.


File: slib-3b5.info,  Node: Space-Filling Curves,  Next: Soundex,  Prev: Hashing,  Up: Sorting and Searching
                                                                              |
7.2.7 Space-Filling Curves
--------------------------

* Menu:

* Multidimensional Space-Filling Curves::  Includes Hilbert and Peano curves
* Hilbert Space-Filling Curve::            Legacy
* Peano Space-Filling Curve::              Legacy
* Sierpinski Curve::                       Rank-2 to scalar


File: slib-3b5.info,  Node: Multidimensional Space-Filling Curves,  Next: Hilbert Space-Filling Curve,  Prev: Space-Filling Curves,  Up: Space-Filling Curves
                                                                              |
7.2.7.1 Multidimensional Space-Filling Curves                                 |
.............................................                                 |
                                                                              |
`(require 'space-filling)'                                                    |
                                                                              |
  The algorithms and cell properties are described in                         |
`http://people.csail.mit.edu/jaffer/Geometry/RMDSFF.pdf'                      |
                                                                              |
 -- Function: make-cell type rank side precession                             |
 -- Function: make-cell type rank side                                        |
 -- Function: make-cell type rank                                             |
     TYPE must be the symbol `diagonal', `adjacent', or `centered'.           |
     RANK must be an integer larger than 1.  SIDE, if present, must be        |
     an even integer larger than 1 if TYPE is `adjacent' or an odd            |
     integer larger than 2 otherwise; SIDE defaults to the smallest           |
     value.  PRECESSION, if present, must be an integer between 0 and         |
     SIDE^RANK-1; it is relevant only when TYPE is `diagonal' or              |
     `centered'.                                                              |
                                                                              |
                                                                              |
 -- Function: make-cell Hamiltonian-path-vector precession                    |
 -- Function: make-cell Hamiltonian-path-vector                               |
     TYPE must be a vector of SIDE^RANK lists of RANK of integers             |
     encoding the coordinate positions of a Hamiltonian path on the           |
     RANK-dimensional grid of points starting and ending on corners of        |
     the grid.  The starting corner must be the origin (all-zero              |
     coordinates). If the side-length is even, then the ending corner         |
     must be non-zero in only one coordinate; otherwise, the ending           |
     corner must be the furthest diagonally opposite corner from the          |
     origin.                                                                  |
                                                                              |
     `make-cell' returns a data object suitable for passing as the            |
     first argument to `integer->coordinates' or `coordinates->integer'.      |
                                                                              |
  Hilbert, Peano, and centered Peano cells are generated respectively         |
by:                                                                           |
     (make-cell 'adjacent RANK 2)   ; Hilbert                                 |
     (make-cell 'diagonal RANK 3)   ; Peano                                   |
     (make-cell 'centered RANK 3)   ; centered Peano                          |
                                                                              |
  In the conversion procedures, if the cell is `diagonal' or                  |
`adjacent', then the coordinates and scalar must be nonnegative               |
integers.  If `centered', then the integers can be negative.                  |
                                                                              |
 -- Function: integer->coordinates cell u                                     |
     `integer->coordinates' converts the integer U to a list of               |
     coordinates according to CELL.                                           |
                                                                              |
 -- Function: coordinates->integer cell v                                     |
     `coordinates->integer' converts the list of coordinates V to an          |
     integer according to CELL.                                               |
                                                                              |
  COORDINATES->INTEGER and INTEGER->COORDINATES are inverse functions         |
when passed the same CELL argument.                                           |
                                                                              |

File: slib-3b5.info,  Node: Hilbert Space-Filling Curve,  Next: Peano Space-Filling Curve,  Prev: Multidimensional Space-Filling Curves,  Up: Space-Filling Curves
                                                                              |
7.2.7.2 Hilbert Space-Filling Curve                                           |
...................................

`(require 'hilbert-fill)' 

The "Hilbert Space-Filling Curve" is a one-to-one mapping between a
unit line segment and an N-dimensional unit cube.  This implementation
treats the nonnegative integers either as fractional bits of a given
width or as nonnegative integers.

The integer procedures map the non-negative integers to an arbitrarily
large N-dimensional cube with its corner at the origin and all
coordinates are non-negative.

For any exact nonnegative integer SCALAR and exact integer RANK > 2,

     (= SCALAR (hilbert-coordinates->integer
                (integer->hilbert-coordinates SCALAR RANK)))
                                            => #t

  When treating integers as K fractional bits,

     (= SCALAR (hilbert-coordinates->integer
                (integer->hilbert-coordinates SCALAR RANK K)) K)
                                            => #t

 -- Function: integer->hilbert-coordinates scalar rank
     Returns a list of RANK integer coordinates corresponding to exact
     non-negative integer SCALAR.  The lists returned by
     `integer->hilbert-coordinates' for SCALAR arguments 0 and 1 will
     differ in the first element.


 -- Function: integer->hilbert-coordinates scalar rank k
     SCALAR must be a nonnegative integer of no more than `RANK*K' bits.

     `integer->hilbert-coordinates' Returns a list of RANK K-bit
     nonnegative integer coordinates corresponding to exact
     non-negative integer SCALAR.  The curves generated by
     `integer->hilbert-coordinates' have the same alignment independent
     of K.

 -- Function: hilbert-coordinates->integer coords
 -- Function: hilbert-coordinates->integer coords k
     Returns an exact non-negative integer corresponding to COORDS, a
     list of non-negative integer coordinates.

7.2.7.3 Gray code                                                             |
.................

A "Gray code" is an ordering of non-negative integers in which exactly
one bit differs between each pair of successive elements.  There are
multiple Gray codings.  An n-bit Gray code corresponds to a Hamiltonian
cycle on an n-dimensional hypercube.

Gray codes find use communicating incrementally changing values between
asynchronous agents.  De-laminated Gray codes comprise the coordinates
of Hilbert space-filling curves.

 -- Function: integer->gray-code k
     Converts K to a Gray code of the same `integer-length' as K.

 -- Function: gray-code->integer k
     Converts the Gray code K to an integer of the same
     `integer-length' as K.

     For any non-negative integer K,
          (eqv? k (gray-code->integer (integer->gray-code k)))

 -- Function: = k1 k2
 -- Function: gray-code<? k1 k2
 -- Function: gray-code>? k1 k2
 -- Function: gray-code<=? k1 k2
 -- Function: gray-code>=? k1 k2
     These procedures return #t if their Gray code arguments are
     (respectively): equal, monotonically increasing, monotonically
     decreasing, monotonically nondecreasing, or monotonically
     nonincreasing.

     For any non-negative integers K1 and K2, the Gray code predicate
     of `(integer->gray-code k1)' and `(integer->gray-code k2)' will
     return the same value as the corresponding predicate of K1 and K2.

7.2.7.4 Bitwise Lamination                                                    |
..........................

 -- Function: delaminate-list count ks
     Returns a list of COUNT integers comprised of the Jth bit of the
     integers KS where J ranges from COUNT-1 to 0.

          (map (lambda (k) (number->string k 2))
               (delaminate-list 4 '(7 6 5 4 0 0 0 0)))
              => ("0" "11110000" "11000000" "10100000")

     `delaminate-list' is its own inverse:
          (delaminate-list 8 (delaminate-list 4 '(7 6 5 4 0 0 0 0)))
              => (7 6 5 4 0 0 0 0)


File: slib-3b5.info,  Node: Peano Space-Filling Curve,  Next: Sierpinski Curve,  Prev: Hilbert Space-Filling Curve,  Up: Space-Filling Curves
                                                                              |
7.2.7.5 Peano Space-Filling Curve                                             |
.................................

`(require 'peano-fill)' 

 -- Function: natural->peano-coordinates scalar rank
     Returns a list of RANK nonnegative integer coordinates
     corresponding to exact nonnegative integer SCALAR.  The lists
     returned by `natural->peano-coordinates' for SCALAR arguments 0
     and 1 will differ in the first element.

 -- Function: peano-coordinates->natural coords
     Returns an exact nonnegative integer corresponding to COORDS, a
     list of nonnegative integer coordinates.

 -- Function: integer->peano-coordinates scalar rank
     Returns a list of RANK integer coordinates corresponding to exact
     integer SCALAR.  The lists returned by
     `integer->peano-coordinates' for SCALAR arguments 0 and 1 will
     differ in the first element.

 -- Function: peano-coordinates->integer coords
     Returns an exact integer corresponding to COORDS, a list of integer
     coordinates.


File: slib-3b5.info,  Node: Sierpinski Curve,  Prev: Peano Space-Filling Curve,  Up: Space-Filling Curves
                                                                              |
7.2.7.6 Sierpinski Curve                                                      |
........................

`(require 'sierpinski)' 

 -- Function: make-sierpinski-indexer max-coordinate
     Returns a procedure (eg hash-function) of 2 numeric arguments which
     preserves _nearness_ in its mapping from NxN to N.

     MAX-COORDINATE is the maximum coordinate (a positive integer) of a
     population of points.  The returned procedures is a function that
     takes the x and y coordinates of a point, (non-negative integers)
     and returns an integer corresponding to the relative position of
     that point along a Sierpinski curve.  (You can think of this as
     computing a (pseudo-) inverse of the Sierpinski spacefilling
     curve.)

     Example use: Make an indexer (hash-function) for integer points
     lying in square of integer grid points [0,99]x[0,99]:
          (define space-key (make-sierpinski-indexer 100))
     Now let's compute the index of some points:
          (space-key 24 78)               => 9206
          (space-key 23 80)               => 9172

     Note that locations (24, 78) and (23, 80) are near in index and
     therefore, because the Sierpinski spacefilling curve is
     continuous, we know they must also be near in the plane.  Nearness
     in the plane does not, however, necessarily correspond to nearness
     in index, although it _tends_ to be so.

     Example applications:
        * Sort points by Sierpinski index to get heuristic solution to
          _travelling salesman problem_.  For details of performance,
          see L. Platzman and J. Bartholdi, "Spacefilling curves and the
          Euclidean travelling salesman problem", JACM 36(4):719-737
          (October 1989) and references therein.

        * Use Sierpinski index as key by which to store 2-dimensional
          data in a 1-dimensional data structure (such as a table).
          Then locations that are near each other in 2-d space will
          tend to be near each other in 1-d data structure; and
          locations that are near in 1-d data structure will be near in
          2-d space.  This can significantly speed retrieval from
          secondary storage because contiguous regions in the plane
          will tend to correspond to contiguous regions in secondary
          storage.  (This is a standard technique for managing CAD/CAM
          or geographic data.)



File: slib-3b5.info,  Node: Soundex,  Next: String Search,  Prev: Space-Filling Curves,  Up: Sorting and Searching
                                                                              |
7.2.8 Soundex
-------------

`(require 'soundex)' 

 -- Function: soundex name
     Computes the _soundex_ hash of NAME.  Returns a string of an
     initial letter and up to three digits between 0 and 6.  Soundex
     supposedly has the property that names that sound similar in normal
     English pronunciation tend to map to the same key.

     Soundex was a classic algorithm used for manual filing of personal
     records before the advent of computers.  It performs adequately for
     English names but has trouble with other languages.

     See Knuth, Vol. 3 `Sorting and searching', pp 391-2

     To manage unusual inputs, `soundex' omits all non-alphabetic
     characters.  Consequently, in this implementation:

          (soundex <string of blanks>)    => ""
          (soundex "")                    => ""

     Examples from Knuth:

          (map soundex '("Euler" "Gauss" "Hilbert" "Knuth"
                                 "Lloyd" "Lukasiewicz"))
                  => ("E460" "G200" "H416" "K530" "L300" "L222")

          (map soundex '("Ellery" "Ghosh" "Heilbronn" "Kant"
                                  "Ladd" "Lissajous"))
                  => ("E460" "G200" "H416" "K530" "L300" "L222")

     Some cases in which the algorithm fails (Knuth):

          (map soundex '("Rogers" "Rodgers"))     => ("R262" "R326")

          (map soundex '("Sinclair" "St. Clair")) => ("S524" "S324")

          (map soundex '("Tchebysheff" "Chebyshev")) => ("T212" "C121")


File: slib-3b5.info,  Node: String Search,  Next: Sequence Comparison,  Prev: Soundex,  Up: Sorting and Searching
                                                                              |
7.2.9 String Search
-------------------

`(require 'string-search)' 

 -- Procedure: string-index string char
 -- Procedure: string-index-ci string char
     Returns the index of the first occurence of CHAR within STRING, or
     `#f' if the STRING does not contain a character CHAR.

 -- Procedure: string-reverse-index string char
 -- Procedure: string-reverse-index-ci string char
     Returns the index of the last occurence of CHAR within STRING, or
     `#f' if the STRING does not contain a character CHAR.

 -- Procedure: substring? pattern string
 -- Procedure: substring-ci? pattern string
     Searches STRING to see if some substring of STRING is equal to
     PATTERN.  `substring?' returns the index of the first character of
     the first substring of STRING that is equal to PATTERN; or `#f' if
     STRING does not contain PATTERN.

          (substring? "rat" "pirate") =>  2
          (substring? "rat" "outrage") =>  #f
          (substring? "" any-string) =>  0

 -- Procedure: find-string-from-port? str in-port max-no-chars
     Looks for a string STR within the first MAX-NO-CHARS chars of the
     input port IN-PORT.

 -- Procedure: find-string-from-port? str in-port
     When called with two arguments, the search span is limited by the
     end of the input stream.

 -- Procedure: find-string-from-port? str in-port char
     Searches up to the first occurrence of character CHAR in STR.

 -- Procedure: find-string-from-port? str in-port proc
     Searches up to the first occurrence of the procedure PROC
     returning non-false when called with a character (from IN-PORT)
     argument.

     When the STR is found, `find-string-from-port?' returns the number
     of characters it has read from the port, and the port is set to
     read the first char after that (that is, after the STR) The
     function returns `#f' when the STR isn't found.

     `find-string-from-port?' reads the port _strictly_ sequentially,
     and does not perform any buffering.  So `find-string-from-port?'
     can be used even if the IN-PORT is open to a pipe or other
     communication channel.

 -- Function: string-subst txt old1 new1 ...
     Returns a copy of string TXT with all occurrences of string OLD1
     in TXT replaced with NEW1; then OLD2 replaced with NEW2 ....
     Matches are found from the left.  Matches do not overlap.

 -- Function: count-newlines str
     Returns the number of `#\newline' characters in string STR.


File: slib-3b5.info,  Node: Sequence Comparison,  Prev: String Search,  Up: Sorting and Searching
                                                                              |
7.2.10 Sequence Comparison
--------------------------

`(require 'diff)' 

`diff:edit-length' implements the algorithm:

     S. Wu, E. Myers, U. Manber, and W. Miller,
        "An O(NP) Sequence Comparison Algorithm,"
        Information Processing Letters 35, 6 (1990), 317-323.
        `http://www.cs.arizona.edu/people/gene/PAPERS/np_diff.ps'

The values returned by `diff:edit-length' can be used to gauge the
degree of match between two sequences.

`diff:edits' and `diff:longest-common-subsequence' combine the
algorithm with the divide-and-conquer method outlined in:

     E. Myers and W. Miller,
        "Optimal alignments in linear space",
        Computer Application in the Biosciences (CABIOS), 4(1):11-17, 1988.
        `http://www.cs.arizona.edu/people/gene/PAPERS/linear.ps'

If the items being sequenced are text lines, then the computed
edit-list is equivalent to the output of the "diff" utility program.
If the items being sequenced are words, then it is like the lesser
known "spiff" program.  

 -- Function: diff:longest-common-subsequence array1 array2 p-lim
 -- Function: diff:longest-common-subsequence array1 array2
     ARRAY1 and ARRAY2 are one-dimensional arrays.

     The non-negative integer P-LIM, if provided, is maximum number of
     deletions of the shorter sequence to allow.
     `diff:longest-common-subsequence' will return `#f' if more
     deletions would be necessary.

     `diff:longest-common-subsequence' returns a one-dimensional array
     of length `(quotient (- (+ len1 len2) (diff:edit-length ARRAY1
     ARRAY2)) 2)' holding the longest sequence common to both ARRAYs.

 -- Function: diff:edits array1 array2 p-lim
 -- Function: diff:edits array1 array2
     ARRAY1 and ARRAY2 are one-dimensional arrays.

     The non-negative integer P-LIM, if provided, is maximum number of
     deletions of the shorter sequence to allow.  `diff:edits' will
     return `#f' if more deletions would be necessary.

     `diff:edits' returns a vector of length `(diff:edit-length ARRAY1
     ARRAY2)' composed of a shortest sequence of edits transformaing
     ARRAY1 to ARRAY2.

     Each edit is an integer:
    K > 0
          Inserts `(array-ref ARRAY1 (+ -1 J))' into the sequence.

    K < 0
          Deletes `(array-ref ARRAY2 (- -1 K))' from the sequence.

 -- Function: diff:edit-length array1 array2 p-lim
 -- Function: diff:edit-length array1 array2
     ARRAY1 and ARRAY2 are one-dimensional arrays.

     The non-negative integer P-LIM, if provided, is maximum number of
     deletions of the shorter sequence to allow.  `diff:edit-length'
     will return `#f' if more deletions would be necessary.

     `diff:edit-length' returns the length of the shortest sequence of
     edits transformaing ARRAY1 to ARRAY2.

     (diff:longest-common-subsequence "fghiejcklm" "fgehijkpqrlm")
     => "fghijklm"

     (diff:edit-length "fghiejcklm" "fgehijkpqrlm")
     => 6

     (diff:edits "fghiejcklm" "fgehijkpqrlm")
     => #A:fixZ32b(3 -5 -7 8 9 10)
            ; e  c  h p q  r


File: slib-3b5.info,  Node: Procedures,  Next: Standards Support,  Prev: Sorting and Searching,  Up: Other Packages
                                                                              |
7.3 Procedures
==============

Anything that doesn't fall neatly into any of the other categories winds
up here.

* Menu:

* Type Coercion::               'coerce
* String-Case::                 'string-case
* String Ports::                'string-port
* Line I/O::                    'line-i/o
* Multi-Processing::            'process
* Metric Units::                Portable manifest types for numeric values.


File: slib-3b5.info,  Node: Type Coercion,  Next: String-Case,  Prev: Procedures,  Up: Procedures
                                                                              |
7.3.1 Type Coercion
-------------------

`(require 'coerce)' 

 -- Function: type-of obj
     Returns a symbol name for the type of OBJ.

 -- Function: coerce obj result-type
     Converts and returns OBJ of type `char', `number', `string',
     `symbol', `list', or `vector' to RESULT-TYPE (which must be one of
     these symbols).


File: slib-3b5.info,  Node: String-Case,  Next: String Ports,  Prev: Type Coercion,  Up: Procedures
                                                                              |
7.3.2 String-Case
-----------------

`(require 'string-case)' 

 -- Procedure: string-upcase str
 -- Procedure: string-downcase str
 -- Procedure: string-capitalize str
     The obvious string conversion routines.  These are non-destructive.

 -- Function: string-upcase! str
 -- Function: string-downcase! str
 -- Function: string-capitalize! str
     The destructive versions of the functions above.

 -- Function: string-ci->symbol str
     Converts string STR to a symbol having the same case as if the
     symbol had been `read'.

 -- Function: symbol-append obj1 ...
     Converts OBJ1 ... to strings, appends them, and converts to a
     symbol which is returned.  Strings and numbers are converted to
     read's symbol case; the case of symbol characters is not changed.
     #f is converted to the empty string (symbol).

 -- Function: StudlyCapsExpand str delimiter
 -- Function: StudlyCapsExpand str
     DELIMITER must be a string or character.  If absent, DELIMITER
     defaults to `-'.  `StudlyCapsExpand' returns a copy of STR where
     DELIMITER is inserted between each lower-case character
     immediately followed by an upper-case character; and between two
     upper-case characters immediately followed by a lower-case
     character.

          (StudlyCapsExpand "aX" " ")   => "a X"
          (StudlyCapsExpand "aX" "..")  => "a..X"
          (StudlyCapsExpand "AX")       => "AX"
          (StudlyCapsExpand "Ax")       => "Ax"
          (StudlyCapsExpand "AXLE")     => "AXLE"
          (StudlyCapsExpand "aAXACz")   => "a-AXA-Cz"
          (StudlyCapsExpand "AaXACz")   => "Aa-XA-Cz"
          (StudlyCapsExpand "AAaXACz")  => "A-Aa-XA-Cz"
          (StudlyCapsExpand "AAaXAC")   => "A-Aa-XAC"



File: slib-3b5.info,  Node: String Ports,  Next: Line I/O,  Prev: String-Case,  Up: Procedures
                                                                              |
7.3.3 String Ports
------------------

`(require 'string-port)' 

 -- Procedure: call-with-output-string proc
     PROC must be a procedure of one argument.  This procedure calls
     PROC with one argument: a (newly created) output port.  When the
     function returns, the string composed of the characters written
     into the port is returned.

 -- Procedure: call-with-input-string string proc
     PROC must be a procedure of one argument.  This procedure calls
     PROC with one argument: an (newly created) input port from which
     STRING's contents may be read.  When PROC returns, the port is
     closed and the value yielded by the procedure PROC is returned.


File: slib-3b5.info,  Node: Line I/O,  Next: Multi-Processing,  Prev: String Ports,  Up: Procedures
                                                                              |
7.3.4 Line I/O
--------------

`(require 'line-i/o)' 

 -- Function: read-line
 -- Function: read-line port
     Returns a string of the characters up to, but not including a
     newline or end of file, updating PORT to point to the character
     following the newline.  If no characters are available, an end of
     file object is returned.  The PORT argument may be omitted, in
     which case it defaults to the value returned by
     `current-input-port'.

 -- Procedure: read-line! string
 -- Procedure: read-line! string port
     Fills STRING with characters up to, but not including a newline or
     end of file, updating the PORT to point to the last character read
     or following the newline if it was read.  If no characters are
     available, an end of file object is returned.  If a newline or end
     of file was found, the number of characters read is returned.
     Otherwise, `#f' is returned.  The PORT argument may be omitted, in
     which case it defaults to the value returned by
     `current-input-port'.

 -- Function: write-line string
 -- Function: write-line string port
     Writes STRING followed by a newline to the given PORT and returns
     an unspecified value.  The PORT argument may be omitted, in which
     case it defaults to the value returned by `current-input-port'.

 -- Function: system->line command tmp
 -- Function: system->line command
     COMMAND must be a string.  The string TMP, if supplied, is a path
     to use as a temporary file.  `system->line' calls `system' with
     COMMAND as argument, redirecting stdout to file TMP.
     `system->line' returns a string containing the first line of
     output from TMP.

     `system->line' is intended to be a portable method for getting
     one-line results from programs like `pwd', `whoami', `hostname',
     `which', `identify', and `cksum'.  Its behavior when called with
     programs which generate lots of output is unspecified.


File: slib-3b5.info,  Node: Multi-Processing,  Next: Metric Units,  Prev: Line I/O,  Up: Procedures
                                                                              |
7.3.5 Multi-Processing
----------------------

`(require 'process)' 

  This module implements asynchronous (non-polled) time-sliced
multi-processing in the SCM Scheme implementation using procedures
`alarm' and `alarm-interrupt'.  Until this is ported to another
implementation, consider it an example of writing schedulers in Scheme.

 -- Procedure: add-process! proc
     Adds proc, which must be a procedure (or continuation) capable of
     accepting accepting one argument, to the `process:queue'.  The
     value returned is unspecified.  The argument to PROC should be
     ignored.  If PROC returns, the process is killed.

 -- Procedure: process:schedule!
     Saves the current process on `process:queue' and runs the next
     process from `process:queue'.  The value returned is unspecified.

 -- Procedure: kill-process!
     Kills the current process and runs the next process from
     `process:queue'.  If there are no more processes on
     `process:queue', `(slib:exit)' is called (*note System::).


File: slib-3b5.info,  Node: Metric Units,  Prev: Multi-Processing,  Up: Procedures
                                                                              |
7.3.6 Metric Units
------------------

`(require 'metric-units)' 

  `http://people.csail.mit.edu/jaffer/MIXF'

  "Metric Interchange Format" is a character string encoding for
numerical values and units which:

   * is unambiguous in all locales;

   * uses only [TOG] "Portable Character Set" characters matching "Basic
     Latin" characters in Plane 0 of the Universal Character Set [UCS];

   * is transparent to [UTF-7] and [UTF-8] UCS transformation formats;

   * is human readable and writable;

   * is machine readable and writable;

   * incorporates SI prefixes and units;

   * incorporates [ISO 6093] numbers; and

   * incorporates [IEC 60027-2] binary prefixes.

  In the expression for the value of a quantity, the unit symbol is
placed after the numerical value.  A dot (PERIOD, `.') is placed between
the numerical value and the unit symbol.

  Within a compound unit, each of the base and derived symbols can
optionally have an attached SI prefix.

  Unit symbols formed from other unit symbols by multiplication are
indicated by means of a dot (PERIOD, `.') placed between them.

  Unit symbols formed from other unit symbols by division are indicated
by means of a SOLIDUS (`/') or negative exponents.  The SOLIDUS must
not be repeated in the same compound unit unless contained within a
parenthesized subexpression.

  The grouping formed by a prefix symbol attached to a unit symbol
constitutes a new inseparable symbol (forming a multiple or submultiple
of the unit concerned) which can be raised to a positive or negative
power and which can be combined with other unit symbols to form compound
unit symbols.

  The grouping formed by surrounding compound unit symbols with
parentheses (`(' and `)') constitutes a new inseparable symbol which
can be raised to a positive or negative power and which can be combined
with other unit symbols to form compound unit symbols.

  Compound prefix symbols, that is, prefix symbols formed by the
juxtaposition of two or more prefix symbols, are not permitted.

  Prefix symbols are not used with the time-related unit symbols min
(minute), h (hour), d (day).  No prefix symbol may be used with dB
(decibel).  Only submultiple prefix symbols may be used with the unit
symbols L (liter), Np (neper), o (degree), oC (degree Celsius), rad
(radian), and sr (steradian).  Submultiple prefix symbols may not be
used with the unit symbols t (metric ton), r (revolution), or Bd (baud).

  A unit exponent follows the unit, separated by a CIRCUMFLEX (`^').
Exponents may be positive or negative.  Fractional exponents must be
parenthesized.

7.3.6.1 SI Prefixes
...................

            Factor     Name    Symbol  |  Factor     Name    Symbol
            ======     ====    ======  |  ======     ====    ======
             1e24      yotta      Y    |   1e-1      deci       d
             1e21      zetta      Z    |   1e-2      centi      c
             1e18      exa        E    |   1e-3      milli      m
             1e15      peta       P    |   1e-6      micro      u
             1e12      tera       T    |   1e-9      nano       n
             1e9       giga       G    |   1e-12     pico       p
             1e6       mega       M    |   1e-15     femto      f
             1e3       kilo       k    |   1e-18     atto       a
             1e2       hecto      h    |   1e-21     zepto      z
             1e1       deka       da   |   1e-24     yocto      y

7.3.6.2 Binary Prefixes
.......................

These binary prefixes are valid only with the units B (byte) and bit.
However, decimal prefixes can also be used with bit; and decimal
multiple (not submultiple) prefixes can also be used with B (byte).

                     Factor       (power-of-2)  Name  Symbol
                     ======       ============  ====  ======
            1.152921504606846976e18  (2^60)     exbi    Ei
               1.125899906842624e15  (2^50)     pebi    Pi
                  1.099511627776e12  (2^40)     tebi    Ti
                     1.073741824e9   (2^30)     gibi    Gi
                        1.048576e6   (2^20)     mebi    Mi
                           1.024e3   (2^10)     kibi    Ki

7.3.6.3 Unit Symbols
....................

         Type of Quantity      Name          Symbol   Equivalent
         ================      ====          ======   ==========
     time                      second           s
     time                      minute           min = 60.s
     time                      hour             h   = 60.min
     time                      day              d   = 24.h
     frequency                 hertz            Hz    s^-1
     signaling rate            baud             Bd    s^-1
     length                    meter            m
     volume                    liter            L     dm^3
     plane angle               radian           rad
     solid angle               steradian        sr    rad^2
     plane angle               revolution     * r   = 6.283185307179586.rad
     plane angle               degree         * o   = 2.777777777777778e-3.r
     information capacity      bit              bit
     information capacity      byte, octet      B   = 8.bit
     mass                      gram             g
     mass                      ton              t     Mg
     mass              unified atomic mass unit u   = 1.66053873e-27.kg
     amount of substance       mole             mol
     catalytic activity        katal            kat   mol/s
     thermodynamic temperature kelvin           K
     centigrade temperature    degree Celsius   oC
     luminous intensity        candela          cd
     luminous flux             lumen            lm    cd.sr
     illuminance               lux              lx    lm/m^2
     force                     newton           N     m.kg.s^-2
     pressure, stress          pascal           Pa    N/m^2
     energy, work, heat        joule            J     N.m
     energy                    electronvolt     eV  = 1.602176462e-19.J
     power, radiant flux       watt             W     J/s
     logarithm of power ratio  neper            Np
     logarithm of power ratio  decibel        * dB  = 0.1151293.Np
     electric current          ampere           A
     electric charge           coulomb          C     s.A
     electric potential, EMF   volt             V     W/A
     capacitance               farad            F     C/V
     electric resistance       ohm              Ohm   V/A
     electric conductance      siemens          S     A/V
     magnetic flux             weber            Wb    V.s
     magnetic flux density     tesla            T     Wb/m^2
     inductance                henry            H     Wb/A
     radionuclide activity     becquerel        Bq    s^-1
     absorbed dose energy      gray             Gy    m^2.s^-2
     dose equivalent           sievert          Sv    m^2.s^-2

  * The formulas are:

   * r/rad = 8 * atan(1)

   * o/r = 1 / 360

   * db/Np = ln(10) / 20

 -- Function: si:conversion-factor to-unit from-unit
     If the strings FROM-UNIT and TO-UNIT express valid unit
     expressions for quantities of the same unit-dimensions, then the
     value returned by `si:conversion-factor' will be such that
     multiplying a numerical value expressed in FROM-UNITs by the
     returned conversion factor yields the numerical value expressed in
     TO-UNITs.

     Otherwise, `si:conversion-factor' returns:

    -3
          if neither FROM-UNIT nor TO-UNIT is a syntactically valid
          unit.

    -2
          if FROM-UNIT is not a syntactically valid unit.

    -1
          if TO-UNIT is not a syntactically valid unit.

    0
          if linear conversion (by a factor) is not possible.


     (si:conversion-factor "km/s" "m/s" ) => 0.001
     (si:conversion-factor "N"    "m/s" ) => 0
     (si:conversion-factor "moC"  "oC"  ) => 1000
     (si:conversion-factor "mK"   "oC"  ) => 0
     (si:conversion-factor "rad"  "o"   ) => 0.0174533
     (si:conversion-factor "K"    "o"   ) => 0
     (si:conversion-factor "K"    "K"   ) => 1
     (si:conversion-factor "oK"   "oK"  ) => -3
     (si:conversion-factor ""     "s/s" ) => 1
     (si:conversion-factor "km/h" "mph" ) => -2


File: slib-3b5.info,  Node: Standards Support,  Next: Session Support,  Prev: Procedures,  Up: Other Packages
                                                                              |
7.4 Standards Support
=====================

* Menu:

* RnRS::                        Revised Reports on Scheme
* With-File::                   'with-file
* Transcripts::                 'transcript
* Rev2 Procedures::             'rev2-procedures
* Rev4 Optional Procedures::    'rev4-optional-procedures
* Multi-argument / and -::      'multiarg/and-
* Multi-argument Apply::        'multiarg-apply
* Rationalize::                 'rationalize
* Promises::                    'delay
* Dynamic-Wind::                'dynamic-wind
* Eval::                        'eval
* Values::                      'values
* SRFI::                        'http://srfi.schemers.org/srfi-0/srfi-0.html


File: slib-3b5.info,  Node: RnRS,  Next: With-File,  Prev: Standards Support,  Up: Standards Support
                                                                              |
7.4.1 RnRS
----------

The `r2rs', `r3rs', `r4rs', and `r5rs' features attempt to provide
procedures and macros to bring a Scheme implementation to the desired
version of Scheme.

 -- Feature: r2rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^2 Report on the Algorithmic Language Scheme';
     namely `rev3-procedures' and `rev2-procedures'.

 -- Feature: r3rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^3 Report on the Algorithmic Language Scheme';
     namely `rev3-procedures'.

     _Note:_ SLIB already mandates the `r3rs' procedures which can be
     portably implemented in `r4rs' implementations.

 -- Feature: r4rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^4 Report on the Algorithmic Language Scheme';
     namely `rev4-optional-procedures'.

 -- Feature: r5rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^5 Report on the Algorithmic Language Scheme';
     namely `values', `macro', and `eval'.


File: slib-3b5.info,  Node: With-File,  Next: Transcripts,  Prev: RnRS,  Up: Standards Support
                                                                              |
7.4.2 With-File
---------------

`(require 'with-file)' 

 -- Function: with-input-from-file file thunk
 -- Function: with-output-to-file file thunk
     Description found in R4RS.


File: slib-3b5.info,  Node: Transcripts,  Next: Rev2 Procedures,  Prev: With-File,  Up: Standards Support
                                                                              |
7.4.3 Transcripts
-----------------

`(require 'transcript)' 

 -- Function: transcript-on filename
 -- Function: transcript-off filename
     Redefines `read-char', `read', `write-char', `write', `display',
     and `newline'.


File: slib-3b5.info,  Node: Rev2 Procedures,  Next: Rev4 Optional Procedures,  Prev: Transcripts,  Up: Standards Support
                                                                              |
7.4.4 Rev2 Procedures
---------------------

`(require 'rev2-procedures)' 

  The procedures below were specified in the `Revised^2 Report on
Scheme'.  *N.B.*: The symbols `1+' and `-1+' are not `R4RS' syntax.
Scheme->C, for instance, chokes on this module.

 -- Procedure: substring-move-left! string1 start1 end1 string2 start2
 -- Procedure: substring-move-right! string1 start1 end1 string2 start2
     STRING1 and STRING2 must be a strings, and START1, START2 and END1
     must be exact integers satisfying

          0 <= START1 <= END1 <= (string-length STRING1)
          0 <= START2 <= END1 - START1 + START2 <= (string-length STRING2)

     `substring-move-left!' and `substring-move-right!' store
     characters of STRING1 beginning with index START1 (inclusive) and
     ending with index END1 (exclusive) into STRING2 beginning with
     index START2 (inclusive).

     `substring-move-left!' stores characters in time order of
     increasing indices.  `substring-move-right!' stores characters in
     time order of increasing indeces.

 -- Procedure: substring-fill! string start end char
     Fills the elements START-END of STRING with the character CHAR.

 -- Function: string-null? str
     == `(= 0 (string-length STR))'

 -- Procedure: append! pair1 ...
     Destructively appends its arguments.  Equivalent to `nconc'.

 -- Function: 1+ n
     Adds 1 to N.

 -- Function: -1+ n
     Subtracts 1 from N.

 -- Function: <?
 -- Function: <=?
 -- Function: =?
 -- Function: >?
 -- Function: >=?
     These are equivalent to the procedures of the same name but
     without the trailing `?'.


File: slib-3b5.info,  Node: Rev4 Optional Procedures,  Next: Multi-argument / and -,  Prev: Rev2 Procedures,  Up: Standards Support
                                                                              |
7.4.5 Rev4 Optional Procedures
------------------------------

`(require 'rev4-optional-procedures)' 

  For the specification of these optional procedures, *Note Standard
procedures: (r4rs)Standard procedures.

 -- Function: list-tail l p

 -- Function: string-copy

 -- Procedure: string-fill! s obj

 -- Procedure: vector-fill! s obj


File: slib-3b5.info,  Node: Multi-argument / and -,  Next: Multi-argument Apply,  Prev: Rev4 Optional Procedures,  Up: Standards Support
                                                                              |
7.4.6 Multi-argument / and -
----------------------------

`(require 'multiarg/and-)' 

  For the specification of these optional forms, *Note Numerical
operations: (r4rs)Numerical operations.

 -- Function: / dividend divisor1 ...

 -- Function: - minuend subtrahend1 ...


File: slib-3b5.info,  Node: Multi-argument Apply,  Next: Rationalize,  Prev: Multi-argument / and -,  Up: Standards Support
                                                                              |
7.4.7 Multi-argument Apply
--------------------------

`(require 'multiarg-apply)' 

For the specification of this optional form, *Note Control features:
(r4rs)Control features.

 -- Function: apply proc arg1 ...


File: slib-3b5.info,  Node: Rationalize,  Next: Promises,  Prev: Multi-argument Apply,  Up: Standards Support
                                                                              |
7.4.8 Rationalize
-----------------

`(require 'rationalize)' 

 -- Function: rationalize x e
     Computes the correct result for exact arguments (provided the
     implementation supports exact rational numbers of unlimited
     precision); and produces a reasonable answer for inexact arguments
     when inexact arithmetic is implemented using floating-point.


  `Rationalize' has limited use in implementations lacking exact
(non-integer) rational numbers.  The following procedures return a list
of the numerator and denominator.

 -- Function: find-ratio x e
     `find-ratio' returns the list of the _simplest_ numerator and
     denominator whose quotient differs from X by no more than E.

     (find-ratio 3/97 .0001)             => (3 97)
     (find-ratio 3/97 .001)              => (1 32)

 -- Function: find-ratio-between x y
     `find-ratio-between' returns the list of the _simplest_ numerator
     and denominator between X and Y.

     (find-ratio-between 2/7 3/5)        => (1 2)
     (find-ratio-between -3/5 -2/7)      => (-1 2)


File: slib-3b5.info,  Node: Promises,  Next: Dynamic-Wind,  Prev: Rationalize,  Up: Standards Support
                                                                              |
7.4.9 Promises
--------------

`(require 'promise)' 

 -- Function: make-promise proc

 -- Function: force promise

  `(require 'delay)' provides `force' and `delay':

 -- Macro: delay obj
     Change occurrences of `(delay EXPRESSION)' to

          (make-promise (lambda () EXPRESSION))


  (*note Control features: (r4rs)Control features.).


File: slib-3b5.info,  Node: Dynamic-Wind,  Next: Eval,  Prev: Promises,  Up: Standards Support
                                                                              |
7.4.10 Dynamic-Wind
-------------------

`(require 'dynamic-wind)' 

  This facility is a generalization of Common LISP `unwind-protect',
designed to take into account the fact that continuations produced by
`call-with-current-continuation' may be reentered.

 -- Procedure: dynamic-wind thunk1 thunk2 thunk3
     The arguments THUNK1, THUNK2, and THUNK3 must all be procedures of
     no arguments (thunks).

     `dynamic-wind' calls THUNK1, THUNK2, and then THUNK3.  The value
     returned by THUNK2 is returned as the result of `dynamic-wind'.
     THUNK3 is also called just before control leaves the dynamic
     context of THUNK2 by calling a continuation created outside that
     context.  Furthermore, THUNK1 is called before reentering the
     dynamic context of THUNK2 by calling a continuation created inside
     that context.  (Control is inside the context of THUNK2 if THUNK2
     is on the current return stack).

     *Warning:* There is no provision for dealing with errors or
     interrupts.  If an error or interrupt occurs while using
     `dynamic-wind', the dynamic environment will be that in effect at
     the time of the error or interrupt.


File: slib-3b5.info,  Node: Eval,  Next: Values,  Prev: Dynamic-Wind,  Up: Standards Support
                                                                              |
7.4.11 Eval
-----------

`(require 'eval)' 

 -- Function: eval expression environment-specifier
     Evaluates EXPRESSION in the specified environment and returns its
     value.  EXPRESSION must be a valid Scheme expression represented
     as data, and ENVIRONMENT-SPECIFIER must be a value returned by one
     of the three procedures described below.  Implementations may
     extend `eval' to allow non-expression programs (definitions) as
     the first argument and to allow other values as environments, with
     the restriction that `eval' is not allowed to create new bindings
     in the environments associated with `null-environment' or
     `scheme-report-environment'.

          (eval '(* 7 3) (scheme-report-environment 5))
                                                             =>  21

          (let ((f (eval '(lambda (f x) (f x x))
                         (null-environment))))
            (f + 10))
                                                             =>  20

 -- Function: scheme-report-environment version
 -- Function: null-environment version
 -- Function: null-environment
     VERSION must be an exact non-negative integer N corresponding to a
     version of one of the Revised^N Reports on Scheme.
     `Scheme-report-environment' returns a specifier for an environment
     that contains the set of bindings specified in the corresponding
     report that the implementation supports.  `Null-environment'
     returns a specifier for an environment that contains only the
     (syntactic) bindings for all the syntactic keywords defined in the
     given version of the report.

     Not all versions may be available in all implementations at all
     times.  However, an implementation that conforms to version N of
     the Revised^N Reports on Scheme must accept version N.  An error
     is signalled if the specified version is not available.

     The effect of assigning (through the use of `eval') a variable
     bound in a `scheme-report-environment' (for example `car') is
     unspecified. Thus the environments specified by
     `scheme-report-environment' may be immutable.


 -- Function: interaction-environment
     This optional procedure returns a specifier for the environment
     that contains implementation-defined bindings, typically a
     superset of those listed in the report.  The intent is that this
     procedure will return the environment in which the implementation
     would evaluate expressions dynamically typed by the user.

Here are some more `eval' examples:

     (require 'eval)
     => #<unspecified>
     (define car 'volvo)
     => #<unspecified>
     car
     => volvo
     (eval 'car (interaction-environment))
     => volvo
     (eval 'car (scheme-report-environment 5))
     => #<primitive-procedure car>
     (eval '(eval 'car (interaction-environment))
           (scheme-report-environment 5))
     => volvo
     (eval '(eval '(set! car 'buick) (interaction-environment))
           (scheme-report-environment 5))
     => #<unspecified>
     car
     => buick
     (eval 'car (scheme-report-environment 5))
     => #<primitive-procedure car>
     (eval '(eval 'car (interaction-environment))
           (scheme-report-environment 5))
     => buick


File: slib-3b5.info,  Node: Values,  Next: SRFI,  Prev: Eval,  Up: Standards Support
                                                                              |
7.4.12 Values
-------------

`(require 'values)' 

 -- Function: values obj ...
     `values' takes any number of arguments, and passes (returns) them
     to its continuation.

 -- Function: call-with-values thunk proc
     THUNK must be a procedure of no arguments, and PROC must be a
     procedure.  `call-with-values' calls THUNK with a continuation
     that, when passed some values, calls PROC with those values as
     arguments.

     Except for continuations created by the `call-with-values'
     procedure, all continuations take exactly one value, as now; the
     effect of passing no value or more than one value to continuations
     that were not created by the `call-with-values' procedure is
     unspecified.


File: slib-3b5.info,  Node: SRFI,  Prev: Values,  Up: Standards Support
                                                                              |
7.4.13 SRFI
-----------

`(require 'srfi)' 

Implements "Scheme Request For Implementation" (SRFI) as described at
`http://srfi.schemers.org/'

 -- Macro: cond-expand <clause1> <clause2> ...
     _Syntax:_ Each <clause> should be of the form

     (<feature> <expression1> ...)

     where <feature> is a boolean expression composed of symbols and
     `and', `or', and `not' of boolean expressions.  The last <clause>
     may be an "else clause," which has the form

     (else <expression1> <expression2> ...).

     The first clause whose feature expression is satisfied is expanded.
     If no feature expression is satisfied and there is no else clause,
     an error is signaled.

     SLIB `cond-expand' is an extension of SRFI-0,
     `http://srfi.schemers.org/srfi-0/srfi-0.html'.

* Menu:

* SRFI-1::                      list-processing

   * SRFI-2 *note Guarded LET* special form:: 

   * SRFI-8 *note Binding to multiple values:: 

   * SRFI-9 *note Define-Record-Type:: 

   * SRFI-11 *note Binding to multiple values:: 

   * SRFI-23 `(define error slib:error)' 

   * SRFI-28 *note Format:: 

   * SRFI-39 *note Parameter Objects::                                        |
                                                                              |
   * SRFI-47 *note Arrays:: 

   * SRFI-59 *note Vicinity:: 

   * SRFI-60 *note Bit-Twiddling:: 

   * SRFI-61 *note Guarded COND Clause:: 

   * SRFI-63 *note Arrays:: 

   * SRFI-94 *note Irrational Integer Functions:: and *note Irrational
     Real Functions:: 

   * SRFI-95 *note Sorting:: 

   * SRFI-96 *note Universal SLIB Procedures::


File: slib-3b5.info,  Node: SRFI-1,  Prev: SRFI,  Up: SRFI
                                                                              |
7.4.13.1 SRFI-1
...............

`(require 'srfi-1)' 

Implements the "SRFI-1" "list-processing library" as described at
`http://srfi.schemers.org/srfi-1/srfi-1.html'

Constructors
------------

 -- Function: xcons d a
     `(define (xcons d a) (cons a d))'.

 -- Function: list-tabulate len proc
     Returns a list of length LEN.  Element I is `(PROC I)' for 0 <= I
     < LEN.

 -- Function: cons* obj1 obj2

 -- Function: list-copy flist

 -- Function: iota count start step
 -- Function: iota count start
 -- Function: iota count
     Returns a list of COUNT numbers: (START, START+STEP, ...,
     START+(COUNT-1)*STEP).

 -- Function: circular-list obj1 obj2 ...
     Returns a circular list of OBJ1, OBJ2, ....

Predicates
----------

 -- Function: proper-list? obj

 -- Function: circular-list? x

 -- Function: dotted-list? obj

 -- Function: null-list? obj

 -- Function: not-pair? obj

 -- Function: list= =pred list ...

Selectors
---------

 -- Function: first pair

 -- Function: second pair

 -- Function: third pair

 -- Function: fourth pair

 -- Function: fifth pair
 -- Function: sixth pair
 -- Function: seventh pair
 -- Function: eighth pair
 -- Function: ninth pair
 -- Function: tenth pair

 -- Function: car+cdr pair

 -- Function: drop lst k
 -- Function: take lst k
 -- Function: take! lst k

 -- Function: take-right lst k

 -- Function: drop-right lst k

 -- Procedure: drop-right! lst k

 -- Function: split-at lst k
 -- Function: split-at! lst k

 -- Function: last lst k ...

Miscellaneous
-------------

 -- Function: length+ clist

 -- Function: concatenate lists
 -- Function: concatenate! lists

 -- Procedure: reverse! lst

 -- Function: append-reverse rev-head tail
 -- Function: append-reverse! rev-head tail

 -- Function: zip list1 list2 ...

 -- Function: unzip1 lst
 -- Function: unzip2 lst
 -- Function: unzip3 lst
 -- Function: unzip4 lst
 -- Function: unzip5 lst

 -- Function: count pred list1 list2 ...

Fold and Unfold
---------------

 -- Function: fold kons knil clist1 clist2 ...

 -- Function: fold-right kons knil clist1 clist2 ...

 -- Function: pair-fold kons knil clist1 clist2 ...

 -- Function: pair-fold-right kons knil clist1 clist2 ...

 -- Function: reduce arg ...

 -- Procedure: map! f clist1 clist2 ...

 -- Function: pair-for-each f clist1 clist2 ...

Filtering and Partitioning
--------------------------

 -- Function: filter pred list

 -- Procedure: filter! pred list

 -- Function: partition pred list

 -- Function: remove pred list

 -- Procedure: partition! pred list

 -- Procedure: remove! pred list

Searching
---------

 -- Function: find pred clist

 -- Function: find-tail pred clist

 -- Function: span pred list

 -- Procedure: span! pred list

 -- Function: break pred list

 -- Procedure: break! pred list

 -- Function: any pred clist1 clist2 ...

 -- Function: list-index pred clist1 clist2 ...

 -- Function: member obj list =
 -- Function: member obj list

Deleting
--------

 -- Function: delete-duplicates x list =
 -- Function: delete-duplicates x list

 -- Procedure: delete-duplicates! x list =
 -- Procedure: delete-duplicates! x list

Association lists
-----------------

 -- Function: assoc obj alist pred
 -- Function: assoc obj alist

 -- Function: alist-cons key datum alist

 -- Function: alist-copy alist

 -- Function: alist-delete key alist =
 -- Function: alist-delete key alist

 -- Procedure: alist-delete! key alist =
 -- Procedure: alist-delete! key alist

Set operations
--------------

 -- Function: lset<= = list1 ...
     Determine if a  transitive subset relation exists between the
     lists LIST1 ..., using = to determine equality of list members.

 -- Function: lset= = list1 list2 ...

 -- Function: lset-adjoin list elt1 ...

 -- Function: lset-union = list1 ...

 -- Function: lset-intersection = list1 list2 ...

 -- Function: lset-difference = list1 list2 ...

 -- Function: lset-xor = list1 ...

 -- Function: lset-diff+intersection = list1 list2 ...

These are linear-update variants.  They are allowed, but not required,
to use the cons cells in their first list parameter to construct their
answer.  `lset-union!' is permitted to recycle cons cells from any of
its list arguments.

 -- Procedure: lset-intersection! = list1 list2 ...

 -- Procedure: lset-difference! = list1 list2 ...

 -- Procedure: lset-union! = list1 ...

 -- Procedure: lset-xor! = list1 ...

 -- Procedure: lset-diff+intersection! = list1 list2 ...


File: slib-3b5.info,  Node: Session Support,  Next: System Interface,  Prev: Standards Support,  Up: Other Packages
                                                                              |
7.5 Session Support
===================

If `(provided? 'abort)':

 -- Function: abort
     Resumes the top level Read-Eval-Print loop.  If provided, `abort'
     is used by the `break' and `debug' packages.

* Menu:

* Repl::                        Macros at top-level
* Quick Print::                 Loop-safe Output
* Debug::                       To err is human ...
* Breakpoints::                 Pause execution
* Trace::                       'trace


File: slib-3b5.info,  Node: Repl,  Next: Quick Print,  Prev: Session Support,  Up: Session Support
                                                                              |
7.5.1 Repl
----------

`(require 'repl)' 

  Here is a read-eval-print-loop which, given an eval, evaluates forms.

 -- Procedure: repl:top-level repl:eval
     `read's, `repl:eval's and `write's expressions from
     `(current-input-port)' to `(current-output-port)' until an
     end-of-file is encountered.  `load', `slib:eval', `slib:error',
     and `repl:quit' dynamically bound during `repl:top-level'.

 -- Procedure: repl:quit
     Exits from the invocation of `repl:top-level'.

  The `repl:' procedures establish, as much as is possible to do
portably, a top level environment supporting macros.  `repl:top-level'
uses `dynamic-wind' to catch error conditions and interrupts.  If your
implementation supports this you are all set.

  Otherwise, if there is some way your implementation can catch error
conditions and interrupts, then have them call `slib:error'.  It will
display its arguments and reenter `repl:top-level'.  `slib:error'
dynamically bound by `repl:top-level'.

  To have your top level loop always use macros, add any interrupt
catching lines and the following lines to your Scheme init file:
     (require 'macro)
     (require 'repl)
     (repl:top-level macro:eval)


File: slib-3b5.info,  Node: Quick Print,  Next: Debug,  Prev: Repl,  Up: Session Support
                                                                              |
7.5.2 Quick Print
-----------------

`(require 'qp)' 

When displaying error messages and warnings, it is paramount that the
output generated for circular lists and large data structures be
limited.  This section supplies a procedure to do this.  It could be
much improved.

     Notice that the neccessity for truncating output eliminates
     Common-Lisp's *note Format:: from consideration; even when
     variables `*print-level*' and `*print-level*' are set, huge
     strings and bit-vectors are _not_ limited.

 -- Procedure: qp arg1 ...
 -- Procedure: qpn arg1 ...
 -- Procedure: qpr arg1 ...
     `qp' writes its arguments, separated by spaces, to
     `(current-output-port)'.  `qp' compresses printing by substituting
     `...' for substructure it does not have sufficient room to print.
     `qpn' is like `qp' but outputs a newline before returning.  `qpr'
     is like `qpn' except that it returns its last argument.

 -- Variable: *qp-width*
     *QP-WIDTH* is the largest number of characters that `qp' should
     use.  If *QP-WIDTH* is #f, then all items will be `write'n.  If
     *QP-WIDTH* is 0, then all items except procedures will be
     `write'n; procedures will be indicated by `#[proc]'.


File: slib-3b5.info,  Node: Debug,  Next: Breakpoints,  Prev: Quick Print,  Up: Session Support
                                                                              |
7.5.3 Debug
-----------

`(require 'debug)' 

Requiring `debug' automatically requires `trace' and `break'.

An application with its own datatypes may want to substitute its own
printer for `qp'.  This example shows how to do this:

     (define qpn (lambda args) ...)
     (provide 'qp)
     (require 'debug)
     

 -- Procedure: trace-all file ...
     Traces (*note Trace::) all procedures `define'd at top-level in
     `file' ....

 -- Procedure: track-all file ...
     Tracks (*note Trace::) all procedures `define'd at top-level in
     `file' ....

 -- Procedure: stack-all file ...
     Stacks (*note Trace::) all procedures `define'd at top-level in
     `file' ....

 -- Procedure: break-all file ...
     Breakpoints (*note Breakpoints::) all procedures `define'd at
     top-level in `file' ....


File: slib-3b5.info,  Node: Breakpoints,  Next: Trace,  Prev: Debug,  Up: Session Support
                                                                              |
7.5.4 Breakpoints
-----------------

`(require 'break)' 

 -- Function: init-debug
     If your Scheme implementation does not support `break' or `abort',
     a message will appear when you `(require 'break)' or `(require
     'debug)' telling you to type `(init-debug)'.  This is in order to
     establish a top-level continuation.  Typing `(init-debug)' at top
     level sets up a continuation for `break'.

 -- Function: breakpoint arg1 ...
     Returns from the top level continuation and pushes the
     continuation from which it was called on a continuation stack.

 -- Function: continue
     Pops the topmost continuation off of the continuation stack and
     returns an unspecified value to it.

 -- Function: continue arg1 ...
     Pops the topmost continuation off of the continuation stack and
     returns ARG1 ... to it.

 -- Macro: break proc1 ...
     Redefines the top-level named procedures given as arguments so that
     `breakpoint' is called before calling PROC1 ....

 -- Macro: break
     With no arguments, makes sure that all the currently broken
     identifiers are broken (even if those identifiers have been
     redefined) and returns a list of the broken identifiers.

 -- Macro: unbreak proc1 ...
     Turns breakpoints off for its arguments.

 -- Macro: unbreak
     With no arguments, unbreaks all currently broken identifiers and
     returns a list of these formerly broken identifiers.

  These are _procedures_ for breaking.  If defmacros are not natively
supported by your implementation, these might be more convenient to use.

 -- Function: breakf proc
 -- Function: breakf proc name
     To break, type
          (set! SYMBOL (breakf SYMBOL))
     or
          (set! SYMBOL (breakf SYMBOL 'SYMBOL))
     or
          (define SYMBOL (breakf FUNCTION))
     or
          (define SYMBOL (breakf FUNCTION 'SYMBOL))

 -- Function: unbreakf proc
     To unbreak, type
          (set! SYMBOL (unbreakf SYMBOL))


File: slib-3b5.info,  Node: Trace,  Prev: Breakpoints,  Up: Session Support
                                                                              |
7.5.5 Tracing
-------------

`(require 'trace)' 

This feature provides three ways to monitor procedure invocations:

stack
     Pushes the procedure-name when the procedure is called; pops when
     it returns.

track
     Pushes the procedure-name and arguments when the procedure is
     called; pops when it returns.

trace
     Pushes the procedure-name and prints `CALL PROCEDURE-NAME ARG1
     ...' when the procdure is called; pops and prints `RETN
     PROCEDURE-NAME VALUE' when the procedure returns.

 -- Variable: debug:max-count
     If a traced procedure calls itself or untraced procedures which
     call it, stack, track, and trace will limit the number of stack
     pushes to DEBUG:MAX-COUNT.

 -- Function: print-call-stack
 -- Function: print-call-stack port
     Prints the call-stack to PORT or the current-error-port.

 -- Macro: trace proc1 ...
     Traces the top-level named procedures given as arguments.

 -- Macro: trace
     With no arguments, makes sure that all the currently traced
     identifiers are traced (even if those identifiers have been
     redefined) and returns a list of the traced identifiers.

 -- Macro: track proc1 ...
     Traces the top-level named procedures given as arguments.

 -- Macro: track
     With no arguments, makes sure that all the currently tracked
     identifiers are tracked (even if those identifiers have been
     redefined) and returns a list of the tracked identifiers.

 -- Macro: stack proc1 ...
     Traces the top-level named procedures given as arguments.

 -- Macro: stack
     With no arguments, makes sure that all the currently stacked
     identifiers are stacked (even if those identifiers have been
     redefined) and returns a list of the stacked identifiers.

 -- Macro: untrace proc1 ...
     Turns tracing, tracking, and  off for its arguments.

 -- Macro: untrace
     With no arguments, untraces all currently traced identifiers and
     returns a list of these formerly traced identifiers.

 -- Macro: untrack proc1 ...
     Turns tracing, tracking, and  off for its arguments.

 -- Macro: untrack
     With no arguments, untracks all currently tracked identifiers and
     returns a list of these formerly tracked identifiers.

 -- Macro: unstack proc1 ...
     Turns tracing, stacking, and  off for its arguments.

 -- Macro: unstack
     With no arguments, unstacks all currently stacked identifiers and
     returns a list of these formerly stacked identifiers.

  These are _procedures_ for tracing.  If defmacros are not natively
supported by your implementation, these might be more convenient to use.

 -- Function: tracef proc
 -- Function: tracef proc name
 -- Function: trackf proc
 -- Function: trackf proc name
 -- Function: stackf proc
 -- Function: stackf proc name
     To trace, type
          (set! SYMBOL (tracef SYMBOL))
     or
          (set! SYMBOL (tracef SYMBOL 'SYMBOL))
     or
          (define SYMBOL (tracef FUNCTION))
     or
          (define SYMBOL (tracef FUNCTION 'SYMBOL))

 -- Function: untracef proc
     Removes tracing, tracking, or stacking for PROC.  To untrace, type
          (set! SYMBOL (untracef SYMBOL))


File: slib-3b5.info,  Node: System Interface,  Next: Extra-SLIB Packages,  Prev: Session Support,  Up: Other Packages
                                                                              |
7.6 System Interface
====================

If `(provided? 'getenv)': 

 -- Function: getenv name
     Looks up NAME, a string, in the program environment.  If NAME is
     found a string of its value is returned.  Otherwise, `#f' is
     returned.

If `(provided? 'system)': 

 -- Function: system command-string
     Executes the COMMAND-STRING on the computer and returns the
     integer status code.  This behaves the same as the POSIX `system'
     call.

If `(provided? 'program-arguments)': 

 -- Function: program-arguments
     Returns a list of strings, the first of which is the program name
     followed by the command-line arguments.

* Menu:

* Directories::
* Transactions::
* CVS::


File: slib-3b5.info,  Node: Directories,  Next: Transactions,  Prev: System Interface,  Up: System Interface
                                                                              |
7.6.1 Directories
-----------------

`(require 'directory)' 

 -- Function: current-directory
     `current-directory' returns a string containing the absolute file
     name representing the current working directory.  If this string
     cannot be obtained, #f is returned.

     If `current-directory' cannot be supported by the platform, then
     #f is returned.

 -- Function: make-directory name
     Creates a sub-directory NAME of the current-directory.  If
     successful, `make-directory' returns #t; otherwise #f.

 -- Function: directory-for-each proc directory
     PROC must be a procedure taking one argument.
     `Directory-For-Each' applies PROC to the (string) name of each
     file in DIRECTORY.  The dynamic order in which PROC is applied to
     the filenames is unspecified.  The value returned by
     `directory-for-each' is unspecified.


 -- Function: directory-for-each proc directory pred
     Applies PROC only to those filenames for which the procedure PRED
     returns a non-false value.


 -- Function: directory-for-each proc directory match
     Applies PROC only to those filenames for which `(filename:match??
     MATCH)' would return a non-false value (*note Filenames:
     (slib)Filenames.).

          (require 'directory)
          (directory-for-each print "." "[A-Z]*.scm")
          -|
          "Bev2slib.scm"
          "Template.scm"

 -- Function: directory*-for-each proc path-glob                              |
     PATH-GLOB is a pathname whose last component is a (wildcard)             |
     pattern (*note Filenames: (slib)Filenames.).  PROC must be a             |
     procedure taking one argument.  `directory*-for-each' applies PROC       |
     to the (string) name of each file in the current directory.  The         |
     dynamic order in which PROC is applied to the filenames is               |
     unspecified.  The value returned by `directory*-for-each' is             |
     unspecified.                                                             |
                                                                              |

File: slib-3b5.info,  Node: Transactions,  Next: CVS,  Prev: Directories,  Up: System Interface
                                                                              |
7.6.2 Transactions
------------------

If `system' is provided by the Scheme implementation, the "transact"
package provides functions for file-locking and file-replacement
transactions.

  `(require 'transact)' 

File Locking
............

Unix file-locking is focussed on write permissions for segments of a
existing file.  While this might be employed for (binary) database
access, it is not used for everyday contention (between users) for text
files.

Microsoft has several file-locking protocols.  Their model denies write
access to a file if any reader has it open.  This is too restrictive.
Write access is denied even when the reader has reached end-of-file.
And tracking read access (which is much more common than write access)
causes havoc when remote hosts crash or disconnect.

It is bizarre that the concept of multi-user contention for modifying
files has not been adequately addressed by either of the large
operating system development efforts.  There is further irony that both
camps support contention detection and resolution only through weak
conventions of some their document editing programs.

The "file-lock" procedures implement a transaction method for file replacement
compatible with the methods used by the GNU "emacs" text editor on Unix
systems and the Microsoft "Word" editor.  

Both protocols employ what I term a "certificate" containing the user,
hostname, time, and (on Unix) process-id.  Intent to replace FILE is
indicated by adding to FILE's directory a certificate object whose name
is derived from FILE.

The Microsoft Word certificate is contained in a 162 byte file named
for the visited FILE with a `~$' prefix.  Emacs/Unix creates a symbolic
link to a certificate named for the visited FILE prefixed with `.#'.
Because Unix systems can import Microsoft file systems, these routines
maintain and check both Emacs and Word certificates.

 -- Function: file-lock-owner path
     Returns the string `USER@HOSTNAME' associated with the lock owner
     of file PATH if locked; and #f otherwise.

 -- Procedure: file-lock! path email
 -- Procedure: file-lock! path
     PATH must be a string naming the file to be locked.  If supplied,
     EMAIL must be a string formatted as `USER@HOSTNAME'.  If absent,
     EMAIL defaults to the value returned by `user-email-address'.

     If PATH is already locked, then `file-lock!' returns `#f'.  If
     PATH is unlocked, then `file-lock!' returns the certificate string
     associated with the new lock for file PATH.

 -- Procedure: file-unlock! path certificate
     PATH must be a string naming the file to be unlocked.  CERTIFICATE
     must be the string returned by `file-lock!' for PATH.

     If PATH is locked with CERTIFICATE, then `file-unlock!' removes
     the locks and returns `#t'.  Otherwise, `file-unlock!' leaves the
     file system unaltered and returns `#f'.

 -- Function: describe-file-lock path prefix
 -- Function: describe-file-lock path
     PATH must be a string naming a file.  Optional argument PREFIX is
     a string printed before each line of the message.
     `describe-file-lock' prints to `(current-error-port)' that PATH is
     locked for writing and lists its lock-files.

          (describe-file-lock "my.txt" ">> ")
          -|
          >> "my.txt" is locked for writing by 'luser@no.com.4829:1200536423'
          >> (lock files are "~$my.txt" and ".#my.txt")

File Transactions
.................

 -- Function: emacs:backup-name path backup-style
     PATH must be a string.  BACKUP-STYLE must be a symbol.  Depending
     on BACKUP-STYLE, `emacs:backup-name' returns:
    none
          #f

    simple
          the string "PATH~"

    numbered
          the string "PATH.~N~", where N is one greater than the
          highest number appearing in a filename matching "PATH.~*~".  N
          defauls to 1 when no filename matches.

    existing
          the string "PATH.~N~" if a numbered backup already exists in
          this directory; otherwise. "PATH~"

    orig
          the string "PATH.orig"

    bak
          the string "PATH.bak"

 -- Function: transact-file-replacement proc path backup-style
          certificate
 -- Function: transact-file-replacement proc path backup-style
 -- Function: transact-file-replacement proc path
     PATH must be a string naming an existing file.  BACKUP-STYLE is
     one of the symbols none, simple, numbered, existing, orig, bak or
     #f; with meanings described above; or a string naming the location
     of a backup file.  BACKUP-STYLE defaults to #f.  If supplied,
     CERTIFICATE is the certificate with which PATH is locked.

     PROC must be a procedure taking two string arguments:
        * PATH, the original filename (to be read); and

        * a temporary file-name.

     If PATH is locked by other than CERTIFICATE, or if CERTIFICATE is
     supplied and PATH is not locked, then `transact-file-replacement'
     returns #f.  If CERTIFICATE is not supplied, then,
     `transact-file-replacement' creates temporary (Emacs and Word)
     locks for PATH during the transaction.  The lock status of PATH
     will be restored before `transact-file-replacement' returns.

     `transact-file-replacement' calls PROC with PATH (which should not
     be modified) and a temporary file path to be written.  If PROC
     returns any value other than #t, then the file named by PATH is
     not altered and `transact-file-replacement' returns #f.
     Otherwise, `emacs:backup-name' is called with PATH and
     BACKUP-STYLE.  If it returns a string, then PATH is renamed to it.

     Finally, the temporary file is renamed PATH.
     `transact-file-replacement' returns #t if PATH was successfully
     replaced; and #f otherwise.

Identification
..............

 -- Function: user-email-address
     `user-email-address' returns a string of the form
     `username@hostname'.  If this e-mail address cannot be obtained,
     #f is returned.


File: slib-3b5.info,  Node: CVS,  Prev: Transactions,  Up: System Interface
                                                                              |
7.6.3 CVS
---------

`(require 'cvs)' 

 -- Function: cvs-files directory/
     Returns a list of the local pathnames (with prefix DIRECTORY/) of
     all CVS controlled files in DIRECTORY/ and in DIRECTORY/'s
     subdirectories.

 -- Function: cvs-directories directory/
     Returns a list of all of DIRECTORY/ and all DIRECTORY/'s CVS
     controlled subdirectories.

 -- Function: cvs-root path/
     Returns the (string) contents of PATH/CVS/Root; or `(getenv
     "CVSROOT")' if Root doesn't exist.

 -- Function: cvs-repository directory/
     Returns the (string) contents of DIRECTORY/CVS/Root appended with
     DIRECTORY/CVS/Repository; or #f if DIRECTORY/CVS/Repository
     doesn't exist.

 -- Procedure: cvs-set-root! new-root directory/
     Writes NEW-ROOT to file CVS/Root of DIRECTORY/.

 -- Procedure: cvs-set-roots! new-root directory/
     Writes NEW-ROOT to file CVS/Root of DIRECTORY/ and all its CVS
     subdirectories.

 -- Function: cvs-vet directory/
     Signals an error if CVS/Repository or CVS/Root files in DIRECTORY/
     or any subdirectory do not match.


File: slib-3b5.info,  Node: Extra-SLIB Packages,  Prev: System Interface,  Up: Other Packages
                                                                              |
7.7 Extra-SLIB Packages
=======================

Several Scheme packages have been written using SLIB.  There are several
reasons why a package might not be included in the SLIB distribution:
   * Because it requires special hardware or software which is not
     universal.

   * Because it is large and of limited interest to most Scheme users.

   * Because it has copying terms different enough from the other SLIB
     packages that its inclusion would cause confusion.

   * Because it is an application program, rather than a library module.

   * Because I have been too busy to integrate it.

  Once an optional package is installed (and an entry added to
`*catalog*'), the `require' mechanism allows it to be called up and
used as easily as any other SLIB package.  Some optional packages (for
which `*catalog*' already has entries) available from SLIB sites are:

SLIB-PSD
     is a portable debugger for Scheme (requires emacs editor).
     `http://groups.csail.mit.edu/mac/ftpdir/scm/slib-psd1-3.tar.gz'          |
     `ftp://ftp.cs.indiana.edu/pub/scheme-repository/utl/slib-psd1-3.tar.gz'  |
     With PSD, you can run a Scheme program in an Emacs buffer, set
     breakpoints, single step evaluation and access and modify the
     program's variables.  It works by instrumenting the original source
     code, so it should run with any R4RS compliant Scheme.  It has been
     tested with SCM, Elk 1.5, and the sci interpreter in the Scheme->C
     system, but should work with other Schemes with a minimal amount of      |
     porting, if at all.  Includes documentation and user's manual.           |
     Written by Pertti Kelloma"ki, the Lisp Pointers article describing       |
     PSD (Lisp Pointers VI(1):15-23, January-March 1993) is available at      |
     `http://www.cs.tut.fi/staff/pk/scheme/psd/article/article.html'          |

SCHELOG
     is an embedding of Prolog in Scheme.
     `http://www.ccs.neu.edu/~dorai/schelog/schelog.html'                     |

JFILTER
     is a Scheme program which converts text among the JIS, EUC, and
     Shift-JIS Japanese character sets.
     `http://www.math.u-toyama.ac.jp/~iwao/Scheme/Jfilter'                    |


File: slib-3b5.info,  Node: About SLIB,  Next: Index,  Prev: Other Packages,  Up: Top
                                                                              |
8 About SLIB
************

More people than I can name have contributed to SLIB.  Thanks to all of
you!

     SLIB 3b5, released January 2015.                                         |
     Aubrey Jaffer <agj@alum.mit.edu>

  Current information about SLIB can be found on SLIB's "WWW" home page:

               `http://people.csail.mit.edu/jaffer/SLIB'

  SLIB is part of the GNU project.

* Menu:

* Installation::                How to install SLIB on your system.
* The SLIB script::             Run interactive SLIB sessions.
* Porting::                     SLIB to new platforms.
* Compiled and Implementation-Specific Features::
* Coding Guidelines::           How to write modules for SLIB.
* Copyrights::                  Intellectual propery issues.
* About this manual::


File: slib-3b5.info,  Node: Installation,  Next: The SLIB script,  Prev: About SLIB,  Up: About SLIB
                                                                              |
8.1 Installation
================

There are five parts to installation:

   * Unpack the SLIB distribution.

   * Install documentation and `slib' script.

   * Configure the Scheme implementation(s) to locate the SLIB directory
     and implementation directories.

   * Arrange for each Scheme implementation to load its SLIB                  |
     initialization file.                                                     |

   * Build the SLIB catalog for each Scheme implementation.                   |

8.1.1 Unpacking the SLIB Distribution
-------------------------------------

If the SLIB distribution is a GNU/Linux RPM, it will create the SLIB
directory `/usr/share/slib'.

  If the SLIB distribution is a ZIP file, unzip the distribution to
create the SLIB directory.  Locate this `slib' directory either in your
home directory (if only you will use this SLIB installation); or put it
in a location where libraries reside on your system.  On unix systems
this might be `/usr/share/slib', `/usr/local/lib/slib', or
`/usr/lib/slib'.  If you know where SLIB should go on other platforms,
please inform agj@alum.mit.edu.

8.1.2 Install documentation and slib script
-------------------------------------------

     make infoz
     make install

8.1.3 Configure Scheme Implementation to Locate SLIB
----------------------------------------------------

If the Scheme implementation supports `getenv', then the value of the
shell environment variable SCHEME_LIBRARY_PATH will be used for
`(library-vicinity)' if it is defined.  Currently, Bigloo, Chez, Elk,
Gambit, Gauche, Guile, Jscheme, Larceny, MITScheme, MzScheme, RScheme,        |
S7, STk, VSCM, and SCM support `getenv'.  Scheme48 supports `getenv'          |
but does not use it for determining `library-vicinity'.  (That is done        |
from the Makefile.)                                                           |

  The `(library-vicinity)' can also be set from the SLIB initialization
file or by implementation-specific means.

8.1.4 Configure Scheme Implementation to Locate and Implementation Directory  |
----------------------------------------------------------------------------  |
                                                                              |
Support for locating an implementation's auxiliary directory is uneven
among implementations.  Also, the person installing SLIB may not have
write permission to some of these directories (necessary for writing
slibcat).  Therefore, those implementations supporting `getenv' (except
SCM and Scheme48) provide a means for specifying the
`implementation-vicinity' through environment variables.  Define the
indicated environment variable to the pathname (with trailing slash or
backslash) of the desired directory.  Do not use `slib/' as an
implementation-vicinity!

Bigloo                 BIGLOO_IMPLEMENTATION_PATH
Chez                   CHEZ_IMPLEMENTATION_PATH
ELK                    ELK_IMPLEMENTATION_PATH
Gambit                 GAMBIT_IMPLEMENTATION_PATH
Guile                  GUILE_IMPLEMENTATION_PATH
Jscheme                JSCHEME_IMPLEMENTATION_PATH
MIT-Scheme             MITSCHEME_IMPLEMENTATION_PATH
MzScheme               MZSCHEME_IMPLEMENTATION_PATH
RScheme                RSCHEME_IMPLEMENTATION_PATH
S7                     S7_IMPLEMENTATION_PATH                                 |
STk                    STK_IMPLEMENTATION_PATH
Vscm                   VSCM_IMPLEMENTATION_PATH

8.1.5 Loading SLIB Initialization File                                        |
--------------------------------------

If you use the `slib' script to start your SLIB session, then this step       |
is unnecessary.                                                               |
                                                                              |
  Check the manifest in `README' to find a configuration file for your
Scheme implementation.  Initialization files for most IEEE P1178
compliant Scheme Implementations are included with this distribution.

  You should check the definitions of `software-type',
`scheme-implementation-version', `implementation-vicinity', and
`library-vicinity' in the initialization file.  There are comments in
the file for how to configure it.

  Once this is done, modify the startup file for your Scheme
implementation to `load' this initialization file.

8.1.6 Build New SLIB Catalog for the Implementation                           |
---------------------------------------------------                           |

When SLIB is first used from an implementation, a file named `slibcat'
is written to the `implementation-vicinity' for that implementation.
Because users may lack permission to write in
`implementation-vicinity', it is good practice to build the new catalog
when installing SLIB.

  To build (or rebuild) the catalog, start the Scheme implementation
(with SLIB), then:

     (require 'new-catalog)

  The catalog also supports color-name dictionaries.  With an
SLIB-installed scheme implementation, type:
     (require 'color-names)
     (make-slib-color-name-db)
     (require 'new-catalog)
     (slib:exit)

8.1.7 Implementation-specific Instructions                                    |
------------------------------------------

Multiple implementations of Scheme can all use the same SLIB directory.
Simply configure each implementation's initialization file as outlined
above.

 -- Implementation: SCM
     The SCM implementation does not require any initialization file as
     SLIB support is already built into SCM.  See the documentation
     with SCM for installation instructions.

 -- Implementation: Larceny
     Starting with version 0.96, Larceny contains its own SLIB
     initialization file, loaded by `(require 'srfi-96)'.  If
     SCHEME_LIBRARY_PATH is not set, then Larceny looks for an `slib'
     subdirectory of a directory in the list returned by
     `(current-require-path)'

          larceny -- -e "(require 'srfi-96)"

 -- Implementation: Gauche-0.9                                                |
     Gauche also supports SLIB.  It finds SLIB at installation time;          |
     `(use slib)' to enable.                                                  |
                                                                              |
          gosh -u slib                                                        |
                                                                              |
 -- Implementation: ELK
          elk -i -l ${SCHEME_LIBRARY_PATH}elk.init

 -- Implementation: PLT Scheme
 -- Implementation: DrScheme
 -- Implementation: MzScheme
     The `init.ss' file in the _slibinit_ collection is an SLIB
     initialization file.  To run SLIB in MzScheme:

          mzscheme -f ${SCHEME_LIBRARY_PATH}mzscheme.init

 -- Implementation: MIT Scheme
          scheme -load ${SCHEME_LIBRARY_PATH}mitscheme.init

 -- Implementation: Gambit-C 3.0
          gsi -:s ${SCHEME_LIBRARY_PATH}gambit.init -

 -- Implementation: SISC
          sisc -e "(load \"${SCHEME_LIBRARY_PATH}sisc.init\")" --

 -- Implementation: Kawa
          kawa -f ${SCHEME_LIBRARY_PATH}kawa.init --

 -- Implementation: Guile
     Guile versions 1.6 and earlier link to an archaic SLIB version.  In
     RedHat or Fedora installations:

          rm /usr/share/guile/slib
          ln -s ${SCHEME_LIBRARY_PATH} /usr/share/guile/slib

     In Debian installations:

          rm /usr/share/guile/1.6/slib
          ln -s ${SCHEME_LIBRARY_PATH} /usr/share/guile/1.6/slib

     `${SCHEME_LIBRARY_PATH}' is where SLIB gets installed.

     Guile before version 1.8 with SLIB can then be started thus:             |

          guile -l ${SCHEME_LIBRARY_PATH}guile.init

     Guile version 1.8 and after with SLIB can then be started thus:          |
                                                                              |
          guile -l ${SCHEME_LIBRARY_PATH}guile.init \                         |
                -l ${SCHEME_LIBRARY_PATH}guile.use                            |
                                                                              |
     The Guile manual has a different way of installing SLIB:                 |
                                                                              |
`http://www.gnu.org/software/guile/manual/html_node/SLIB-installation.html'   |
                                                                              |
                                                                              |
                                                                              |
 -- Implementation: Scheme48
     To make a Scheme48 image for an installation under `<prefix>',

       1. `cd' to the SLIB directory

       2. type `make prefix=<prefix> slib48'.

       3. To install the image, type `make prefix=<prefix> install48'.
          This will also create a shell script with the name `slib48'
          which will invoke the saved image.

 -- Implementation: VSCM
     From: Matthias Blume <blume @ cs.Princeton.EDU>
     Date: Tue, 1 Mar 1994 11:42:31 -0500

     Disclaimer: The code below is only a quick hack.  If I find some
     time to spare I might get around to make some more things work.

     You have to provide `vscm.init' as an explicit command line
     argument.  Since this is not very nice I would recommend the
     following installation procedure:

       1. run scheme

       2. `(load "vscm.init")'

       3. `(slib:dump "dumpfile")'

       4. mv dumpfile place-where-vscm-standard-bootfile-resides.  For
          example:

          `mv dumpfile /usr/local/vscm/lib/scheme-boot'

          In this case vscm should have been compiled with flag:

          -DDEFAULT_BOOTFILE='"/usr/local/vscm/lib/scheme-boot"'

          See Makefile (definition of DDP) for details.

 -- Implementation: S7                                                        |
     S7 is not a standalone implementation, but runs as the extension         |
     language for the Snd sound editor.                                       |
     `${SCHEME_LIBRARY_PATH}s7.init' can be loaded from the Snd init          |
     file or on the Snd command line thus:                                    |
                                                                              |
          snd -l ${SCHEME_LIBRARY_PATH}s7.init                                |
                                                                              |

File: slib-3b5.info,  Node: The SLIB script,  Next: Porting,  Prev: Installation,  Up: About SLIB
                                                                              |
8.2 The SLIB script
===================

SLIB comes with shell script for Unix platforms.

      slib  [ scheme | scm | gsi | mzscheme | guile
            | scheme48 | scmlit | elk | sisc | kawa ]

Starts an interactive Scheme-with-SLIB session.

The optional argument to the `slib' script is the Scheme implementation
to run.  Absent the argument, it searches for implementations in the
above order.


File: slib-3b5.info,  Node: Porting,  Next: Compiled and Implementation-Specific Features,  Prev: The SLIB script,  Up: About SLIB
                                                                              |
8.3 Porting
===========

If there is no initialization file for your Scheme implementation, you
will have to create one.  Your Scheme implementation must be largely
compliant with
     `IEEE Std 1178-1990',
     `Revised^4 Report on the Algorithmic Language Scheme', or
     `Revised^5 Report on the Algorithmic Language Scheme'
  in order to support SLIB.  (1)

`http://cvs.savannah.gnu.org/viewcvs/*checkout*/scm/scm/r4rstest.scm'
is a file which checks compliance with much of R4RS.

  `Template.scm' is an example configuration file.  The comments inside
will direct you on how to customize it to reflect your system.  Give
your new initialization file the implementation's name with `.init'
appended.  For instance, if you were porting `foo-scheme' then the
initialization file might be called `foo.init'.

  Your customized version should then be loaded as part of your scheme
implementation's initialization.  It will load `require.scm' from the
library; this will allow the use of `provide', `provided?', and
`require' along with the "vicinity" functions (these functions are
documented in the sections *note Feature:: and *note Require::).  The
rest of the library will then be accessible in a system independent
fashion.

  Please mail new working configuration files to `agj@alum.mit.edu' so        |
that they can be included in the SLIB distribution.                           |

  ---------- Footnotes ----------

  (1) If you are porting a `Revised^3 Report on the Algorithmic
Language Scheme' implementation, then you will need to finish writing
`sc4sc3.scm' and `load' it from your initialization file.


File: slib-3b5.info,  Node: Compiled and Implementation-Specific Features,  Next: Coding Guidelines,  Prev: Porting,  Up: About SLIB
                                                                              |
8.4 Compiled and Implementation-Specific Features
=================================================

Often an implementation can implement an SLIB feature more efficiently
than the R4RS-compliant source code in SLIB.  Alternatively,
implementations with compilers can compile SLIB source code into binary
files which run faster than loading source code.

  Additionally, the SLIB catalog can be augmented with extra-SLIB
features which can be loaded by the implementation.  The catalog format
is described in *Note Library Catalogs::.

  These implementation-specific modifications are made when a new
catalog is created (*note Catalog Creation::).  If `mkimpcat.scm' in
`implementation-invicinity' exists, it is loaded.  That should produce
the file `implcat' in `implementation-invicinity', whose associations
will override those of SLIB.  `implcat' is copied into `slibcat' in
`implementation-vicinity' as part of the catalog creation process;
modifications to `implcat' after that will have no effect.


File: slib-3b5.info,  Node: Coding Guidelines,  Next: Copyrights,  Prev: Compiled and Implementation-Specific Features,  Up: About SLIB
                                                                              |
8.5 Coding Guidelines
=====================

All library packages are written in IEEE P1178 Scheme and assume that a
configuration file and `require.scm' package have already been loaded.
Other versions of Scheme can be supported in library packages as well
by using, for example, `(provided? 'r3rs)' or `(require 'r3rs)' (*note
Require::).  

  If a procedure defined in a module is called by other procedures in
that module, then those procedures should instead call an alias defined
in that module:

     (define module-name:foo foo)

  The module name and `:' should prefix that symbol for the internal
name.  Do not export internal aliases.

  A procedure is exported from a module by putting Schmooz-style
comments (*note Schmooz::) or `;@' at the beginning of the line
immediately preceding the definition (`define', `define-syntax', or
`defmacro').  Modules, exports and other relevant issues are discussed
in *note Compiling Scheme::.

  Code submitted for inclusion in SLIB should not duplicate (more than
one) routines already in SLIB files.  Use `require' to force those
library routines to be used by your package.

  Documentation should be provided in Emacs Texinfo format if possible,
but documentation must be provided.

  Your package will be released sooner with SLIB if you send me a file
which tests your code.  Please run this test _before_ you send me the
code!

8.5.1 Modifications
-------------------

Please document your changes.  A line or two for `ChangeLog' is
sufficient for simple fixes or extensions.  Look at the format of
`ChangeLog' to see what information is desired.  Please send me `diff'
files from the latest SLIB distribution (remember to send `diff's of
`slib.texi' and `ChangeLog').  This makes for less email traffic and
makes it easier for me to integrate when more than one person is
changing a file (this happens a lot with `slib.texi' and `*.init'
files).

  If someone else wrote a package you want to significantly modify,
please try to contact the author, who may be working on a new version.
This will insure against wasting effort on obsolete versions.

  Please _do not_ reformat the source code with your favorite
beautifier, make 10 fixes, and send me the resulting source code.  I do
not have the time to fish through 10000 diffs to find your 10 real
fixes.


File: slib-3b5.info,  Node: Copyrights,  Next: About this manual,  Prev: Coding Guidelines,  Up: About SLIB
                                                                              |
8.6 Copyrights
==============

This section has instructions for SLIB authors regarding copyrights.  

  Each package in SLIB must either be in the public domain, or come
with a statement of terms permitting users to copy, redistribute and
modify it.  The comments at the beginning of `require.scm' and
`macwork.scm' illustrate copyright and appropriate terms.

  If your code or changes amount to less than about 10 lines, you do not
need to add your copyright or send a disclaimer.

8.6.1 Putting code into the Public Domain
-----------------------------------------

In order to put code in the public domain you should sign a copyright
disclaimer and send it to the SLIB maintainer.  Contact                       |
agj@alum.mit.edu for the address to mail the disclaimer to.                   |

     I, <MY-NAME>, hereby affirm that I have placed the software
     package <NAME> in the public domain.

     I affirm that I am the sole author and sole copyright holder for
     the software package, that I have the right to place this software
     package in the public domain, and that I will do nothing to
     undermine this status in the future.
                                                     SIGNATURE AND DATE

  This wording assumes that you are the sole author.  If you are not the
sole author, the wording needs to be different.  If you don't want to
be bothered with sending a letter every time you release or modify a
module, make your letter say that it also applies to your future
revisions of that module.

  Make sure no employer has any claim to the copyright on the work you
are submitting.  If there is any doubt, create a copyright disclaimer
and have your employer sign it.  Mail the signed disclaimer to the SLIB
maintainer.  Contact agj@alum.mit.edu for the address to mail the
disclaimer to.  An example disclaimer follows.

8.6.2 Explicit copying terms
----------------------------

If you submit more than about 10 lines of code which you are not
placing into the Public Domain (by sending me a disclaimer) you need to:

   * Arrange that your name appears in a copyright line for the
     appropriate year.  Multiple copyright lines are acceptable.

   * With your copyright line, specify any terms you require to be
     different from those already in the file.

   * Make sure no employer has any claim to the copyright on the work
     you are submitting.  If there is any doubt, create a copyright
     disclaimer and have your employer sign it.  Mail the signed
     disclaim to the SLIB maintainer.  Contact agj@alum.mit.edu for the       |
     address to mail the disclaimer to.                                       |

8.6.3 Example: Company Copyright Disclaimer
-------------------------------------------

This disclaimer should be signed by a vice president or general manager
of the company.  If you can't get at them, anyone else authorized to
license out software produced there will do.  Here is a sample wording:

     <EMPLOYER> Corporation hereby disclaims all copyright interest in
     the program <PROGRAM> written by <NAME>.

     <EMPLOYER> Corporation affirms that it has no other intellectual
     property interest that would undermine this release, and will do
     nothing to undermine it in the future.

     <SIGNATURE AND DATE>,
     <NAME>, <TITLE>, <EMPLOYER> Corporation


File: slib-3b5.info,  Node: About this manual,  Prev: Copyrights,  Up: About SLIB
                                                                              |
8.7 About this manual
=====================

   * Entries that are labeled as Functions are called for their return
     values.  Entries that are labeled as Procedures are called
     primarily for their side effects.

   * Examples in this text were produced using the `scm' Scheme
     implementation.

   * At the beginning of each section, there is a line that looks like: 
          (require 'feature)
     Include this line in your code prior to using the package.

* Menu:

* GNU Free Documentation License::


File: slib-3b5.info,  Node: GNU Free Documentation License,  Prev: About this manual,  Up: About this manual
                                                                              |
8.7.1 GNU Free Documentation License
------------------------------------

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, receipt of a copy of some or all of
     the same material does not give you any rights to use it.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.  If the Document specifies that a proxy
     can decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

 11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

  If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

  If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

  If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: slib-3b5.info,  Node: Index,  Prev: About SLIB,  Up: Top
                                                                              |
Index
*****

Procedure and Macro Index
*************************

 [index ]
* Menu:

* -:                                     Multi-argument / and -.
                                                              (line  14)
* -1+:                                   Rev2 Procedures.     (line  42)
* /:                                     Multi-argument / and -.
                                                              (line  12)
* 1+:                                    Rev2 Procedures.     (line  39)
* <=?:                                   Rev2 Procedures.     (line  46)
* <?:                                    Rev2 Procedures.     (line  45)
* =:                                     Hilbert Space-Filling Curve.
                                                              (line  73)      |
* =?:                                    Rev2 Procedures.     (line  47)
* >=?:                                   Rev2 Procedures.     (line  49)
* >?:                                    Rev2 Procedures.     (line  48)
* A:bool:                                Arrays.              (line 236)
* A:fixN16b:                             Arrays.              (line 226)
* A:fixN32b:                             Arrays.              (line 221)
* A:fixN64b:                             Arrays.              (line 216)
* A:fixN8b:                              Arrays.              (line 231)
* A:fixZ16b:                             Arrays.              (line 206)
* A:fixZ32b:                             Arrays.              (line 201)
* A:fixZ64b:                             Arrays.              (line 196)
* A:fixZ8b:                              Arrays.              (line 211)
* A:floC128b:                            Arrays.              (line 149)
* A:floC16b:                             Arrays.              (line 161)
* A:floC32b:                             Arrays.              (line 157)
* A:floC64b:                             Arrays.              (line 153)
* A:floR128b:                            Arrays.              (line 165)
* A:floR128d:                            Arrays.              (line 181)
* A:floR16b:                             Arrays.              (line 177)
* A:floR32b:                             Arrays.              (line 173)
* A:floR32d:                             Arrays.              (line 191)
* A:floR64b:                             Arrays.              (line 169)
* A:floR64d:                             Arrays.              (line 186)
* abort:                                 Session Support.     (line   9)
* abs:                                   Irrational Real Functions.
                                                              (line  86)
* absolute-path?:                        URI.                 (line 102)
* absolute-uri?:                         URI.                 (line  98)
* add-command-tables:                    Database Extension.  (line  11)
* add-domain:                            Using Databases.     (line 132)
* add-domain on relational-database:     Command Intrinsics.  (line  10)
* add-macro-support:                     Within-database.     (line  52)
* add-process!:                          Multi-Processing.    (line  14)
* add-setter:                            Setters.             (line  43)
* adjoin:                                Lists as sets.       (line  10)
* adjoin-parameters!:                    Parameter lists.     (line  38)
* alist->wt-tree:                        Construction of Weight-Balanced Trees.
                                                              (line  65)
* alist-associator:                      Association Lists.   (line  28)
* alist-cons:                            SRFI-1.              (line 177)
* alist-copy:                            SRFI-1.              (line 179)
* alist-delete:                          SRFI-1.              (line 181)
* alist-delete!:                         SRFI-1.              (line 184)
* alist-for-each:                        Association Lists.   (line  53)
* alist-inquirer:                        Association Lists.   (line  23)
* alist-map:                             Association Lists.   (line  48)
* alist-remover:                         Association Lists.   (line  39)
* alist-table:                           The Base.            (line  12)
* and-let*:                              Guarded LET* special form.
                                                              (line   9)
* and?:                                  Non-List functions.  (line   7)
* any:                                   SRFI-1.              (line 155)
* any-bits-set?:                         Bit-Twiddling.       (line  64)
* any?:                                  Collections.         (line  84)
* append!:                               Rev2 Procedures.     (line  36)
* append-reverse:                        SRFI-1.              (line  95)
* append-reverse!:                       SRFI-1.              (line  96)
* apply:                                 Multi-argument Apply.
                                                              (line  12)
* arithmetic-shift:                      Bit-Twiddling.       (line 192)
* array->list:                           Arrays.              (line 101)
* array->vector:                         Arrays.              (line 124)
* array-dimensions:                      Arrays.              (line  48)
* array-for-each:                        Array Mapping.       (line  25)
* array-in-bounds?:                      Arrays.              (line 133)
* array-index-for-each:                  Array Mapping.       (line  34)
* array-index-map!:                      Array Mapping.       (line  44)
* array-indexes:                         Array Mapping.       (line  29)
* array-map:                             Array Mapping.       (line  17)
* array-map!:                            Array Mapping.       (line   9)
* array-rank:                            Arrays.              (line  44)
* array-ref:                             Arrays.              (line 136)
* array-set!:                            Arrays.              (line 139)
* array-trim:                            Subarrays.           (line  47)
* array:copy!:                           Array Mapping.       (line  60)
* array?:                                Arrays.              (line   9)
* asctime:                               Posix Time.          (line  62)
* ash:                                   Bit-Twiddling.       (line 191)
* assoc:                                 SRFI-1.              (line 174)
* atan:                                  Irrational Real Functions.
                                                              (line  22)
* atom?:                                 Non-List functions.  (line  30)
* attlist-add:                           Parsing XML.         (line 452)
* attlist-remove-top:                    Parsing XML.         (line 457)
* batch:call-with-output-script:         Batch.               (line  47)
* batch:command:                         Batch.               (line  64)
* batch:comment:                         Batch.               (line  95)
* batch:delete-file:                     Batch.               (line 102)
* batch:initialize!:                     Batch.               (line  36)
* batch:lines->file:                     Batch.               (line  98)
* batch:rename-file:                     Batch.               (line 106)
* batch:run-script:                      Batch.               (line  88)
* batch:try-chopped-command:             Batch.               (line  76)
* batch:try-command:                     Batch.               (line  72)
* bit-field:                             Bit-Twiddling.       (line 166)
* bit-set?:                              Bit-Twiddling.       (line 145)
* bitwise-and:                           Bit-Twiddling.       (line  19)
* bitwise-bit-count:                     Bit-Twiddling.       (line  91)
* bitwise-if:                            Bit-Twiddling.       (line  56)
* bitwise-ior:                           Bit-Twiddling.       (line  28)
* bitwise-merge:                         Bit-Twiddling.       (line  57)
* bitwise-not:                           Bit-Twiddling.       (line  46)
* bitwise-xor:                           Bit-Twiddling.       (line  37)
* blackbody-spectrum:                    Spectra.             (line 128)
* booleans->integer:                     Bit-Twiddling.       (line 238)
* break <1>:                             Breakpoints.         (line  28)
* break:                                 SRFI-1.              (line 151)
* break!:                                SRFI-1.              (line 153)
* break-all:                             Debug.               (line  31)
* breakf:                                Breakpoints.         (line  47)
* breakpoint:                            Breakpoints.         (line  16)
* browse:                                Database Browser.    (line   9)
* browse-url:                            System.              (line  61)
* butlast:                               Lists as sequences.  (line 121)
* butnthcdr:                             Lists as sequences.  (line 147)
* byte-ref:                              Byte.                (line  14)
* byte-set!:                             Byte.                (line  18)
* bytes:                                 Byte.                (line  32)
* bytes->ieee-double:                    Byte/Number Conversions.
                                                              (line  61)
* bytes->ieee-float:                     Byte/Number Conversions.
                                                              (line  41)
* bytes->integer:                        Byte/Number Conversions.
                                                              (line  17)
* bytes->list:                           Byte.                (line  40)
* bytes->string:                         Byte.                (line  47)
* bytes-copy:                            Byte.                (line  57)
* bytes-length:                          Byte.                (line  29)
* bytes-reverse:                         Byte.                (line  73)
* bytes-reverse!:                        Byte.                (line  70)
* call-with-dynamic-binding:             Dynamic Data Type.   (line  25)
* call-with-input-string:                String Ports.        (line  15)
* call-with-open-ports:                  Input/Output.        (line  54)
* call-with-output-string:               String Ports.        (line   9)
* call-with-tmpnam:                      Filenames.           (line  74)
* call-with-values:                      Values.              (line  13)
* capture-syntactic-environment:         Syntactic Closures.  (line 212)
* car+cdr:                               SRFI-1.              (line  68)
* cart-prod-tables on relational-database: Database Operations.
                                                              (line  77)
* catalog->html:                         HTML Tables.         (line  49)
* catalog-id on base-table:              Base Tables.         (line  30)
* catalog:read:                          Catalog Vicinities.  (line  57)
* cdna:base-count:                       NCBI-DNA.            (line  37)
* cdna:report-base-count:                NCBI-DNA.            (line  41)
* cgi:serve-query:                       HTTP and CGI.        (line  72)
* chap:next-string:                      Chapter Ordering.    (line  29)
* chap:string<=?:                        Chapter Ordering.    (line  25)
* chap:string<?:                         Chapter Ordering.    (line  14)
* chap:string>=?:                        Chapter Ordering.    (line  26)
* chap:string>?:                         Chapter Ordering.    (line  24)
* check-parameters:                      Parameter lists.     (line  59)
* chromaticity->CIEXYZ:                  Spectra.             (line 172)
* chromaticity->whitepoint:              Spectra.             (line 175)
* CIE:DE*:                               Color Difference Metrics.
                                                              (line  20)
* CIE:DE*94:                             Color Difference Metrics.
                                                              (line  27)
* ciexyz->color:                         Color Spaces.        (line  25)
* CIEXYZ->e-sRGB:                        Color Conversions.   (line  56)
* CIEXYZ->L*a*b*:                        Color Conversions.   (line  38)
* CIEXYZ->L*u*v*:                        Color Conversions.   (line  32)
* CIEXYZ->RGB709:                        Color Conversions.   (line  29)
* CIEXYZ->sRGB:                          Color Conversions.   (line  47)
* CIEXYZ->xRGB:                          Color Conversions.   (line  50)
* circular-list:                         SRFI-1.              (line  32)
* circular-list?:                        SRFI-1.              (line  40)
* cksum:                                 Cyclic Checksum.     (line 150)
* clear-sky-color-xyy:                   Daylight.            (line  84)
* clip-to-rect:                          Rectangles.          (line  36)
* close-base on base-table:              The Base.            (line  60)
* close-database:                        Using Databases.     (line  90)
* close-database on relational-database: Database Operations. (line  20)
* close-port:                            Input/Output.        (line  47)
* close-table on relational-table:       Table Administration.
                                                              (line  20)
* CMC-DE:                                Color Difference Metrics.
                                                              (line  63)      |
* CMC:DE*:                               Color Difference Metrics.
                                                              (line  67)      |
* codons<-cdna:                          NCBI-DNA.            (line  20)
* coerce:                                Type Coercion.       (line  12)
* collection?:                           Collections.         (line  36)
* color->ciexyz:                         Color Spaces.        (line  34)
* color->e-srgb:                         Color Spaces.        (line 260)
* color->l*a*b*:                         Color Spaces.        (line  92)
* color->l*c*h:                          Color Spaces.        (line 171)
* color->l*u*v*:                         Color Spaces.        (line 118)
* color->rgb709:                         Color Spaces.        (line  55)
* color->srgb:                           Color Spaces.        (line 215)
* color->string:                         Color Data-Type.     (line  95)
* color->xrgb:                           Color Spaces.        (line 218)
* color-dictionaries->lookup:            Color Names.         (line  33)
* color-dictionary:                      Color Names.         (line  40)
* color-name->color:                     Color Names.         (line  27)
* color-name:canonicalize:               Color Names.         (line  23)
* color-precision:                       Color Data-Type.     (line  46)
* color-space:                           Color Data-Type.     (line  43)
* color-white-point:                     Color Data-Type.     (line  51)
* color:ciexyz:                          Color Spaces.        (line  30)
* color:e-srgb:                          Color Spaces.        (line 247)
* color:l*a*b*:                          Color Spaces.        (line  83)
* color:l*c*h:                           Color Spaces.        (line 163)
* color:l*u*v*:                          Color Spaces.        (line 109)
* color:linear-transform:                Color Conversions.   (line  27)
* color:rgb709:                          Color Spaces.        (line  51)
* color:srgb:                            Color Spaces.        (line 206)
* color?:                                Color Data-Type.     (line   9)
* column-domains on relational-table:    Table Administration.
                                                              (line   9)
* column-foreigns on relational-table:   Table Administration.
                                                              (line   8)
* column-names on relational-table:      Table Administration.
                                                              (line   7)
* column-range:                          Column Ranges.       (line  10)
* column-types on relational-table:      Table Administration.
                                                              (line  10)
* combine-ranges:                        Column Ranges.       (line  19)
* combined-rulesets:                     Commutative Rings.   (line  90)
* command->p-specs:                      HTML.                (line 149)
* command:make-editable-table:           HTML Tables.         (line  98)
* command:modify-table:                  HTML Tables.         (line  87)
* concatenate:                           SRFI-1.              (line  90)
* concatenate!:                          SRFI-1.              (line  91)
* cond:                                  Guarded COND Clause. (line  11)
* cond-expand:                           SRFI.                (line  12)
* cons*:                                 SRFI-1.              (line  22)
* continue:                              Breakpoints.         (line  20)
* convert-color:                         Color Data-Type.     (line  54)
* coordinates->integer:                  Multidimensional Space-Filling Curves.
                                                              (line  52)      |
* copy-bit:                              Bit-Twiddling.       (line 154)
* copy-bit-field:                        Bit-Twiddling.       (line 177)
* copy-list:                             List construction.   (line  32)
* copy-random-state:                     Exact Random Numbers.
                                                              (line  29)
* copy-tree:                             Tree Operations.     (line  33)
* count:                                 SRFI-1.              (line 106)
* count-newlines:                        String Search.       (line  61)
* crc16:                                 Cyclic Checksum.     (line 168)
* crc5:                                  Cyclic Checksum.     (line 179)
* crc:make-table:                        Cyclic Checksum.     (line 132)
* create-array:                          Arrays.              (line  66)
* create-database:                       Using Databases.     (line  43)
* create-database on relational-system:  Relational Database Objects.
                                                              (line  34)
* create-postscript-graph:               PostScript Graphing. (line  17)
* create-table on relational-database:   Database Operations. (line  63)
* create-view on relational-database:    Database Operations. (line  74)
* cring:define-rule:                     Commutative Rings.   (line 116)
* ctime:                                 Posix Time.          (line  68)
* current-directory:                     Directories.         (line   9)
* current-error-port:                    Input/Output.        (line  70)
* current-input-port <1>:                Byte.                (line  94)
* current-input-port:                    Ruleset Definition and Use.
                                                              (line  61)
* current-output-port:                   Byte.                (line  86)
* current-time:                          Time and Date.       (line  20)
* cvs-directories:                       CVS.                 (line  14)
* cvs-files:                             CVS.                 (line   9)
* cvs-repository:                        CVS.                 (line  22)
* cvs-root:                              CVS.                 (line  18)
* cvs-set-root!:                         CVS.                 (line  27)
* cvs-set-roots!:                        CVS.                 (line  30)
* cvs-vet:                               CVS.                 (line  34)
* db->html-directory:                    HTML Tables.         (line 147)
* db->html-files:                        HTML Tables.         (line 137)
* db->netscape:                          HTML Tables.         (line 158)
* decode-universal-time:                 Common-Lisp Time.    (line  15)
* define-*commands*:                     Database Extension.  (line  16)
* define-access-operation:               Setters.             (line  53)
* define-command:                        Within-database.     (line  17)
* define-domains:                        Using Databases.     (line 125)
* define-macro:                          Within-database.     (line  58)
* define-operation:                      Yasos interface.     (line   7)
* define-predicate:                      Yasos interface.     (line  12)
* define-record-type:                    Define-Record-Type.  (line  12)
* define-structure:                      Define-Structure.    (line  12)
* define-syntax:                         Macro by Example.    (line  39)
* define-table:                          Within-database.     (line  26)
* define-tables:                         Using Databases.     (line 135)
* defmacro:                              Defmacro.            (line  41)
* defmacro:eval:                         Defmacro.            (line  15)
* defmacro:expand*:                      Defmacro.            (line  52)
* defmacro:load:                         Defmacro.            (line  19)
* defmacro?:                             Defmacro.            (line  28)
* delaminate-list:                       Hilbert Space-Filling Curve.
                                                              (line  90)      |
* delay:                                 Promises.            (line  15)
* delete:                                Destructive list operations.
                                                              (line  58)
* delete on base-table:                  Base Record Operations.
                                                              (line  37)
* delete* on base-table:                 Aggregate Base Operations.
                                                              (line  11)
* delete-domain on relational-database:  Command Intrinsics.  (line  39)
* delete-duplicates:                     SRFI-1.              (line 165)
* delete-duplicates!:                    SRFI-1.              (line 168)
* delete-file:                           Input/Output.        (line  14)
* delete-if:                             Destructive list operations.
                                                              (line  59)
* delete-if-not:                         Destructive list operations.
                                                              (line  60)
* delete-table on relational-database:   Database Operations. (line  58)
* dequeue!:                              Queues.              (line  28)
* dequeue-all!:                          Queues.              (line  36)
* describe-file-lock:                    Transactions.        (line  70)
* determinant:                           Matrix Algebra.      (line  18)
* dft:                                   Discrete Fourier Transform.
                                                              (line  44)
* dft-1:                                 Discrete Fourier Transform.
                                                              (line  49)
* diff:edit-length:                      Sequence Comparison. (line  64)
* diff:edits:                            Sequence Comparison. (line  45)
* diff:longest-common-subsequence:       Sequence Comparison. (line  32)
* difftime:                              Time and Date.       (line  26)
* directory*-for-each:                   Directories.         (line  45)
* directory-for-each:                    Directories.         (line  21)
* do-elts:                               Collections.         (line  41)
* do-keys:                               Collections.         (line  57)
* domain-checker on relational-database: Command Intrinsics.  (line  42)
* dotted-list?:                          SRFI-1.              (line  42)
* drop:                                  SRFI-1.              (line  70)
* drop-right:                            SRFI-1.              (line  76)
* drop-right!:                           SRFI-1.              (line  78)
* dynamic-ref:                           Dynamic Data Type.   (line  17)
* dynamic-set!:                          Dynamic Data Type.   (line  21)
* dynamic-wind:                          Dynamic-Wind.        (line  13)
* dynamic?:                              Dynamic Data Type.   (line  12)
* e-sRGB->CIEXYZ:                        Color Conversions.   (line  57)
* e-srgb->color:                         Color Spaces.        (line 241)
* e-sRGB->e-sRGB:                        Color Conversions.   (line  68)
* e-sRGB->sRGB:                          Color Conversions.   (line  60)
* eighth:                                SRFI-1.              (line  64)
* emacs:backup-name:                     Transactions.        (line  85)
* empty?:                                Collections.         (line 100)
* encode-universal-time:                 Common-Lisp Time.    (line  40)
* enqueue!:                              Queues.              (line  25)
* equal? <1>:                            Byte.                (line  44)
* equal?:                                Arrays.              (line  19)
* eval:                                  Eval.                (line   9)
* every:                                 Lists as sets.       (line  91)
* every?:                                Collections.         (line  92)
* exports<-info-index:                   Top-level Variable References.
                                                              (line  35)
* extended-euclid:                       Modular Arithmetic.  (line   9)
* factor:                                Prime Numbers.       (line  41)
* feature->export-alist:                 Module Manifests.    (line 100)
* feature->exports:                      Module Manifests.    (line 105)
* feature->requires:                     Module Manifests.    (line  29)
* feature->requires*:                    Module Manifests.    (line  45)
* feature-eval:                          Feature.             (line  52)
* fft:                                   Discrete Fourier Transform.
                                                              (line  27)
* fft-1:                                 Discrete Fourier Transform.
                                                              (line  34)
* fifth:                                 SRFI-1.              (line  61)
* file->color-dictionary:                Color Names.         (line  69)
* file->definitions:                     Module Manifests.    (line  72)
* file->exports:                         Module Manifests.    (line  84)
* file->loads:                           Module Manifests.    (line  53)
* file->requires:                        Module Manifests.    (line  15)
* file->requires*:                       Module Manifests.    (line  49)
* file-exists?:                          Input/Output.        (line   9)
* file-lock!:                            Transactions.        (line  52)
* file-lock-owner:                       Transactions.        (line  48)
* file-position:                         Input/Output.        (line  81)
* file-unlock!:                          Transactions.        (line  62)
* filename:match-ci??:                   Filenames.           (line  10)
* filename:match??:                      Filenames.           (line   9)
* filename:substitute-ci??:              Filenames.           (line  35)
* filename:substitute??:                 Filenames.           (line  34)
* fill-empty-parameters:                 Parameter lists.     (line  51)
* fill-rect:                             Rectangles.          (line  30)
* filter:                                SRFI-1.              (line 128)
* filter!:                               SRFI-1.              (line 130)
* find:                                  SRFI-1.              (line 143)
* find-if:                               Lists as sets.       (line 138)
* find-ratio:                            Rationalize.         (line  20)
* find-ratio-between:                    Rationalize.         (line  27)
* find-string-from-port?:                String Search.       (line  30)
* find-tail:                             SRFI-1.              (line 145)
* first:                                 SRFI-1.              (line  53)
* first-set-bit:                         Bit-Twiddling.       (line 110)
* fluid-let:                             Fluid-Let.           (line  13)
* fold:                                  SRFI-1.              (line 111)
* fold-right:                            SRFI-1.              (line 113)
* for-each-elt:                          Collections.         (line  67)
* for-each-key:                          Collections.         (line  66)
* for-each-key on base-table:            Aggregate Base Operations.
                                                              (line  16)
* for-each-row on relational-table:      Multi-Row Operations.
                                                              (line  33)
* for-each-row-in-order on relational-table: Sequential Index Operations.
                                                              (line  11)
* force:                                 Promises.            (line  11)
* force-output:                          Input/Output.        (line  74)
* form:delimited:                        HTML.                (line 138)
* form:element:                          HTML.                (line  98)
* form:image:                            HTML.                (line  92)
* form:reset:                            HTML.                (line  95)
* form:submit:                           HTML.                (line  84)
* format:                                Format Interface.    (line   7)
* fourth:                                SRFI-1.              (line  59)
* fprintf:                               Standard Formatted Output.
                                                              (line  10)
* fscanf:                                Standard Formatted Input.
                                                              (line  14)
* gen-elts:                              Collections.         (line  25)
* gen-keys:                              Collections.         (line  29)
* generic-write:                         Generic-Write.       (line  15)
* gentemp:                               Defmacro.            (line   9)
* get on relational-table:               Table Operations.    (line  18)
* get* on relational-table:              Match-Keys.          (line  29)
* get-decoded-time:                      Common-Lisp Time.    (line   7)
* get-foreign-choices:                   HTML.                (line 146)
* get-method:                            Object.              (line  78)
* get-universal-time:                    Common-Lisp Time.    (line  10)
* getenv:                                System Interface.    (line   9)
* getopt:                                Getopt.              (line  39)
* getopt--:                              Getopt.              (line 125)
* getopt->arglist:                       Getopt Parameter lists.
                                                              (line  37)
* getopt->parameter-list:                Getopt Parameter lists.
                                                              (line  10)
* glob-pattern?:                         URI.                 (line 110)
* gmktime:                               Posix Time.          (line  50)
* gmtime:                                Posix Time.          (line  36)
* golden-section-search:                 Minimizing.          (line  18)
* gray-code->integer:                    Hilbert Space-Filling Curve.
                                                              (line  66)      |
* gray-code<=?:                          Hilbert Space-Filling Curve.
                                                              (line  76)      |
* gray-code<?:                           Hilbert Space-Filling Curve.
                                                              (line  74)      |
* gray-code>=?:                          Hilbert Space-Filling Curve.
                                                              (line  77)      |
* gray-code>?:                           Hilbert Space-Filling Curve.
                                                              (line  75)      |
* grey:                                  Color Names.         (line  13)
* grid-horizontals:                      Legending.           (line  58)
* grid-verticals:                        Legending.           (line  54)
* gtime:                                 Posix Time.          (line  67)
* has-duplicates?:                       Lists as sets.       (line 187)
* hash:                                  Hashing.             (line  14)
* hash-associator:                       Hash Tables.         (line  36)
* hash-for-each:                         Hash Tables.         (line  51)
* hash-inquirer:                         Hash Tables.         (line  31)
* hash-map:                              Hash Tables.         (line  46)
* hash-rehasher:                         Hash Tables.         (line  56)
* hash-remover:                          Hash Tables.         (line  41)
* hashq:                                 Hashing.             (line  12)
* hashv:                                 Hashing.             (line  13)
* heap-extract-max!:                     Priority Queues.     (line  23)
* heap-insert!:                          Priority Queues.     (line  19)
* heap-length:                           Priority Queues.     (line  16)
* hilbert-coordinates->integer:          Hilbert Space-Filling Curve.
                                                              (line  46)      |
* histograph:                            Character Plotting.  (line  83)
* home-vicinity:                         Vicinity.            (line  51)
* htm-fields:                            Parsing HTML.        (line  58)
* html-for-each:                         Parsing HTML.        (line  10)
* html:anchor:                           URI.                 (line  24)
* html:atval:                            HTML.                (line   9)
* html:base:                             URI.                 (line  39)
* html:body:                             HTML.                (line  47)
* html:buttons:                          HTML.                (line  81)
* html:caption:                          HTML Tables.         (line  11)
* html:checkbox:                         HTML.                (line  69)
* html:comment:                          HTML.                (line  55)
* html:delimited-list:                   HTML.                (line 143)
* html:editable-row-converter:           HTML Tables.         (line 117)
* html:form:                             HTML.                (line  61)
* html:head:                             HTML.                (line  39)
* html:heading:                          HTML Tables.         (line  15)
* html:hidden:                           HTML.                (line  66)
* html:href-heading:                     HTML Tables.         (line  18)
* html:http-equiv:                       HTML.                (line  24)
* html:isindex:                          URI.                 (line  43)
* html:link:                             URI.                 (line  32)
* html:linked-row-converter:             HTML Tables.         (line  22)
* html:meta:                             HTML.                (line  17)
* html:meta-refresh:                     HTML.                (line  30)
* html:plain:                            HTML.                (line  13)
* html:pre:                              HTML.                (line  50)
* html:read-title:                       Parsing HTML.        (line  44)
* html:select:                           HTML.                (line  78)
* html:table:                            HTML Tables.         (line   9)
* html:text:                             HTML.                (line  72)
* html:text-area:                        HTML.                (line  75)
* http:content:                          HTTP and CGI.        (line  13)
* http:error-page:                       HTTP and CGI.        (line  20)
* http:forwarding-page:                  HTTP and CGI.        (line  26)
* http:header:                           HTTP and CGI.        (line   9)
* http:serve-query:                      HTTP and CGI.        (line  36)
* identifier=?:                          Syntactic Closures.  (line 370)
* identifier?:                           Syntactic Closures.  (line 335)
* identity:                              Miscellany.          (line   9)
* ieee-byte-collate:                     Byte/Number Conversions.
                                                              (line 153)      |
* ieee-byte-collate!:                    Byte/Number Conversions.
                                                              (line 144)      |
* ieee-byte-decollate:                   Byte/Number Conversions.
                                                              (line 157)      |
* ieee-byte-decollate!:                  Byte/Number Conversions.
                                                              (line 149)      |
* ieee-double->bytes:                    Byte/Number Conversions.
                                                              (line  99)      |
* ieee-float->bytes:                     Byte/Number Conversions.
                                                              (line  81)      |
* illuminant-map:                        Spectra.             (line  80)
* illuminant-map->XYZ:                   Spectra.             (line  85)
* implementation-vicinity:               Vicinity.            (line  42)
* in-graphic-context:                    Graphics Context.    (line   7)
* in-vicinity:                           Vicinity.            (line  62)
* init-debug:                            Breakpoints.         (line   9)
* integer->bytes:                        Byte/Number Conversions.
                                                              (line  29)
* integer->coordinates:                  Multidimensional Space-Filling Curves.
                                                              (line  48)      |
* integer->gray-code:                    Hilbert Space-Filling Curve.
                                                              (line  63)      |
* integer->hilbert-coordinates:          Hilbert Space-Filling Curve.
                                                              (line  30)
* integer->list:                         Bit-Twiddling.       (line 225)
* integer->peano-coordinates:            Peano Space-Filling Curve.
                                                              (line  19)
* integer-byte-collate:                  Byte/Number Conversions.
                                                              (line 138)      |
* integer-byte-collate!:                 Byte/Number Conversions.
                                                              (line 132)      |
* integer-expt:                          Irrational Integer Functions.
                                                              (line   9)
* integer-length:                        Bit-Twiddling.       (line  98)
* integer-log:                           Irrational Integer Functions.
                                                              (line  18)
* integer-sqrt:                          Irrational Integer Functions.
                                                              (line  23)
* interaction-environment:               Eval.                (line  51)
* interpolate-array-ref:                 Array Interpolation. (line   9)
* interpolate-from-table:                Database Interpolation.
                                                              (line  13)
* intersection:                          Lists as sets.       (line  32)
* iota:                                  SRFI-1.              (line  26)
* isam-next on relational-table:         Sequential Index Operations.
                                                              (line  18)
* isam-prev on relational-table:         Sequential Index Operations.
                                                              (line  29)
* jacobi-symbol:                         Prime Numbers.       (line  20)
* kill-process!:                         Multi-Processing.    (line  24)
* kill-table on base-table:              Base Tables.         (line  26)
* L*a*b*->CIEXYZ:                        Color Conversions.   (line  40)
* l*a*b*->color:                         Color Spaces.        (line  78)
* L*a*b*->L*C*h:                         Color Conversions.   (line  44)
* L*a*b*:DE*:                            Color Difference Metrics.
                                                              (line  17)
* L*a*b*:DE*94:                          Color Difference Metrics.
                                                              (line  25)
* l*c*h->color:                          Color Spaces.        (line 158)
* L*C*h->L*a*b*:                         Color Conversions.   (line  45)
* L*u*v*->CIEXYZ:                        Color Conversions.   (line  34)
* l*u*v*->color:                         Color Spaces.        (line 104)
* laguerre:find-polynomial-root:         Root Finding.        (line  57)
* laguerre:find-root:                    Root Finding.        (line  46)
* last <1>:                              SRFI-1.              (line  83)
* last:                                  Lists as sequences.  (line 111)
* last-pair:                             Miscellany.          (line  64)
* length+:                               SRFI-1.              (line  88)
* let-values:                            Binding to multiple values.
                                                              (line  14)
* let-values*:                           Binding to multiple values.
                                                              (line  15)
* library-vicinity:                      Vicinity.            (line  39)
* light:ambient:                         Solid Modeling.      (line 110)
* light:beam:                            Solid Modeling.      (line 144)
* light:directional:                     Solid Modeling.      (line 122)
* light:point:                           Solid Modeling.      (line 158)
* light:spot:                            Solid Modeling.      (line 176)
* limit:                                 The Limit.           (line   7)
* list*:                                 List construction.   (line  18)
* list->array:                           Arrays.              (line  88)
* list->bytes:                           Byte.                (line  36)
* list->integer:                         Bit-Twiddling.       (line 231)
* list-copy:                             SRFI-1.              (line  24)
* list-index:                            SRFI-1.              (line 157)
* list-of??:                             Lists as sets.       (line 120)
* list-table-definition:                 Using Databases.     (line 168)
* list-tabulate:                         SRFI-1.              (line  18)
* list-tail:                             Rev4 Optional Procedures.
                                                              (line  12)
* list=:                                 SRFI-1.              (line  48)
* ln:                                    Irrational Real Functions.
                                                              (line  77)
* load->path:                            Module Manifests.    (line  63)
* load-ciexyz:                           Spectra.             (line  40)
* load-color-dictionary:                 Color Names.         (line  53)
* localtime:                             Posix Time.          (line  39)
* log2-binary-factors:                   Bit-Twiddling.       (line 109)
* logand:                                Bit-Twiddling.       (line  18)
* logbit?:                               Bit-Twiddling.       (line 144)
* logcount:                              Bit-Twiddling.       (line  73)
* logior:                                Bit-Twiddling.       (line  27)
* lognot:                                Bit-Twiddling.       (line  45)
* logtest:                               Bit-Twiddling.       (line  63)
* logxor:                                Bit-Twiddling.       (line  36)
* lset-adjoin:                           SRFI-1.              (line 196)
* lset-diff+intersection:                SRFI-1.              (line 206)
* lset-diff+intersection!:               SRFI-1.              (line 221)
* lset-difference:                       SRFI-1.              (line 202)
* lset-difference!:                      SRFI-1.              (line 215)
* lset-intersection:                     SRFI-1.              (line 200)
* lset-intersection!:                    SRFI-1.              (line 213)
* lset-union:                            SRFI-1.              (line 198)
* lset-union!:                           SRFI-1.              (line 217)
* lset-xor:                              SRFI-1.              (line 204)
* lset-xor!:                             SRFI-1.              (line 219)
* lset<=:                                SRFI-1.              (line 190)
* lset=:                                 SRFI-1.              (line 194)
* macro:eval <1>:                        Syntax-Case Macros.  (line  14)
* macro:eval <2>:                        Syntactic Closures.  (line  14)
* macro:eval <3>:                        Macros That Work.    (line  18)
* macro:eval:                            R4RS Macros.         (line  19)
* macro:expand <1>:                      Syntax-Case Macros.  (line   9)
* macro:expand <2>:                      Syntactic Closures.  (line   9)
* macro:expand <3>:                      Macros That Work.    (line  13)
* macro:expand:                          R4RS Macros.         (line  15)
* macro:load <1>:                        Syntax-Case Macros.  (line  20)
* macro:load <2>:                        Syntactic Closures.  (line  20)
* macro:load <3>:                        Macros That Work.    (line  24)
* macro:load:                            R4RS Macros.         (line  23)
* macroexpand:                           Defmacro.            (line  32)
* macroexpand-1:                         Defmacro.            (line  31)
* macwork:eval:                          Macros That Work.    (line  19)
* macwork:expand:                        Macros That Work.    (line  14)
* macwork:load:                          Macros That Work.    (line  25)
* make-array:                            Arrays.              (line  54)
* make-base on base-table:               The Base.            (line  19)
* make-bytes:                            Byte.                (line  23)
* make-cell:                             Multidimensional Space-Filling Curves.
                                                              (line  12)      |
* make-color:                            Color Data-Type.     (line  30)
* make-command-server:                   Command Service.     (line   7)
* make-directory:                        Directories.         (line  17)
* make-dynamic:                          Dynamic Data Type.   (line   9)
* make-exchanger:                        Miscellany.          (line  28)
* make-generic-method:                   Object.              (line  57)
* make-generic-predicate:                Object.              (line  62)
* make-getter on base-table:             Base Record Operations.
                                                              (line  14)
* make-getter-1 on base-table:           Base Record Operations.
                                                              (line  23)
* make-hash-table:                       Hash Tables.         (line  17)
* make-heap:                             Priority Queues.     (line  12)
* make-key->list on base-table:          Composite Keys.      (line  38)
* make-key-extractor on base-table:      Composite Keys.      (line  31)
* make-keyifier-1 on base-table:         Composite Keys.      (line   7)
* make-list:                             List construction.   (line   7)
* make-list-keyifier on base-table:      Composite Keys.      (line  17)
* make-method!:                          Object.              (line  65)
* make-nexter on base-table:             Base ISAM Operations.
                                                              (line  17)
* make-object:                           Object.              (line  46)
* make-parameter-list:                   Parameter lists.     (line  23)
* make-polar:                            Irrational Real Functions.
                                                              (line  94)
* make-predicate!:                       Object.              (line  72)
* make-prever on base-table:             Base ISAM Operations.
                                                              (line  25)
* make-promise:                          Promises.            (line   9)
* make-putter on base-table:             Base Record Operations.
                                                              (line  31)
* make-query-alist-command-server:       HTTP and CGI.        (line  92)
* make-queue:                            Queues.              (line  13)
* make-random-state:                     Exact Random Numbers.
                                                              (line  45)      |
* make-record-type:                      Records.             (line  12)
* make-rectangular:                      Irrational Real Functions.
                                                              (line  93)
* make-relational-system:                Relational Database Objects.
                                                              (line  11)
* make-ruleset:                          Commutative Rings.   (line  82)
* make-shared-array:                     Arrays.              (line  69)
* make-sierpinski-indexer:               Sierpinski Curve.    (line   9)
* make-slib-color-name-db:               Color Names.         (line  95)
* make-syntactic-closure:                Syntactic Closures.  (line 178)
* make-table on base-table:              Base Tables.         (line   7)
* make-uri:                              URI.                 (line  12)
* make-vicinity:                         Vicinity.            (line  21)
* make-wt-tree:                          Construction of Weight-Balanced Trees.
                                                              (line  51)
* make-wt-tree-type:                     Construction of Weight-Balanced Trees.
                                                              (line  19)
* map!:                                  SRFI-1.              (line 121)
* map-elts:                              Collections.         (line  40)
* map-key on base-table:                 Aggregate Base Operations.
                                                              (line  22)
* map-keys:                              Collections.         (line  56)
* matfile:load:                          MAT-File Format.     (line  25)
* matfile:read:                          MAT-File Format.     (line  19)
* matrix->array:                         Matrix Algebra.      (line  15)
* matrix->lists:                         Matrix Algebra.      (line  12)
* matrix:difference:                     Matrix Algebra.      (line  33)
* matrix:inverse:                        Matrix Algebra.      (line  47)
* matrix:product:                        Matrix Algebra.      (line  36)
* matrix:sum:                            Matrix Algebra.      (line  30)
* mdbm:report:                           Using Databases.     (line  95)
* member:                                SRFI-1.              (line 159)
* member-if:                             Lists as sets.       (line  62)
* merge:                                 Sorting.             (line  62)
* merge!:                                Sorting.             (line  67)
* mktime:                                Posix Time.          (line  54)
* mod:                                   Irrational Real Functions.
                                                              (line  52)
* modular:*:                             Modular Arithmetic.  (line  61)
* modular:+:                             Modular Arithmetic.  (line  55)
* modular:-:                             Modular Arithmetic.  (line  58)
* modular:characteristic:                Modular Arithmetic.  (line  19)
* modular:expt:                          Modular Arithmetic.  (line  67)
* modular:invert:                        Modular Arithmetic.  (line  48)
* modular:invertable?:                   Modular Arithmetic.  (line  44)
* modular:negate:                        Modular Arithmetic.  (line  52)
* modular:normalize:                     Modular Arithmetic.  (line  23)
* modulo:                                Irrational Integer Functions.
                                                              (line  29)      |
* mrna<-cdna:                            NCBI-DNA.            (line  17)
* must-be-first:                         Batch.               (line 128)
* must-be-last:                          Batch.               (line 133)
* natural->peano-coordinates:            Peano Space-Filling Curve.
                                                              (line   9)
* ncbi:read-dna-sequence:                NCBI-DNA.            (line   9)
* ncbi:read-file:                        NCBI-DNA.            (line  13)
* nconc:                                 Destructive list operations.
                                                              (line  10)
* newton:find-integer-root:              Root Finding.        (line  12)
* newton:find-root:                      Root Finding.        (line  29)
* ninth:                                 SRFI-1.              (line  65)
* not-pair?:                             SRFI-1.              (line  46)
* notany:                                Lists as sets.       (line 105)
* notevery:                              Lists as sets.       (line 109)
* nreverse:                              Destructive list operations.
                                                              (line  38)
* nthcdr:                                Lists as sequences.  (line 137)
* null-directory?:                       URI.                 (line 106)
* null-environment:                      Eval.                (line  29)
* null-list?:                            SRFI-1.              (line  44)
* object:                                Yasos interface.     (line  17)
* object->limited-string:                Object-To-String.    (line  12)
* object->string:                        Object-To-String.    (line   9)
* object-with-ancestors:                 Yasos interface.     (line  23)
* object?:                               Object.              (line  54)
* offset-time:                           Time and Date.       (line  30)
* open-base on base-table:               The Base.            (line  33)
* open-command-database:                 Database Extension.  (line  34)
* open-command-database!:                Database Extension.  (line  43)
* open-database:                         Using Databases.     (line  71)
* open-database on relational-system:    Relational Database Objects.
                                                              (line  45)
* open-database!:                        Using Databases.     (line  68)
* open-file <1>:                         Byte.                (line  77)
* open-file:                             Input/Output.        (line  18)
* open-table:                            Using Databases.     (line 108)
* open-table on base-table:              Base Tables.         (line  16)
* open-table on relational-database:     Database Operations. (line  51)
* open-table!:                           Using Databases.     (line 115)
* operate-as:                            Yasos interface.     (line  31)
* or?:                                   Non-List functions.  (line  19)
* ordered-for-each-key on base-table:    Base ISAM Operations.
                                                              (line  10)
* os->batch-dialect:                     Batch.               (line 138)
* outline-rect:                          Rectangles.          (line  33)
* output-port-height:                    Input/Output.        (line 100)
* output-port-width:                     Input/Output.        (line  94)
* overcast-sky-color-xyy:                Daylight.            (line  74)
* p<-cdna:                               NCBI-DNA.            (line  29)
* pad-range:                             Column Ranges.       (line  13)
* pair-fold:                             SRFI-1.              (line 115)
* pair-fold-right:                       SRFI-1.              (line 117)
* pair-for-each:                         SRFI-1.              (line 123)
* parameter-list->arglist:               Parameter lists.     (line  86)
* parameter-list-expand:                 Parameter lists.     (line  41)
* parameter-list-ref:                    Parameter lists.     (line  26)
* parse-ftp-address:                     URI.                 (line 117)
* partition:                             SRFI-1.              (line 132)
* partition!:                            SRFI-1.              (line 136)
* partition-page:                        Rectangles.          (line  16)
* path->uri:                             URI.                 (line  95)
* pathname->vicinity:                    Vicinity.            (line  25)
* peano-coordinates->integer:            Peano Space-Filling Curve.
                                                              (line  25)
* peano-coordinates->natural:            Peano Space-Filling Curve.
                                                              (line  15)
* plot <1>:                              Legacy Plotting.     (line  11)
* plot:                                  Character Plotting.  (line  17)
* plot-column:                           Drawing the Graph.   (line   7)
* plot-text-column:                      Drawing the Graph.   (line  59)
* pnm:array-write:                       Portable Image Files.
                                                              (line  45)      |
* pnm:image-file->array:                 Portable Image Files.
                                                              (line  35)
* pnm:type-dimensions:                   Portable Image Files.
                                                              (line   9)
* port?:                                 Input/Output.        (line  44)
* position:                              Lists as sequences.  (line   7)
* pprint-file:                           Pretty-Print.        (line  63)
* pprint-filter-file:                    Pretty-Print.        (line  69)
* prec:commentfix:                       Grammar Rule Definition.
                                                              (line 111)
* prec:define-grammar:                   Ruleset Definition and Use.
                                                              (line  24)
* prec:delim:                            Grammar Rule Definition.
                                                              (line  24)
* prec:infix:                            Grammar Rule Definition.
                                                              (line  53)
* prec:inmatchfix:                       Grammar Rule Definition.
                                                              (line 151)
* prec:make-led:                         Nud and Led Definition.
                                                              (line  49)
* prec:make-nud:                         Nud and Led Definition.
                                                              (line  39)
* prec:matchfix:                         Grammar Rule Definition.
                                                              (line 131)
* prec:nary:                             Grammar Rule Definition.
                                                              (line  72)
* prec:nofix:                            Grammar Rule Definition.
                                                              (line  29)
* prec:parse:                            Ruleset Definition and Use.
                                                              (line  33)
* prec:postfix:                          Grammar Rule Definition.
                                                              (line  85)
* prec:prefix:                           Grammar Rule Definition.
                                                              (line  36)
* prec:prestfix:                         Grammar Rule Definition.
                                                              (line  94)
* predicate->asso:                       Association Lists.   (line  17)
* predicate->hash:                       Hash Tables.         (line   9)
* predicate->hash-asso:                  Hash Tables.         (line  25)
* present? on base-table:                Base Record Operations.
                                                              (line  10)
* pretty-print:                          Pretty-Print.        (line   9)
* pretty-print->string:                  Pretty-Print.        (line  23)
* primary-limit on relational-table:     Table Administration.
                                                              (line  16)
* prime?:                                Prime Numbers.       (line  28)
* primes<:                               Prime Numbers.       (line  33)
* primes>:                               Prime Numbers.       (line  38)
* print:                                 Yasos interface.     (line  36)
* print-call-stack:                      Trace.               (line  29)
* printf:                                Standard Formatted Output.
                                                              (line   9)
* process:schedule!:                     Multi-Processing.    (line  20)
* program-arguments:                     System Interface.    (line  23)
* program-vicinity:                      Vicinity.            (line  30)
* project-table on relational-database:  Database Operations. (line  75)
* proper-list?:                          SRFI-1.              (line  38)
* protein<-cdna:                         NCBI-DNA.            (line  25)
* provide:                               Feature.             (line  58)
* provided?:                             Feature.             (line  30)
* qp:                                    Quick Print.         (line  19)
* qpn:                                   Quick Print.         (line  20)
* qpr:                                   Quick Print.         (line  21)
* queue-empty?:                          Queues.              (line  19)
* queue-front:                           Queues.              (line  39)
* queue-pop!:                            Queues.              (line  29)
* queue-push!:                           Queues.              (line  22)
* queue-rear:                            Queues.              (line  42)
* queue?:                                Queues.              (line  16)
* quo:                                   Irrational Real Functions.
                                                              (line  50)
* quotient:                              Irrational Integer Functions.
                                                              (line  27)      |
* random:                                Exact Random Numbers.
                                                              (line   9)
* random:exp:                            Inexact Random Numbers.
                                                              (line  14)
* random:hollow-sphere!:                 Inexact Random Numbers.
                                                              (line  32)
* random:normal:                         Inexact Random Numbers.
                                                              (line  20)
* random:normal-vector!:                 Inexact Random Numbers.
                                                              (line  26)
* random:solid-sphere!:                  Inexact Random Numbers.
                                                              (line  39)
* random:uniform:                        Inexact Random Numbers.
                                                              (line   9)
* rationalize:                           Rationalize.         (line   9)
* read-byte:                             Byte.                (line  89)
* read-bytes:                            Byte.                (line 107)
* read-cie-illuminant:                   Spectra.             (line  46)
* read-command:                          Command Line.        (line   9)
* read-line:                             Line I/O.            (line   9)
* read-line!:                            Line I/O.            (line  18)
* read-normalized-illuminant:            Spectra.             (line  57)
* read-options-file:                     Command Line.        (line  65)
* real-acos:                             Irrational Real Functions.
                                                              (line  20)
* real-asin:                             Irrational Real Functions.
                                                              (line  19)
* real-atan:                             Irrational Real Functions.
                                                              (line  21)
* real-cos:                              Irrational Real Functions.
                                                              (line  17)
* real-exp:                              Irrational Real Functions.
                                                              (line  13)
* real-expt:                             Irrational Real Functions.
                                                              (line  37)
* real-ln:                               Irrational Real Functions.
                                                              (line  14)
* real-log:                              Irrational Real Functions.
                                                              (line  15)
* real-sin:                              Irrational Real Functions.
                                                              (line  16)
* real-sqrt:                             Irrational Real Functions.
                                                              (line  32)
* real-tan:                              Irrational Real Functions.
                                                              (line  18)
* receive:                               Binding to multiple values.
                                                              (line   9)
* record-accessor:                       Records.             (line  41)
* record-constructor:                    Records.             (line  22)
* record-modifier:                       Records.             (line  50)
* record-predicate:                      Records.             (line  35)
* reduce <1>:                            SRFI-1.              (line 119)
* reduce <2>:                            Lists as sequences.  (line  19)
* reduce:                                Collections.         (line  71)
* reduce-init:                           Lists as sequences.  (line  61)
* rem:                                   Irrational Real Functions.
                                                              (line  51)
* remainder:                             Irrational Integer Functions.
                                                              (line  28)      |
* remove <1>:                            SRFI-1.              (line 134)
* remove:                                Lists as sets.       (line 153)
* remove!:                               SRFI-1.              (line 138)
* remove-duplicates:                     Lists as sets.       (line 199)
* remove-if:                             Lists as sets.       (line 166)
* remove-if-not:                         Lists as sets.       (line 177)
* remove-parameter:                      Parameter lists.     (line  31)
* remove-setter-for:                     Setters.             (line  49)
* repl:quit:                             Repl.                (line  17)
* repl:top-level:                        Repl.                (line  11)
* replace-suffix:                        Filenames.           (line  65)
* require <1>:                           Catalog Creation.    (line  50)
* require:                               Require.             (line  25)
* require-if:                            Require.             (line  40)
* resample-array!:                       Array Interpolation. (line  19)
* resene:                                Color Names.         (line 130)
* restrict-table on relational-database: Database Operations. (line  76)
* reverse!:                              SRFI-1.              (line  93)
* reverse-bit-field:                     Bit-Twiddling.       (line 216)
* RGB709->CIEXYZ:                        Color Conversions.   (line  30)
* rgb709->color:                         Color Spaces.        (line  46)
* rotate-bit-field:                      Bit-Twiddling.       (line 202)
* round-quotient:                        Irrational Integer Functions.
                                                              (line  32)      |
* row:delete on relational-table:        Single Row Operations.
                                                              (line  50)
* row:delete* on relational-table:       Multi-Row Operations.
                                                              (line  26)
* row:insert on relational-table:        Single Row Operations.
                                                              (line  12)
* row:insert* on relational-table:       Multi-Row Operations.
                                                              (line  41)
* row:remove on relational-table:        Single Row Operations.
                                                              (line  45)
* row:remove* on relational-table:       Multi-Row Operations.
                                                              (line  21)
* row:retrieve on relational-table:      Single Row Operations.
                                                              (line  37)
* row:retrieve* on relational-table:     Multi-Row Operations.
                                                              (line   7)
* row:update on relational-table:        Single Row Operations.
                                                              (line  31)
* row:update* on relational-table:       Multi-Row Operations.
                                                              (line  47)
* rule-horizontal:                       Legending.           (line  40)
* rule-vertical:                         Legending.           (line  32)
* saturate:                              Color Names.         (line 110)
* scanf:                                 Standard Formatted Input.
                                                              (line  13)
* scanf-read-list:                       Standard Formatted Input.
                                                              (line   9)
* scene:overcast:                        Solid Modeling.      (line  67)
* scene:panorama:                        Solid Modeling.      (line  33)
* scene:sky-and-dirt:                    Solid Modeling.      (line  50)
* scene:sky-and-grass:                   Solid Modeling.      (line  53)
* scene:sphere:                          Solid Modeling.      (line  37)
* scene:sun:                             Solid Modeling.      (line  56)
* scene:viewpoint:                       Solid Modeling.      (line  81)
* scene:viewpoints:                      Solid Modeling.      (line  88)
* scheme-report-environment:             Eval.                (line  28)
* schmooz:                               Schmooz.             (line  16)
* secant:find-bracketed-root:            Root Finding.        (line  70)
* secant:find-root:                      Root Finding.        (line  69)
* second:                                SRFI-1.              (line  55)
* seed->random-state:                    Exact Random Numbers.
                                                              (line  36)      |
* set:                                   Setters.             (line  30)
* set-color:                             Graphics Context.    (line  11)
* set-difference:                        Lists as sets.       (line  42)
* set-font:                              Graphics Context.    (line  18)
* set-glyphsize:                         Graphics Context.    (line  58)
* set-linedash:                          Graphics Context.    (line  47)
* set-linewidth:                         Graphics Context.    (line  42)
* set-margin-templates:                  Legending.           (line  27)
* Setter:                                Collections.         (line 108)
* setter:                                Setters.             (line  22)
* setup-plot:                            Column Ranges.       (line  22)
* seventh:                               SRFI-1.              (line  63)
* sft:                                   Discrete Fourier Transform.
                                                              (line  15)
* sft-1:                                 Discrete Fourier Transform.
                                                              (line  21)
* si:conversion-factor:                  Metric Units.        (line 160)
* singleton-wt-tree:                     Construction of Weight-Balanced Trees.
                                                              (line  58)
* sixth:                                 SRFI-1.              (line  62)
* size <1>:                              Collections.         (line 105)
* size:                                  Yasos interface.     (line  41)
* sky-color-xyy:                         Daylight.            (line  85)
* slib:error:                            System.              (line  46)
* slib:eval:                             System.              (line  30)
* slib:eval-load:                        System.              (line  35)
* slib:exit:                             System.              (line  52)
* slib:in-catalog?:                      Require.             (line  57)
* slib:load:                             System.              (line  20)
* slib:load-compiled:                    System.              (line  15)
* slib:load-source:                      System.              (line   9)
* slib:report:                           Configuration.       (line  43)
* slib:report-version:                   Configuration.       (line  36)
* slib:warn:                             System.              (line  43)
* snap-range:                            Column Ranges.       (line  16)
* software-type:                         Configuration.       (line  32)
* solar-declination:                     Daylight.            (line  21)
* solar-hour:                            Daylight.            (line  14)
* solar-polar:                           Daylight.            (line  23)
* solid:arrow:                           Solid Modeling.      (line 413)
* solid:basrelief:                       Solid Modeling.      (line 285)
* solid:box:                             Solid Modeling.      (line 206)
* solid:center-array-of:                 Solid Modeling.      (line 404)
* solid:center-pile-of:                  Solid Modeling.      (line 409)
* solid:center-row-of:                   Solid Modeling.      (line 400)
* solid:color:                           Solid Modeling.      (line 327)
* solid:cone:                            Solid Modeling.      (line 235)
* solid:cylinder:                        Solid Modeling.      (line 220)
* solid:disk:                            Solid Modeling.      (line 228)
* solid:ellipsoid:                       Solid Modeling.      (line 253)
* solid:font:                            Solid Modeling.      (line 365)
* solid:lumber:                          Solid Modeling.      (line 215)
* solid:polyline:                        Solid Modeling.      (line 262)
* solid:prism:                           Solid Modeling.      (line 276)
* solid:pyramid:                         Solid Modeling.      (line 241)
* solid:rotation:                        Solid Modeling.      (line 433)
* solid:scale:                           Solid Modeling.      (line 429)
* solid:sphere:                          Solid Modeling.      (line 247)
* solid:text:                            Solid Modeling.      (line 308)
* solid:texture:                         Solid Modeling.      (line 344)
* solid:translation:                     Solid Modeling.      (line 424)
* solidify-database:                     Using Databases.     (line  87)
* solidify-database on relational-database: Database Operations.
                                                              (line  42)
* some:                                  Lists as sets.       (line  73)
* sort:                                  Sorting.             (line  72)
* sort!:                                 Sorting.             (line  82)
* sorted?:                               Sorting.             (line  52)
* soundex:                               Soundex.             (line   9)
* span:                                  SRFI-1.              (line 147)
* span!:                                 SRFI-1.              (line 149)
* spectrum->chromaticity:                Spectra.             (line 114)
* spectrum->XYZ:                         Spectra.             (line  88)
* split-at:                              SRFI-1.              (line  80)
* split-at!:                             SRFI-1.              (line  81)
* sprintf:                               Standard Formatted Output.
                                                              (line  11)
* sRGB->CIEXYZ:                          Color Conversions.   (line  48)
* srgb->color:                           Color Spaces.        (line 201)
* sRGB->e-sRGB:                          Color Conversions.   (line  59)
* sRGB->xRGB:                            Color Conversions.   (line  53)
* ssax:assert-current-char:              Parsing XML.         (line  52)
* ssax:assert-token:                     Parsing XML.         (line 631)
* ssax:complete-start-tag:               Parsing XML.         (line 518)
* ssax:handle-parsed-entity:             Parsing XML.         (line 437)
* ssax:init-buffer:                      Parsing XML.         (line  64)
* ssax:make-elem-parser:                 Parsing XML.         (line 668)
* ssax:make-parser:                      Parsing XML.         (line 715)
* ssax:make-pi-parser:                   Parsing XML.         (line 648)
* ssax:next-token:                       Parsing XML.         (line  69)
* ssax:next-token-of:                    Parsing XML.         (line  83)
* ssax:read-attributes:                  Parsing XML.         (line 461)
* ssax:read-cdata-body:                  Parsing XML.         (line 386)
* ssax:read-char-data:                   Parsing XML.         (line 590)
* ssax:read-char-ref:                    Parsing XML.         (line 416)
* ssax:read-external-id:                 Parsing XML.         (line 554)
* ssax:read-markup-token:                Parsing XML.         (line 329)
* ssax:read-ncname:                      Parsing XML.         (line 294)
* ssax:read-pi-body-as-string:           Parsing XML.         (line 374)
* ssax:read-qname:                       Parsing XML.         (line 320)
* ssax:read-string:                      Parsing XML.         (line 111)
* ssax:resolve-name:                     Parsing XML.         (line 505)
* ssax:reverse-collect-str:              Parsing XML.         (line  18)
* ssax:reverse-collect-str-drop-ws:      Parsing XML.         (line  24)
* ssax:scan-misc:                        Parsing XML.         (line 578)
* ssax:skip-internal-dtd:                Parsing XML.         (line 381)
* ssax:skip-pi:                          Parsing XML.         (line 371)
* ssax:skip-s:                           Parsing XML.         (line 286)
* ssax:skip-while:                       Parsing XML.         (line  58)
* ssax:xml->sxml:                        Parsing XML.         (line 804)
* sscanf:                                Standard Formatted Input.
                                                              (line  15)
* stack:                                 Trace.               (line  49)
* stack-all:                             Debug.               (line  27)
* stackf:                                Trace.               (line  85)
* string->bytes:                         Byte.                (line  52)
* string->color:                         Color Data-Type.     (line  98)
* string-capitalize:                     String-Case.         (line  11)
* string-capitalize!:                    String-Case.         (line  16)
* string-ci->symbol:                     String-Case.         (line  19)
* string-copy:                           Rev4 Optional Procedures.
                                                              (line  14)
* string-downcase:                       String-Case.         (line  10)
* string-downcase!:                      String-Case.         (line  15)
* string-fill!:                          Rev4 Optional Procedures.
                                                              (line  16)
* string-index:                          String Search.       (line   9)
* string-index-ci:                       String Search.       (line  10)
* string-join:                           Batch.               (line 123)
* string-null?:                          Rev2 Procedures.     (line  33)
* string-reverse-index:                  String Search.       (line  14)
* string-reverse-index-ci:               String Search.       (line  15)
* string-subst:                          String Search.       (line  56)
* string-upcase:                         String-Case.         (line   9)
* string-upcase!:                        String-Case.         (line  14)
* StudlyCapsExpand:                      String-Case.         (line  29)
* sub-vicinity:                          Vicinity.            (line  73)
* subarray:                              Subarrays.           (line   9)
* subbytes:                              Byte.                (line  60)
* subbytes-read!:                        Byte.                (line 132)
* subbytes-write:                        Byte.                (line 141)
* subset?:                               Lists as sets.       (line  52)
* subst:                                 Tree Operations.     (line  11)
* substq:                                Tree Operations.     (line  12)
* substring-ci?:                         String Search.       (line  20)
* substring-fill!:                       Rev2 Procedures.     (line  30)
* substring-move-left!:                  Rev2 Procedures.     (line  13)
* substring-move-right!:                 Rev2 Procedures.     (line  14)
* substring?:                            String Search.       (line  19)
* substv:                                Tree Operations.     (line  13)
* sunlight-chromaticity:                 Daylight.            (line  65)
* sunlight-spectrum:                     Daylight.            (line  61)
* supported-key-type? on base-table:     Base Field Types.    (line  13)
* supported-type? on base-table:         Base Field Types.    (line   7)
* symbol-append:                         String-Case.         (line  23)
* symmetric:modulus:                     Modular Arithmetic.  (line  13)
* sync-base on base-table:               The Base.            (line  53)
* sync-database:                         Using Databases.     (line  83)
* sync-database on relational-database:  Database Operations. (line  37)
* syncase:eval:                          Syntax-Case Macros.  (line  15)
* syncase:expand:                        Syntax-Case Macros.  (line  10)
* syncase:load:                          Syntax-Case Macros.  (line  21)
* syncase:sanity-check:                  Syntax-Case Macros.  (line  68)
* synclo:eval:                           Syntactic Closures.  (line  15)
* synclo:expand:                         Syntactic Closures.  (line  10)
* synclo:load:                           Syntactic Closures.  (line  21)
* syntax-rules:                          Macro by Example.    (line  56)
* system:                                System Interface.    (line  16)
* system->line:                          Line I/O.            (line  35)
* table->linked-html:                    HTML Tables.         (line  34)
* table->linked-page:                    HTML Tables.         (line  42)
* table-exists? on relational-database:  Database Operations. (line  47)
* table-name->filename:                  HTML Tables.         (line  31)
* take:                                  SRFI-1.              (line  71)
* take!:                                 SRFI-1.              (line  72)
* take-right:                            SRFI-1.              (line  74)
* temperature->chromaticity:             Spectra.             (line 153)
* temperature->XYZ:                      Spectra.             (line 138)
* tenth:                                 SRFI-1.              (line  66)
* third:                                 SRFI-1.              (line  57)
* time-zone:                             Time Zone.           (line  68)
* time:gmtime:                           Time Infrastructure. (line   9)
* time:invert:                           Time Infrastructure. (line  10)
* time:split:                            Time Infrastructure. (line  11)
* title-bottom:                          Legending.           (line  12)
* title-top:                             Legending.           (line   7)
* tmpnam:                                Input/Output.        (line  65)
* tok:char-group:                        Token definition.    (line   7)
* top-refs:                              Top-level Variable References.
                                                              (line  15)
* top-refs<-file:                        Top-level Variable References.
                                                              (line  19)
* topological-sort:                      Topological Sort.    (line  13)
* trace:                                 Trace.               (line  33)
* trace-all:                             Debug.               (line  19)
* tracef:                                Trace.               (line  81)
* track:                                 Trace.               (line  41)
* track-all:                             Debug.               (line  23)
* trackf:                                Trace.               (line  83)
* transact-file-replacement:             Transactions.        (line 110)
* transcript-off:                        Transcripts.         (line  10)
* transcript-on:                         Transcripts.         (line   9)
* transformer:                           Syntactic Closures.  (line 114)
* transpose:                             Matrix Algebra.      (line  26)
* truncate-up-to:                        Batch.               (line 113)
* tsort:                                 Topological Sort.    (line  12)
* type-of:                               Type Coercion.       (line   9)
* tz:params:                             Time Zone.           (line  73)
* tz:std-offset:                         Time Zone.           (line  89)
* tzfile:read:                           Time Infrastructure. (line  15)
* tzset:                                 Time Zone.           (line  97)
* unbreak:                               Breakpoints.         (line  37)
* unbreakf:                              Breakpoints.         (line  58)
* union:                                 Lists as sets.       (line  21)
* unmake-method!:                        Object.              (line  75)
* unstack:                               Trace.               (line  71)
* untrace:                               Trace.               (line  57)
* untracef:                              Trace.               (line  96)
* untrack:                               Trace.               (line  64)
* unzip1:                                SRFI-1.              (line 100)
* unzip2:                                SRFI-1.              (line 101)
* unzip3:                                SRFI-1.              (line 102)
* unzip4:                                SRFI-1.              (line 103)
* unzip5:                                SRFI-1.              (line 104)
* uri->tree:                             URI.                 (line  47)
* uri:decode-query:                      URI.                 (line  71)
* uri:make-path:                         URI.                 (line  21)
* uri:path->keys:                        URI.                 (line  87)
* uri:split-fields:                      URI.                 (line  67)
* uric:decode:                           URI.                 (line  81)
* uric:encode:                           URI.                 (line  76)
* url->color-dictionary:                 Color Names.         (line  78)
* user-email-address:                    Transactions.        (line 145)
* user-vicinity:                         Vicinity.            (line  47)
* values:                                Values.              (line   9)
* vector->array:                         Arrays.              (line 111)
* vector-fill!:                          Rev4 Optional Procedures.
                                                              (line  18)
* vet-slib:                              Module Analysis.     (line   9)
* vicinity:suffix?:                      Vicinity.            (line  58)
* vrml:                                  Solid Modeling.      (line  12)
* vrml-append:                           Solid Modeling.      (line  16)
* vrml-to-file:                          Solid Modeling.      (line  20)
* wavelength->chromaticity:              Spectra.             (line 123)
* wavelength->XYZ:                       Spectra.             (line 118)
* whole-page <1>:                        Rectangles.          (line  11)
* whole-page:                            PostScript Graphing. (line  37)
* with-input-from-file:                  With-File.           (line   9)
* with-load-pathname:                    Vicinity.            (line  79)
* with-output-to-file:                   With-File.           (line  10)
* within-database:                       Within-database.     (line   7)
* world:info:                            Solid Modeling.      (line  24)
* wrap-command-interface:                Database Extension.  (line   7)
* write-base on base-table:              The Base.            (line  43)
* write-byte:                            Byte.                (line  82)
* write-bytes:                           Byte.                (line 118)
* write-database:                        Using Databases.     (line  80)
* write-database on relational-database: Database Operations. (line  26)
* write-line:                            Line I/O.            (line  29)
* wt-tree/add:                           Basic Operations on Weight-Balanced Trees.
                                                              (line  20)
* wt-tree/add!:                          Basic Operations on Weight-Balanced Trees.
                                                              (line  28)
* wt-tree/delete:                        Basic Operations on Weight-Balanced Trees.
                                                              (line  48)
* wt-tree/delete!:                       Basic Operations on Weight-Balanced Trees.
                                                              (line  55)
* wt-tree/delete-min:                    Indexing Operations on Weight-Balanced Trees.
                                                              (line  60)
* wt-tree/delete-min!:                   Indexing Operations on Weight-Balanced Trees.
                                                              (line  70)
* wt-tree/difference:                    Advanced Operations on Weight-Balanced Trees.
                                                              (line  49)
* wt-tree/empty?:                        Basic Operations on Weight-Balanced Trees.
                                                              (line  12)
* wt-tree/fold:                          Advanced Operations on Weight-Balanced Trees.
                                                              (line  91)
* wt-tree/for-each:                      Advanced Operations on Weight-Balanced Trees.
                                                              (line 112)
* wt-tree/index:                         Indexing Operations on Weight-Balanced Trees.
                                                              (line  12)
* wt-tree/index-datum:                   Indexing Operations on Weight-Balanced Trees.
                                                              (line  13)
* wt-tree/index-pair:                    Indexing Operations on Weight-Balanced Trees.
                                                              (line  14)
* wt-tree/intersection:                  Advanced Operations on Weight-Balanced Trees.
                                                              (line  38)
* wt-tree/lookup:                        Basic Operations on Weight-Balanced Trees.
                                                              (line  41)
* wt-tree/member?:                       Basic Operations on Weight-Balanced Trees.
                                                              (line  35)
* wt-tree/min:                           Indexing Operations on Weight-Balanced Trees.
                                                              (line  43)
* wt-tree/min-datum:                     Indexing Operations on Weight-Balanced Trees.
                                                              (line  44)
* wt-tree/min-pair:                      Indexing Operations on Weight-Balanced Trees.
                                                              (line  45)
* wt-tree/rank:                          Indexing Operations on Weight-Balanced Trees.
                                                              (line  35)
* wt-tree/set-equal?:                    Advanced Operations on Weight-Balanced Trees.
                                                              (line  74)
* wt-tree/size:                          Basic Operations on Weight-Balanced Trees.
                                                              (line  16)
* wt-tree/split<:                        Advanced Operations on Weight-Balanced Trees.
                                                              (line  11)
* wt-tree/split>:                        Advanced Operations on Weight-Balanced Trees.
                                                              (line  18)
* wt-tree/subset?:                       Advanced Operations on Weight-Balanced Trees.
                                                              (line  59)
* wt-tree/union:                         Advanced Operations on Weight-Balanced Trees.
                                                              (line  25)
* wt-tree/union-merge:                   Advanced Operations on Weight-Balanced Trees.
                                                              (line 125)      |
* x-axis:                                Legending.           (line  51)
* xcons:                                 SRFI-1.              (line  15)
* xRGB->CIEXYZ:                          Color Conversions.   (line  51)
* xrgb->color:                           Color Spaces.        (line 221)
* xRGB->sRGB:                            Color Conversions.   (line  54)
* xyY->XYZ:                              Spectra.             (line 191)
* xyY:normalize-colors:                  Spectra.             (line 193)
* XYZ->chromaticity:                     Spectra.             (line 168)
* XYZ->xyY:                              Spectra.             (line 187)
* y-axis:                                Legending.           (line  48)
* zenith-xyy:                            Daylight.            (line  70)
* zip:                                   SRFI-1.              (line  98)

Variable Index
**************

 [index ]
* Menu:

* *argv*:                                Getopt.              (line  25)
* *base-table-implementations*:          Base Table.          (line  52)
* *catalog*:                             Require.             (line  10)
* *http:byline*:                         HTTP and CGI.        (line  17)
* *operating-system*:                    Batch.               (line  41)
* *optarg*:                              Getopt.              (line  35)
* *optind*:                              Getopt.              (line  30)
* *qp-width*:                            Quick Print.         (line  28)
* *random-state*:                        Exact Random Numbers.
                                                              (line  21)
* *ruleset*:                             Commutative Rings.   (line  76)
* *syn-defs*:                            Ruleset Definition and Use.
                                                              (line   7)
* *syn-ignore-whitespace*:               Ruleset Definition and Use.
                                                              (line  12)
* *timezone*:                            Time Zone.           (line 111)
* atm-hec-polynomial:                    Cyclic Checksum.     (line 116)
* bottomedge:                            Legending.           (line  18)
* char-code-limit:                       Configuration.       (line  11)
* charplot:dimensions:                   Character Plotting.  (line   9)
* CIEXYZ:A:                              Color Conversions.   (line  21)
* CIEXYZ:B:                              Color Conversions.   (line  22)
* CIEXYZ:C:                              Color Conversions.   (line  23)
* CIEXYZ:D50:                            Color Conversions.   (line  17)
* CIEXYZ:D65:                            Color Conversions.   (line  13)
* CIEXYZ:E:                              Color Conversions.   (line  24)
* crc-08-polynomial:                     Cyclic Checksum.     (line 110)
* crc-10-polynomial:                     Cyclic Checksum.     (line  99)
* crc-12-polynomial:                     Cyclic Checksum.     (line  78)
* crc-16-polynomial:                     Cyclic Checksum.     (line  70)
* crc-32-polynomial:                     Cyclic Checksum.     (line  46)
* crc-ccitt-polynomial:                  Cyclic Checksum.     (line  62)
* D50:                                   Color Data-Type.     (line 120)
* D65:                                   Color Data-Type.     (line 116)
* daylight?:                             Time Zone.           (line 117)
* debug:max-count:                       Trace.               (line  24)
* distribute*:                           Commutative Rings.   (line 100)
* distribute/:                           Commutative Rings.   (line 104)
* dowcrc-polynomial:                     Cyclic Checksum.     (line 121)
* graph:dimensions:                      Legacy Plotting.     (line   7)
* graphrect:                             Rectangles.          (line  26)
* leftedge:                              Legending.           (line  22)
* most-positive-fixnum:                  Configuration.       (line  15)
* nil:                                   Miscellany.          (line  61)
* number-wt-type:                        Construction of Weight-Balanced Trees.
                                                              (line  39)
* plotrect:                              Rectangles.          (line  22)
* prime:prngs:                           Prime Numbers.       (line   9)
* prime:trials:                          Prime Numbers.       (line  24)
* rightedge:                             Legending.           (line  23)
* slib:form-feed:                        Configuration.       (line  29)
* slib:tab:                              Configuration.       (line  26)
* stderr:                                Standard Formatted I/O.
                                                              (line  25)
* stdin:                                 Standard Formatted I/O.
                                                              (line  19)
* stdout:                                Standard Formatted I/O.
                                                              (line  22)
* string-wt-type:                        Construction of Weight-Balanced Trees.
                                                              (line  45)
* t:                                     Miscellany.          (line  58)
* tok:decimal-digits:                    Token definition.    (line  41)
* tok:lower-case:                        Token definition.    (line  48)
* tok:upper-case:                        Token definition.    (line  44)
* tok:whitespaces:                       Token definition.    (line  52)
* topedge:                               Legending.           (line  17)
* tzname:                                Time Zone.           (line 123)
* usb-token-polynomial:                  Cyclic Checksum.     (line 125)

Concept and Feature Index
*************************

 [index ]
* Menu:

* =>:                                    Guarded COND Clause. (line  21)
* aggregate <1>:                         Module Semantics.    (line  20)
* aggregate:                             Library Catalogs.    (line  24)
* alarm:                                 Multi-Processing.    (line  10)
* alarm-interrupt:                       Multi-Processing.    (line  10)
* alist:                                 Association Lists.   (line   6)
* alist-table <1>:                       Relational Database Objects.
                                                              (line  23)
* alist-table <2>:                       The Base.            (line  12)
* alist-table:                           Base Table.          (line  16)
* and-let*:                              Guarded LET* special form.
                                                              (line   6)
* ange-ftp:                              URI.                 (line 118)
* appearance:                            Solid Modeling.      (line 334)
* array:                                 Arrays.              (line   6)
* array-for-each:                        Array Mapping.       (line   6)
* association function:                  Association Lists.   (line  17)
* Attribute:                             Parsing XML.         (line 461)
* attribute-value:                       HTML.                (line  10)
* AttValue:                              Parsing XML.         (line 473)
* Auto-sharing:                          Using Databases.     (line  25)
* balanced binary trees:                 Weight-Balanced Trees.
                                                              (line   8)
* base:                                  URI.                 (line  39)
* base-table:                            Base Table.          (line   6)
* batch:                                 Batch.               (line   6)
* bignum:                                Feature.             (line  13)
* binary:                                Byte.                (line  76)
* binary trees:                          Weight-Balanced Trees.
                                                              (line   8)
* binary trees, as discrete maps:        Weight-Balanced Trees.
                                                              (line  52)
* binary trees, as sets:                 Weight-Balanced Trees.
                                                              (line  52)
* binding power:                         Precedence Parsing Overview.
                                                              (line  22)
* break:                                 Breakpoints.         (line   6)
* byte:                                  Byte.                (line   6)
* byte-number:                           Byte/Number Conversions.
                                                              (line   6)
* calendar time <1>:                     Posix Time.          (line  10)
* calendar time:                         Time and Date.       (line  16)
* Calendar-Time:                         Posix Time.          (line  10)
* caltime:                               Posix Time.          (line  10)
* canonical:                             Color Names.         (line  16)
* careful:                               Commutative Rings.   (line  14)
* catalog:                               Require.             (line   6)
* Catalog File:                          Library Catalogs.    (line   6)
* certificate:                           Transactions.        (line  36)
* cgi:                                   HTTP and CGI.        (line   6)
* chapter-order:                         Chapter Ordering.    (line   6)
* charplot:                              Character Plotting.  (line   6)
* Chroma:                                Color Spaces.        (line 145)
* cie1931:                               Spectra.             (line  32)
* cie1964:                               Spectra.             (line  27)
* ciexyz:                                Spectra.             (line  37)
* CIEXYZ:                                Color Spaces.        (line  18)
* cksum-string:                          Cyclic Checksum.     (line 161)
* coerce:                                Type Coercion.       (line   6)
* collect:                               Collections.         (line   6)
* color-database:                        Color Names.         (line  66)
* color-names:                           Color Names.         (line   6)
* command line:                          Command Line.        (line  10)
* commentfix:                            Rule Types.          (line  35)
* common-list-functions <1>:             Common List Functions.
                                                              (line   6)
* common-list-functions:                 Collections.         (line  81)
* commutative-ring:                      Commutative Rings.   (line  11)
* compiled:                              Library Catalogs.    (line  21)
* compiling:                             Module Conventions.  (line  11)
* complex:                               Feature.             (line  13)
* Coordinated Universal Time:            Posix Time.          (line  13)
* copyright:                             Copyrights.          (line   6)
* crc:                                   Cyclic Checksum.     (line   6)
* cvs:                                   CVS.                 (line   6)
* database-commands:                     Command Example.     (line  10)
* databases <1>:                         Command Example.     (line  11)
* databases <2>:                         Define-tables Example.
                                                              (line  12)
* databases <3>:                         Using Databases.     (line   6)
* databases:                             Batch.               (line 145)
* daylight:                              Daylight.            (line   6)
* db->html:                              HTML Tables.         (line   6)
* debug <1>:                             Breakpoints.         (line  11)
* debug:                                 Debug.               (line   6)
* define-record-type:                    Define-Record-Type.  (line   6)
* defmacro:                              Library Catalogs.    (line  31)
* defmacroexpand <1>:                    Pretty-Print.        (line  88)
* defmacroexpand:                        Defmacro.            (line  49)
* delim:                                 Rule Types.          (line  47)
* dequeues:                              Queues.              (line  10)
* determinant:                           Matrix Algebra.      (line   6)
* dft, Fourier-transform:                Discrete Fourier Transform.
                                                              (line   6)
* diff:                                  Sequence Comparison. (line   6)
* directory:                             Directories.         (line   6)
* Discrete Fourier Transform:            Discrete Fourier Transform.
                                                              (line  18)
* discrete maps, using binary trees:     Weight-Balanced Trees.
                                                              (line  52)
* DrScheme:                              Installation.        (line 151)
* dynamic:                               Dynamic Data Type.   (line   6)
* dynamic-wind:                          Dynamic-Wind.        (line   6)
* e-sRGB:                                Color Spaces.        (line 224)
* ELK:                                   Installation.        (line 147)
* emacs:                                 Transactions.        (line  33)
* Encapsulated-PostScript:               PostScript Graphing. (line  23)
* escaped:                               URI.                 (line  77)
* EUC:                                   Extra-SLIB Packages. (line  45)
* Euclidean Domain:                      Commutative Rings.   (line  67)
* eval:                                  Eval.                (line   6)
* exchanger:                             Miscellany.          (line  22)
* factor:                                Prime Numbers.       (line   6)
* feature <1>:                           About this manual.   (line  13)
* feature <2>:                           Require.             (line  18)
* feature:                               Feature.             (line   6)
* File Transfer Protocol:                URI.                 (line 113)
* file-lock:                             Transactions.        (line  32)
* filename <1>:                          Batch.               (line 148)
* filename:                              Filenames.           (line   6)
* fluid-let:                             Fluid-Let.           (line   6)
* fold:                                  Parsing XML.         (line 401)
* form:                                  HTML.                (line  63)
* format:                                Format.              (line   6)
* Gambit-C 3.0:                          Installation.        (line 161)
* gamut:                                 Color Spaces.        (line  18)
* Gauche-0.9:                            Installation.        (line 141)
* generic-write:                         Generic-Write.       (line   6)
* getenv:                                System Interface.    (line   6)
* getit:                                 URI.                 (line 118)
* getopt <1>:                            Command Example.     (line  14)
* getopt:                                Getopt.              (line   6)
* getopt-parameters <1>:                 Command Example.     (line  12)
* getopt-parameters:                     Getopt Parameter lists.
                                                              (line   6)
* glob:                                  Filenames.           (line   6)
* Gray code:                             Hilbert Space-Filling Curve.
                                                              (line  53)      |
* guarded-cond-clause:                   Guarded COND Clause. (line   6)
* Guile:                                 Installation.        (line 170)
* hash:                                  Hashing.             (line   6)
* hash-table:                            Hash Tables.         (line   6)
* Hilbert:                               Hilbert Space-Filling Curve.
                                                              (line   8)
* Hilbert Space-Filling Curve:           Hilbert Space-Filling Curve.
                                                              (line   8)
* hilbert-fill:                          Hilbert Space-Filling Curve.
                                                              (line   6)
* HOME <1>:                              Vicinity.            (line  51)
* HOME:                                  Catalog Creation.    (line  21)
* homecat:                               Catalog Vicinities.  (line  35)
* html-for-each:                         Parsing HTML.        (line   6)
* html-form:                             HTML.                (line   6)
* http:                                  HTTP and CGI.        (line   6)
* Hue:                                   Color Spaces.        (line 147)
* ICC Profile:                           Color Spaces.        (line 197)
* implcat:                               Catalog Vicinities.  (line  23)
* indexed-sequential-access-method:      Byte/Number Conversions.
                                                              (line 129)      |
* inexact:                               Feature.             (line  13)
* infix:                                 Rule Types.          (line  19)
* Info:                                  Top-level Variable References.
                                                              (line  32)
* inmatchfix:                            Rule Types.          (line  43)
* install:                               Installation.        (line   6)
* installation:                          Installation.        (line   6)
* intrinsic feature:                     Feature.             (line   9)
* ISAM:                                  Indexed Sequential Access Methods.
                                                              (line   6)
* Japanese:                              Extra-SLIB Packages. (line  45)
* JFILTER:                               Extra-SLIB Packages. (line  45)
* JIS:                                   Extra-SLIB Packages. (line  45)
* Kawa:                                  Installation.        (line 167)
* L*a*b*:                                Color Spaces.        (line  68)
* L*C*h:                                 Color Spaces.        (line 139)
* L*u*v*:                                Color Spaces.        (line 100)
* lamination:                            Hilbert Space-Filling Curve.
                                                              (line  89)      |
* Larceny:                               Installation.        (line 132)
* Left Denotation, led:                  Nud and Led Definition.
                                                              (line  13)
* let-values:                            Binding to multiple values.
                                                              (line  11)
* Lightness:                             Color Spaces.        (line  71)
* line-i:                                Line I/O.            (line   6)
* list-processing library:               SRFI-1.              (line   8)
* load-option:                           Weight-Balanced Trees.
                                                              (line  73)
* logical:                               Bit-Twiddling.       (line   6)
* macro <1>:                             Repl.                (line  32)
* macro <2>:                             R4RS Macros.         (line   6)
* macro:                                 Library Catalogs.    (line  37)
* macro-by-example <1>:                  Macro by Example.    (line   6)
* macro-by-example:                      Library Catalogs.    (line  34)
* macros-that-work <1>:                  Macros That Work.    (line   6)
* macros-that-work:                      Library Catalogs.    (line  40)
* manifest:                              Module Manifests.    (line   6)
* match:                                 Match Keys.          (line   6)
* match-keys <1>:                        Match Keys.          (line   6)
* match-keys:                            Match-Keys.          (line   6)
* matchfix:                              Rule Types.          (line  39)
* matfile:                               MAT-File Format.     (line   6)
* math-integer:                          Irrational Integer Functions.
                                                              (line   6)
* math-real:                             Irrational Real Functions.
                                                              (line   6)
* matlab:                                MAT-File Format.     (line   6)
* metric-units:                          Metric Units.        (line   6)
* minimize:                              Minimizing.          (line   6)
* minimum field width (printf):          Standard Formatted Output.
                                                              (line  88)
* MIT Scheme:                            Installation.        (line 158)
* mkimpcat.scm:                          Catalog Vicinities.  (line  28)
* mklibcat.scm:                          Catalog Vicinities.  (line  16)
* modular:                               Modular Arithmetic.  (line   6)
* multiarg:                              Multi-argument / and -.
                                                              (line   6)
* multiarg-apply:                        Multi-argument Apply.
                                                              (line   6)
* MzScheme:                              Installation.        (line 152)
* nary:                                  Rule Types.          (line  23)
* ncbi-dma:                              NCBI-DNA.            (line   6)
* new-catalog:                           Catalog Creation.    (line  50)
* nofix:                                 Rule Types.          (line  11)
* null:                                  HTML Tables.         (line  92)
* Null Denotation, nud:                  Nud and Led Definition.
                                                              (line   9)
* object:                                Object.              (line   6)
* object->string:                        Object-To-String.    (line   6)
* oop:                                   Yasos.               (line   6)
* option, run-time-loadable:             Weight-Balanced Trees.
                                                              (line  69)
* options file:                          Command Line.        (line  65)
* parameters <1>:                        Command Example.     (line  13)
* parameters <2>:                        Batch.               (line 146)
* parameters:                            Parameter lists.     (line   6)
* parse:                                 Precedence Parsing.  (line   6)
* pbm:                                   Portable Image Files.
                                                              (line  22)
* pbm-raw:                               Portable Image Files.
                                                              (line  22)
* peano-fill:                            Peano Space-Filling Curve.
                                                              (line   6)
* pgm:                                   Portable Image Files.
                                                              (line  26)
* pgm-raw:                               Portable Image Files.
                                                              (line  26)
* plain-text:                            HTML.                (line  14)
* PLT Scheme:                            Installation.        (line 150)
* pnm:                                   Portable Image Files.
                                                              (line   6)
* portable bitmap graphics:              Portable Image Files.
                                                              (line   9)
* posix-time:                            Posix Time.          (line   7)
* postfix:                               Rule Types.          (line  27)
* ppm:                                   Portable Image Files.
                                                              (line  31)
* ppm-raw:                               Portable Image Files.
                                                              (line  31)
* pprint-file:                           Pretty-Print.        (line  60)
* PRE:                                   HTML.                (line  50)
* precedence:                            Precedence Parsing.  (line   6)
* precision (printf):                    Standard Formatted Output.
                                                              (line 101)
* prefix:                                Rule Types.          (line  15)
* prestfix:                              Rule Types.          (line  31)
* pretty-print:                          Pretty-Print.        (line   6)
* primes:                                Prime Numbers.       (line   6)
* printf:                                Standard Formatted Output.
                                                              (line   6)
* priority-queue:                        Priority Queues.     (line   6)
* PRNG:                                  Random Numbers.      (line   6)
* process:                               Multi-Processing.    (line   6)
* program-arguments <1>:                 System Interface.    (line  20)
* program-arguments:                     Getopt.              (line 102)
* Prolog:                                Extra-SLIB Packages. (line  41)
* promise:                               Promises.            (line   6)
* PSD:                                   Extra-SLIB Packages. (line  26)
* qp <1>:                                Quick Print.         (line   6)
* qp:                                    Getopt.              (line 146)
* query-string:                          HTTP and CGI.        (line  36)
* queue:                                 Queues.              (line   6)
* r2rs:                                  RnRS.                (line  11)
* r3rs <1>:                              Coding Guidelines.   (line  10)
* r3rs:                                  RnRS.                (line  16)
* r4rs:                                  RnRS.                (line  24)
* r5rs:                                  RnRS.                (line  29)
* random:                                Exact Random Numbers.
                                                              (line   6)
* random-inexact:                        Inexact Random Numbers.
                                                              (line   6)
* range:                                 Column Ranges.       (line   6)
* rational:                              Feature.             (line  13)
* rationalize:                           Rationalize.         (line   6)
* read-command:                          Command Line.        (line   6)
* real:                                  Feature.             (line  13)
* receive:                               Binding to multiple values.
                                                              (line   6)
* record:                                Records.             (line   6)
* rectangle:                             Rectangles.          (line   6)
* relational-database:                   Relational Database. (line   6)
* relational-system:                     Using Databases.     (line  53)
* repl <1>:                              Repl.                (line   6)
* repl:                                  Syntax-Case Macros.  (line  62)
* resene:                                Color Names.         (line 127)
* Resene:                                Color Names.         (line  96)
* reset:                                 HTML.                (line  95)
* rev2-procedures:                       Rev2 Procedures.     (line   6)
* rev4-optional-procedures:              Rev4 Optional Procedures.
                                                              (line   6)
* RGB709:                                Color Spaces.        (line  37)
* ring, commutative:                     Commutative Rings.   (line  11)
* RNG:                                   Random Numbers.      (line   6)
* root:                                  Root Finding.        (line   6)
* run-time-loadable option:              Weight-Balanced Trees.
                                                              (line  69)
* rwb-isam:                              Base Table.          (line  39)
* S7:                                    Installation.        (line 238)
* saturate:                              Color Names.         (line  96)
* scanf:                                 Standard Formatted Input.
                                                              (line   6)
* SCHELOG:                               Extra-SLIB Packages. (line  41)
* scheme:                                URI.                 (line  99)
* Scheme Request For Implementation:     SRFI.                (line   8)
* Scheme48:                              Installation.        (line 199)
* schmooz:                               Schmooz.             (line   6)
* SCM:                                   Installation.        (line 127)
* script:                                Installation.        (line  37)
* self-set:                              Commutative Rings.   (line  17)
* Sequence Comparison:                   Sequence Comparison. (line   6)
* Server-based Naming Authority:         URI.                 (line  58)
* session:                               Feature.             (line   7)
* sets, using binary trees:              Weight-Balanced Trees.
                                                              (line  52)
* shell:                                 Command Line.        (line  12)
* sierpinski:                            Sierpinski Curve.    (line   6)
* SISC:                                  Installation.        (line 164)
* sitecat:                               Catalog Vicinities.  (line  19)
* sky:                                   Daylight.            (line   6)
* slib:                                  Installation.        (line  37)
* slibcat:                               Catalog Vicinities.  (line  11)
* solid:                                 Solid Modeling.      (line   6)
* solid-modeling:                        Solid Modeling.      (line   6)
* solids:                                Solid Modeling.      (line   6)
* sort:                                  Sorting.             (line   6)
* soundex:                               Soundex.             (line   6)
* source:                                Library Catalogs.    (line  18)
* Space-Filling:                         Hilbert Space-Filling Curve.
                                                              (line   8)
* space-filling:                         Multidimensional Space-Filling Curves.
                                                              (line   6)      |
* sparse:                                MAT-File Format.     (line  15)
* Spectral Tristimulus Values:           Spectra.             (line  24)
* spiff:                                 Sequence Comparison. (line  29)
* srfi:                                  SRFI.                (line   6)
* SRFI-1:                                SRFI-1.              (line   8)
* srfi-1:                                SRFI-1.              (line   6)
* srfi-11 <1>:                           SRFI.                (line  37)
* srfi-11:                               Binding to multiple values.
                                                              (line  11)
* srfi-2 <1>:                            SRFI.                (line  33)
* srfi-2:                                Guarded LET* special form.
                                                              (line   6)
* srfi-23:                               SRFI.                (line  39)
* srfi-28:                               SRFI.                (line  41)
* srfi-39 <1>:                           SRFI.                (line  43)
* srfi-39:                               Parameter Objects.   (line   6)
* srfi-47:                               SRFI.                (line  45)
* srfi-59:                               SRFI.                (line  47)
* srfi-60 <1>:                           SRFI.                (line  49)
* srfi-60:                               Bit-Twiddling.       (line   6)
* srfi-61 <1>:                           SRFI.                (line  51)
* srfi-61:                               Guarded COND Clause. (line   6)
* srfi-63:                               SRFI.                (line  53)
* srfi-8 <1>:                            SRFI.                (line  33)
* srfi-8:                                Binding to multiple values.
                                                              (line   6)
* srfi-9 <1>:                            SRFI.                (line  35)
* srfi-9:                                Define-Record-Type.  (line   6)
* srfi-94:                               SRFI.                (line  55)
* srfi-95 <1>:                           SRFI.                (line  58)
* srfi-95:                               Sorting.             (line   6)
* srfi-96:                               SRFI.                (line  60)
* sRGB:                                  Color Spaces.        (line 195)
* stdio:                                 Standard Formatted I/O.
                                                              (line  14)
* string-case:                           String-Case.         (line   6)
* string-port:                           String Ports.        (line   6)
* string-search:                         String Search.       (line   6)
* subarray:                              Subarrays.           (line   6)
* sun:                                   Daylight.            (line   6)
* sunlight:                              Daylight.            (line   6)
* symmetric:                             Modular Arithmetic.  (line  38)
* syntactic-closures <1>:                Syntactic Closures.  (line   6)
* syntactic-closures:                    Library Catalogs.    (line  46)
* syntax tree:                           Precedence Parsing Overview.
                                                              (line  32)
* syntax-case <1>:                       Syntax-Case Macros.  (line   6)
* syntax-case:                           Library Catalogs.    (line  43)
* system:                                System Interface.    (line  13)
* time:                                  Time and Date.       (line  16)
* time-zone:                             Time Zone.           (line  63)
* top-level variable references:         Top-level Variable References.
                                                              (line   6)
* top-refs:                              Top-level Variable References.
                                                              (line   6)
* topological-sort:                      Topological Sort.    (line   6)
* trace:                                 Trace.               (line   6)
* transact:                              Transactions.        (line  10)
* transcript:                            Transcripts.         (line   6)
* tree:                                  Tree Operations.     (line   6)
* trees, balanced binary:                Weight-Balanced Trees.
                                                              (line   8)
* tristimulus:                           Color Spaces.        (line   9)
* tsort:                                 Topological Sort.    (line   6)
* turbidity:                             Daylight.            (line  31)
* TZ-string:                             Time Zone.           (line   9)
* Uniform Resource Identifiers:          URI.                 (line   8)
* Uniform Resource Locator:              URI.                 (line 118)
* Unique Factorization:                  Commutative Rings.   (line  67)
* unsafe:                                URI.                 (line  77)
* URI:                                   URI.                 (line  71)
* uri:                                   URI.                 (line   6)
* URI:                                   HTTP and CGI.        (line  36)
* usercat:                               Catalog Vicinities.  (line  38)
* UTC:                                   Posix Time.          (line  13)
* values:                                Values.              (line   6)
* variable references:                   Top-level Variable References.
                                                              (line   6)
* vet:                                   Module Analysis.     (line   6)
* VSCM:                                  Installation.        (line 210)
* WB:                                    Base Table.          (line  34)
* wb-table:                              Base Table.          (line  32)
* weight-balanced binary trees:          Weight-Balanced Trees.
                                                              (line   8)
* wget:                                  Color Names.         (line  82)
* white point:                           Color Data-Type.     (line 107)
* wild-card:                             Match Keys.          (line   6)
* with-file:                             With-File.           (line   6)
* Word:                                  Transactions.        (line  34)
* wt-tree:                               Weight-Balanced Trees.
                                                              (line   6)
* xRGB:                                  Color Spaces.        (line 210)
* xyY:                                   Spectra.             (line 178)
* yasos:                                 Yasos.               (line   6)



Tag Table:
Node: Top912
Node: The Library System2118
Node: Feature2868
Ref: Feature-Footnote-14794
Node: Require5648
Node: Library Catalogs8144
Node: Catalog Creation9658
Node: Catalog Vicinities12297
Node: Compiling Scheme15140
Node: Module Conventions15873
Ref: Module Conventions-Footnote-116454
Node: Module Manifests17627
Node: Module Semantics23182
Node: Top-level Variable References24883
Ref: Top-level Variable References-Footnote-125881
Node: Module Analysis27366
Node: Universal SLIB Procedures28554
Node: Vicinity29252
Node: Configuration33190
Node: Input/Output36253
Node: System40291
Node: Miscellany43572
Node: Scheme Syntax Extension Packages45558
Node: Defmacro46620
Node: R4RS Macros48710
Node: Macro by Example50084
Node: Macros That Work53065
Node: Syntactic Closures59169
Node: Syntax-Case Macros76807
Node: Define-Structure80848
Node: Define-Record-Type83299
Node: Fluid-Let84015
Node: Parameter Objects85379
Node: Binding to multiple values86159
Node: Guarded LET* special form86897
Node: Guarded COND Clause87381
Node: Yasos89304
Node: Yasos terms90492
Node: Yasos interface91680
Node: Setters93931
Node: Yasos examples96738
Node: Textual Conversion Packages99843
Node: Precedence Parsing100779
Node: Precedence Parsing Overview101547
Ref: Precedence Parsing Overview-Footnote-198120
Node: Rule Types103260
Node: Ruleset Definition and Use104798
Node: Token definition107469
Node: Nud and Led Definition109838
Node: Grammar Rule Definition112382
Node: Format120061
Node: Format Interface120423
Node: Format Specification122099
Node: Standard Formatted I/O133127
Node: Standard Formatted Output133798
Node: Standard Formatted Input143419
Node: Programs and Arguments150179
Node: Getopt150761
Node: Command Line157390
Node: Parameter lists160671
Node: Getopt Parameter lists164660
Node: Filenames167984
Node: Batch171957
Node: HTML179875
Node: HTML Tables186400
Node: HTTP and CGI193015
Node: Parsing HTML198279
Node: URI200975
Node: Parsing XML205726
Node: Printing Scheme238696
Node: Generic-Write239106
Node: Object-To-String240605
Node: Pretty-Print241107
Node: Time and Date244198
Node: Time Zone245338
Node: Posix Time250163
Node: Common-Lisp Time252414
Node: Time Infrastructure254123
Node: NCBI-DNA254557
Node: Schmooz256012
Node: Mathematical Packages260331
Node: Bit-Twiddling261169
Node: Modular Arithmetic269818
Node: Irrational Integer Functions272332
Node: Irrational Real Functions274096
Node: Prime Numbers278385
Node: Random Numbers280172
Node: Exact Random Numbers281102
Node: Inexact Random Numbers283458
Node: Discrete Fourier Transform285375
Node: Cyclic Checksum287893
Node: Graphing295607
Node: Character Plotting295885
Node: PostScript Graphing301480
Node: Column Ranges303342
Node: Drawing the Graph304904
Node: Graphics Context308162
Node: Rectangles310808
Node: Legending312338
Node: Legacy Plotting314650
Node: Example Graph315865
Node: Solid Modeling320315
Node: Color339908
Node: Color Data-Type340827
Ref: Color Data-Type-Footnote-1331893
Node: Color Spaces345301
Ref: Color Spaces-Footnote-1341906
Node: Spectra355311
Node: Color Difference Metrics364294
Node: Color Conversions367353
Node: Color Names369580
Node: Daylight376600
Node: Root Finding381372
Node: Minimizing385575
Ref: Minimizing-Footnote-1373682
Node: The Limit387700
Node: Commutative Rings392653
Node: Matrix Algebra404147
Node: Database Packages405708
Node: Relational Database406074
Node: Using Databases407024
Node: Table Operations413614
Node: Single Row Operations414908
Node: Match-Keys417238
Node: Multi-Row Operations419400
Node: Indexed Sequential Access Methods421874
Node: Sequential Index Operations422865
Node: Table Administration425304
Node: Database Interpolation426254
Node: Embedded Commands427439
Node: Database Extension429096
Node: Command Intrinsics431304
Node: Define-tables Example432949
Node: The *commands* Table434682
Node: Command Service437043
Node: Command Example439088
Node: Database Macros443724
Node: Within-database444692
Node: Within-database Example447682
Node: Database Browser449552
Node: Relational Infrastructure450710
Node: Base Table451097
Node: The Base453688
Node: Base Tables456889
Node: Base Field Types458448
Node: Composite Keys459314
Node: Base Record Operations461451
Node: Match Keys463262
Node: Aggregate Base Operations464226
Node: Base ISAM Operations465374
Node: Catalog Representation466775
Node: Relational Database Objects469527
Node: Database Operations472254
Node: Weight-Balanced Trees476041
Node: Construction of Weight-Balanced Trees480010
Node: Basic Operations on Weight-Balanced Trees483559
Node: Advanced Operations on Weight-Balanced Trees486509
Node: Indexing Operations on Weight-Balanced Trees496073
Node: Other Packages499997
Node: Data Structures500609
Node: Arrays501533
Node: Subarrays510303
Node: Array Mapping512607
Node: Array Interpolation515490
Node: Association Lists516837
Node: Byte519196
Node: Byte/Number Conversions525298
Node: MAT-File Format533005
Node: Portable Image Files534367
Node: Collections536081
Node: Dynamic Data Type542277
Node: Hash Tables543639
Node: Object546310
Node: Priority Queues554676
Node: Queues555614
Node: Records556942
Node: Sorting and Searching560535
Node: Common List Functions561317
Node: List construction561857
Node: Lists as sets563655
Node: Lists as sequences570276
Node: Destructive list operations575648
Node: Non-List functions578409
Node: Tree Operations579581
Node: Chapter Ordering581357
Node: Sorting583087
Node: Topological Sort586696
Node: Hashing588487
Node: Space-Filling Curves589587
Node: Multidimensional Space-Filling Curves590080
Node: Hilbert Space-Filling Curve594720
Node: Peano Space-Filling Curve598870
Node: Sierpinski Curve600105
Node: Soundex602707
Node: String Search604388
Node: Sequence Comparison607044
Node: Procedures610257
Node: Type Coercion610868
Node: String-Case611383
Node: String Ports613293
Node: Line I/O614148
Node: Multi-Processing616280
Node: Metric Units617481
Node: Standards Support625843
Node: RnRS626722
Node: With-File628028
Node: Transcripts628387
Node: Rev2 Procedures628804
Node: Rev4 Optional Procedures630620
Node: Multi-argument / and -631172
Node: Multi-argument Apply631665
Node: Rationalize632085
Node: Promises633330
Node: Dynamic-Wind633859
Node: Eval635210
Node: Values638638
Node: SRFI639536
Node: SRFI-1641307
Node: Session Support645897
Node: Repl646554
Node: Quick Print647933
Node: Debug649322
Node: Breakpoints650312
Node: Trace652437
Node: System Interface655746
Node: Directories656646
Node: Transactions658944
Node: CVS665064
Node: Extra-SLIB Packages666314
Node: About SLIB668681
Node: Installation669633
Node: The SLIB script680252
Node: Porting680834
Ref: Porting-Footnote-1652860
Node: Compiled and Implementation-Specific Features682668
Node: Coding Guidelines683890
Node: Copyrights686425
Node: About this manual689963
Node: GNU Free Documentation License690645
Node: Index715884

End Tag Table
